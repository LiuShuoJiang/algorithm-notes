/*
输入一个长度为n的整数数列，从小到大输出前m小的数。

输入格式
第一行包含整数n和m。
第二行包含n个整数，表示整数数列。

输出格式
共一行，包含m个整数，表示整数数列中前m小的数。

数据范围
1≤m≤n≤10^5，
1≤数列中元素≤10^9

输入样例：
5 3
4 5 1 3 2

输出样例：
1 2 3
*/

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
//h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点
//size_h 既表示堆里存储的元素个数，又表示最后一个节点的下标
int h[N], size_h;

void down(int u) {
    int t = u;  //t存储三个结点中存在的最小的节点的下标，初始化为当前节点u
    //左子节点存在并且小于当前节点，更新t的下标
    if (u * 2 <= size_h && h[u * 2] < h[t]) t = u * 2;
    //右子节点存在并且小于当前节点，更新t的下标
    if (u * 2 + 1 <= size_h && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    //如果t==u意味着不用变动，u就是三个节点中拥有最小值的节点下标，否则交换数值
    if (u != t) {
        swap(h[u], h[t]);
        //交换数值后，t这个结点存储原本u的值，u存储存储t的值(三个数中的最小值)
        //u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小
        down(t);
    }
}

//本题用不到
void up(int u) {
    while (u / 2 && h[u / 2] > h[u]) {
        swap(h[u / 2], h[u]);
        u /= 2;
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
    size_h = n;

    //建堆：O(n)
    //叶子节点不需要down
    //因为n是最大值，n/2是n的父节点，因为n是最大，所以n/2是最大的有子节点的父节点，所以从n/2往前遍历，就可以把整个数组遍历一遍
    /*
    i为什么从n/2开始down？
    首先要明确要进行down操作时必须满足左儿子和右儿子已经是个堆。
    开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点：
    1.左右儿子满足堆的性质。
    2.下标最大（因为要往上遍历）
    3.不是叶结点（叶节点一定满足堆的性质）
    */
    for (int i = n / 2; i; i--) down(i);

    while (m--) {
        printf("%d ", h[1]);  //输出当前堆顶元素

        //删掉堆顶
        h[1] = h[size_h];
        size_h--;
        down(1);
    }

    return 0;
}
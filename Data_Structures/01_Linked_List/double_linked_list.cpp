/*
实现一个双链表，双链表初始为空，支持5种操作：
在最左侧插入一个数；
在最右侧插入一个数；
将第k个插入的数删除；
在第k个插入的数左侧插入一个数；
在第k个插入的数右侧插入一个数

现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。

注意:题目中第k个插入的数并不是指当前链表的第k个数。
例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：
第1个插入的数，第2个插入的数，…，第n个插入的数。

输入格式
第一行包含整数M，表示操作次数。
接下来M行，每行包含一个操作命令，操作命令可能为以下几种：
L x，表示在链表的最左端插入数x。
R x，表示在链表的最右端插入数x。
D k，表示将第k个插入的数删除。
IL k x，表示在第k个插入的数左侧插入一个数。
IR k x，表示在第k个插入的数右侧插入一个数。

输出格式
共一行，将整个链表从左到右输出。

数据范围
1≤M≤100000
所有操作保证合法。
*/

#include <iostream>
using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

//初始化
void init() {
    //0表示左端点，1表示右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

//再下标为k的点的右边插入x
//注：在下标为k的点的左边插入下可以调用：add(l[k], x);
void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;

    //先修改r[k]的左指针，再修改r[k]
    l[r[k]] = idx;
    r[k] = idx;
}

//删除第k个点
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

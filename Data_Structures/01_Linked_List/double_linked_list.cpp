/*
实现一个双链表，双链表初始为空，支持5种操作：
在最左侧插入一个数；
在最右侧插入一个数；
将第k个插入的数删除；
在第k个插入的数左侧插入一个数；
在第k个插入的数右侧插入一个数

现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。

注意:题目中第k个插入的数并不是指当前链表的第k个数。
例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：
第1个插入的数，第2个插入的数，…，第n个插入的数。

输入格式
第一行包含整数M，表示操作次数。
接下来M行，每行包含一个操作命令，操作命令可能为以下几种：
L x，表示在链表的最左端插入数x。
R x，表示在链表的最右端插入数x。
D k，表示将第k个插入的数删除。
IL k x，表示在第k个插入的数左侧插入一个数。
IR k x，表示在第k个插入的数右侧插入一个数。

输出格式
共一行，将整个链表从左到右输出。

数据范围
1≤M≤100000
所有操作保证合法。
*/

#include <iostream>
using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

//初始化
void init() {
    //0表示左端点，1表示右端点
    //初始化第一个点的右边是1，第二个点的左边是0
    r[0] = 1, l[1] = 0;
    idx = 2;  //idx此时已经用掉两个点了
}

//在第k个点的右边插入x
//注：在下标为k的点的左边插入下可以直接调用：add(l[k], x);
//因为在k的左边插入一个数等价于在l[k]的右边插入一个数
void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;

    //(顺序不能写反)先修改r[k]的左指针，再修改r[k]
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}

//删除第k个点
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main() {
    cin >> m;

    init();

    while (m--) {
        string op;
        cin >> op;
        int k, x;
        if (op == "R") {
            cin >> x;
            //0和1只是代表头和尾
            //所以最右边插入只要在指向1的那个点的右边插入就可以了
            add(l[1], x);
        } else if (op == "L") {
            cin >> x;
            //最左边插入就是在指向0的数的左边插入就可以了
            //也就是可以直接在0的右边插入
            add(0, x);
        } else if (op == "D") {
            cin >> k;
            remove(k + 1);
        } else if (op == "IL") {
            cin >> k >> x;
            add(l[k + 1], x);
        } else {
            cin >> k >> x;
            add(k + 1 , x);
        }
    }

    for (int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';
    return 0;
}

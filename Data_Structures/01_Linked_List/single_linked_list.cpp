/*
实现一个单链表，链表初始为空(head->空)，支持三种操作：
向链表头插入一个数；
删除第k个插入的数后面的数(也就是删除下标为k-1的点的后一个点)；
在第k个插入的数后插入一个数(也就是在下标k-1的点后插入新点)。

现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。

注意:题目中第k个插入的数并不是指当前链表的第k个数。
例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：
第1个插入的数，第2个插入的数，…，第n个插入的数。

输入格式
第一行包含整数M，表示操作次数。
接下来M行，每行包含一个操作命令，操作命令可能为以下几种：
H x，表示向链表头插入一个数x。
D k，表示删除第k个插入的数后面的数（当k为0时，表示删除头结点）。
I k x，表示在第k个插入的数后面插入一个数x（此操作中k均大于0）。

输出格式
共一行，将整个链表从头到尾输出。

数据范围
1≤M≤100000
测试样例中，所有操作保证合法。
*/

#include <iostream>
using namespace std;

const int N = 100010;

//head表示头节点的下标(头指针)
//e[i]表示节点i的值
//ne[i]表示节点i的next指针是多少(也就是节点i的下一个点的下标是多少)
//idx是一个指针，记录哪些点被分配过(当前已经用到了哪个点)
int head, e[N], ne[N], idx;

//初始化
void init() {
    //最开始的时候，链表的头节点要指向-1，
    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束
    /*
    head其实应该就是一个指针，是一个特殊的指针罢了。
    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针
    当它在初始化的时候指向-1，来表示链表内没有内容。
    */
    head = -1;

    //idx有两个作用，第一个是在一开始的时候，作为链表的下标，让我们好找
    //第二个在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下标来帮助操作。
    //并且是在每一次插入操作的时候，给插入元素一个下标
    /*
    虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的
    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。
    另外，我们遍历链表的时候也是这样，靠的是ne[]
    */
    idx = 0;
}

//将x插入到头节点
//head就是头节点在数组e中的下标(不一定是-1)，e[head]就可以访问第一个节点的值
//ne[idx]就是第二个元素的地址，以此类推
void add_to_head(int x) {
    e[idx] = x;  //第一步，先将值放进去
    // 在头节点插入新节点，原来头节点的下标就变成了新节点的next节点
    ne[idx] = head;  //head作为一个指针指向空节点，现在ne[idx] = head;
    //现在只是做到了第一步，将元素x的指针指向了head原本指向的

    head = idx;  //head现在表示指向第一个元素了，它不再是空指针了
    idx++;  //指针向下移一位，为下一次插入元素做准备

    //模板写法
    /*
    e[idx] = x, ne[idx] = head, head = idx++;
    */
}

//将x插入下标为k的节点后
//idx是数组最后一个已经使用过的下标的下一个空位
void add(int k, int x) {
    e[idx] = x;  //先将元素插进去
    ne[idx] = ne[k];  //让元素x配套的指针，指向它要占位的元素的下一个位置
    ne[k] = idx;  //让原来元素的指针指向自己
    idx++;  //将idx向后挪
}

//将下标k的点的后面的点删掉
void remove(int k) {
    //让k的指针指向k下一个人的下一个人，那中间的那位就被挤掉了
    ne[k] = ne[ne[k]]; 
}

int main() {
    int m;
    cin >> m;

    init();

    while (m--) {
        int k, x;
        char op;

        cin >> op;
        if (op == 'H') {
            cin >> x;
            add_to_head(x);
        } else if (op =='D') {
            cin >> k;
            //处理删除头节点的特殊情况
            if (!k) head = ne[head];
            remove(k - 1);
        } else {
            cin >> k >> x;
            add(k - 1, x);
        }
    }

    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;

    return 0;
}
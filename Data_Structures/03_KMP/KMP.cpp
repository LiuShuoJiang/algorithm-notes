/*
给定一个字符串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模式串P在字符串S中多次作为子串出现。
求出模式串P在字符串S中所有出现的位置的起始下标。

输入格式
第一行输入整数N，表示字符串P的长度。
第二行输入字符串P。
第三行输入整数M，表示字符串S的长度。
第四行输入字符串S。

输出格式
共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。

数据范围
1≤N≤10^5
1≤M≤10^6

输入样例：
3
aba
5
ababa

输出样例：
0 2
*/

#include <iostream>
using namespace std;

const int N = 1000010;

int n, m;  // n是模板串长度，m是模式串长度
char p[N], s[N];  // 用p来匹配s
// “next” 数组，若第i位存储值为k
// 说明p[0...i]内最长相等前后缀的前缀的最后一位下标为k
// 即p[0...k] == p[i-k...i]
int next_arr[N];

int main() {
    cin >> n >> p >> m >> s;

    // p[0...0] 的区间内一定没有相等前后缀
    next_arr[0] = -1;

    //求next的过程
    //构造模板串的next数组
    //next[i]存储的就是使子串s[0…i]有最长相等前后缀的前缀的最后一位的下标
    for (int i = 1, j = -1; i < n; i++) {
        //若前后缀匹配不成功
        //反复令j回退，直至到-1 或是s[i] == s[j + 1]
        while (j != -1 && p[i] != p[j + 1]) j = next_arr[j];
        //匹配成功时，最长相等前后缀变长，最长相等前后缀前缀的最后一位变大
        if (p[i] == p[j + 1]) j++;
        //令ne[i] = j，以方便计算next[i + 1]
        next_arr[i] = j;
    }

    //KMP匹配过程
    for (int i = 0, j = -1; i < m; i++) {
        while (j != -1 && s[i] != p[j + 1]) j = next_arr[j];
        if (s[i] == p[j + 1]) j++;  //匹配成功时，模板串指向下一位
        if (j == n - 1) {  // 模板串匹配完成，第一个匹配字符下标为0，故到n - 1
            //匹配成功
            //匹配成功时，文本串结束位置减去模式串长度即为起始位置
            printf("%d ", i - j);

            //模板串在模式串中出现的位置可能是重叠的
            //需要让j回退到一定位置，再让i加1继续进行比较
            //回退到ne[j]可以保证j最大，即已经成功匹配的部分最长
            j = next_arr[j];
        }
    }

    return 0;
}

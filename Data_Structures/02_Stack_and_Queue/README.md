# 栈与队列

## 栈

先进后出

### 普通栈

> 例题：[模拟栈](./stack_simulate.cpp)

```C++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[++tt] = x;

// 从栈顶弹出一个数
tt--;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果tt > 0，则表示不为空
if (tt > 0) {

}
```

### 单调栈

单调栈是栈的一中特殊形式，在栈中的元素必须满足单调性(一定是单调上升或单调下降等等的规律)。

常见应用：给定一个序列，求出序列中每一个元素的左边离它最近的比它小的数在什么地方，若不存在返回-1。

> 例题：[单调栈](./monotonic_stack.cpp)

既然我们必须让元素满足单调性，那么每次插入就和栈顶作比较。如果不满足某些性质，直接弹出栈顶，直到栈为空或满足该性质插入这个元素。

以`[3, 4, 2, 7, 5]`为例：

![单调栈](../../images/stack.gif)

```C++
//常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i++) {
    while (tt && check(stk[tt], i)) tt--;
    stk[++tt] = i;
}
```

## 队列

先进先出

### 普通队列

```C++
//在队尾插入元素。在队头弹出元素
int q[N], hh = 0, tt = -1;

//向队尾插入一个数x
q[++tt] = x;

//从队头弹出一个数
hh++;

//判断队列是否为空，如果hh <= tt，则表示不为空
if (hh <= tt) {/*not empty*/}
else {/*empty*/}

//访问队头元素的值
q[hh];

//访问队尾元素的值
q[tt];
```

### 单调队列

常见应用为滑动窗口：确定滑动窗口位于数组每个位置时，窗口中的最大值和最小值。

> 例题：[滑动窗口](./sliding_windows.cpp)

*以求最大值为例*：由于我们需要求出的是滑动窗口的最大值。如果当前的滑动窗口中有两个下标`i`和`j`，其中i在j的左侧`(i<j)`，并且i对应的元素不大于j对应的元素`(nums[i] <= nums[j])`，则当滑动窗口向右移动时，只要`i`还在窗口中，那么`j`一定也还在窗口中。这是由于`i`在`j`的左侧所保证的。因此，由于`nums[j]`的存在，`nums[i]`一定不会是滑动窗口中的最大值了，我们可以将`nums[i]`永久地移除。

因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组`nums`中对应的值是严格单调递减的。当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。窗口向右移动的时候，我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。

*以求最小值为例*：我们从左到右扫描整个序列，用一个队列来维护最近`k`个元素。如果用暴力来做，就是每次都遍历一遍队列中的所有元素，找出最小值即可，但这样时间复杂度就变成 $O(nk)$ 了。

然后我们可以发现一个性质：如果队列中存在两个元素，满足`a[i] >= a[j]`且`i < j`，那么无论在什么时候我们都不会取`a[i]`作为最小值了，所以可以直接将`a[i]`删掉；此时队列中剩下的元素严格单调递增，所以队头就是整个队列中的最小值，可以用 $O(1)$ 的时间找到；为了维护队列的这个性质，我们在往队尾插入元素之前，先将队尾大于等于当前数的元素全部弹出即可。这样所有数均只进队一次，出队一次，所以时间复杂度是 $O(n)$ 的。

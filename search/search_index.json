{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Algorithm Notes","text":"<p>An all-in-one repository for useful algorithms in C++ (Some contents are currently in Chinese only) \u2712\ufe0f</p> <p>\ud83d\udca1\ud83d\udca1\ud83d\udca1 Keep on updating...</p> <p>This repository records some common data structures and algorithms ideas, templates and sample code, whose content stems from the summary of personal learning and practice.</p> <ul> <li>Basic Algorithms<ul> <li>Sorting</li> <li>Binary Search</li> <li>High Precision Computing</li> <li>Prefix Sum</li> <li>Double Pointer</li> <li>Bot Operations</li> <li>Discretization</li> <li>Interval Merge</li> </ul> </li> <li>Data Structures<ul> <li>Linked List</li> <li>Stack and Queue</li> <li>KMP</li> <li>Trie</li> <li>Disjoint Set</li> <li>Heap</li> <li>Hash Map</li> <li>C++ STL</li> </ul> </li> <li>Graph Theory and Searching Techniques<ul> <li>BFS and DFS</li> <li>Graph Theory</li> <li>Shortest Distance</li> <li>MST</li> <li>Bipartite Graph</li> <li>Network Flow</li> </ul> </li> <li>Dynamic Programming<ul> <li>Knapsack DP</li> <li>Linear DP</li> <li>Interval DP</li> <li>Digital Statistics DP</li> </ul> </li> <li>Greedy Algorithm<ul> <li>Interval Problem</li> <li>Huffman Tree</li> </ul> </li> <li>Math<ul> <li>Prime Number</li> <li>Factor</li> <li>Euler Function</li> <li>Binary Exponentiation</li> <li>Extended Euclidean</li> <li>Chinese Remainder Theorem</li> <li>Gauss Elimination</li> <li>Combinatorial Number</li> </ul> </li> <li>Leetcode Solutions</li> </ul> <p>This repository is licensed under CC BY-NC-SA-4.0.</p> <p></p>"},{"location":"Algorithm_Basics/","title":"Basic Algorithms","text":""},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/","title":"Example: Binary Search Float","text":"<p>code</p>"},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/#description","title":"Description","text":"<p>Given a floating point number \\(n\\), find its cubic root.</p>"},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/#input-format","title":"Input format","text":"<p>One line containing a floating point number \\(n\\).</p>"},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/#output-format","title":"Output format","text":"<p>A single line containing a floating point number representing the solution to the problem.</p> <p>Note that the result is preserved to \\(6\\) decimal places.</p>"},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/#data-range","title":"Data range","text":"<p>\\(-10000 \\leqslant n \\leqslant 10000\\)</p>"},{"location":"Algorithm_Basics/02_Binary_Search/binary_search_float/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble x;\n\nint main() {\n    cin &gt;&gt; x;\n    double l = -1000, r = 1000;\n\n    // we can also execute \"for\" loop for 100 times\n    while (r - l &gt;= 1e-8) {\n        double mid = (l + r) / 2;\n        if (mid * mid * mid &lt;= x) l = mid;\n        else r = mid;\n    }\n    printf(\"%.6lf\", l);\n    return 0;\n}\n</code></pre>"},{"location":"Data_Structures/","title":"Common Data Structures","text":""},{"location":"Dynamic_Programming/","title":"Dynamic Programming","text":""},{"location":"Graph_and_Search/","title":"Graph Theory and Searching Techniques","text":""},{"location":"Graph_and_Search/07_Tree_Basics/","title":"Introduction to Trees","text":"<ul> <li>Introduction to Trees</li> <li>Basic Concepts of Trees<ul> <li>Concept of Tree</li> <li>Concept of Binary Tree</li> </ul> </li> <li>Some Properties of Binary Trees<ul> <li>Number of Possible Binary Trees</li> <li>Height VS Nodes in Binary Tree</li> <li>Internal Nodes VS External Nodes in Binary Tree</li> </ul> </li> <li>Special Tree Structures<ul> <li>Strict (Full) Binary Tree</li> <li>Concept of Strict Binary Tree</li> <li>Height VS Nodes in Strict Binary Tree</li> <li>Internal Nodes VS External Nodes in Strict Binary Tree</li> <li>M-ary Tree</li> <li>Concept of M-ary Tree</li> <li>Height VS Nodes in M-ary Tree</li> <li>Internal Nodes VS External Nodes in a Strict M-ary Tree</li> <li>Complete Binary Tree</li> </ul> </li> <li>Representation of Binary Tree<ul> <li>Array Representation</li> <li>Linked Representation</li> </ul> </li> <li>Binary Tree Traversal</li> <li>Creating Binary Tree using Queue</li> <li>Iterative Methods for Binary Tree Traversal<ul> <li>Pre-order Traversal (Iterative Method)</li> <li>In-order Traversal (Iterative Method)</li> <li>Post-order Traversal (Iterative Method)</li> <li>Level-order Traversal</li> </ul> </li> <li>Binary Tree Implementation</li> <li>Concepts of Binary Search Tree</li> <li>Operations of Binary Search Tree<ul> <li>Searching in BST</li> <li>Recursive Searching in BST</li> <li>Iterative Searching in BST</li> <li>Inserting in BST</li> <li>Recursive Insertion in BST</li> <li>Iterative Insertion in BST</li> <li>Deleting from BST</li> <li>Generating a BST from Pre-order</li> </ul> </li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#basic-concepts-of-trees","title":"Basic Concepts of Trees","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#concept-of-tree","title":"Concept of Tree","text":"<p>Definition of Tree:</p> <p>A tree represents a hierarchical tree structure with a set of connected nodes. Each node in the tree can be connected to many children (depending on the type of tree), but must be connected to exactly one parent, except for the root node, which has no parent (i.e., the root node as the top-most node in the tree hierarchy).</p> <p>Terminology:</p> <ol> <li>Root: The root is the topmost node of a tree. It is the only node in the tree that has no parent. Every tree has exactly one root node.</li> <li>Parent: In a tree, a parent is a node that has one or more child nodes. Every node, except the root, has exactly one parent.</li> <li>Child: A child is a node that has a parent. A node can have zero, one, or multiple children. In a binary tree, a node can have at most two children.</li> <li>Sibling: Siblings are nodes that share the same parent. In other words, nodes are siblings if they are at the same level and have the same parent.</li> <li>Descendant: A descendant of a node is any node that can be reached by starting at the given node and repeatedly following child links. This includes the node's children, the children of those children, and so on.</li> <li>Ancestor: An ancestor of a node is any node that can be reached by starting at the given node and repeatedly following parent links. This includes the node's parent, the parent's parent, and so on, up to the root.</li> <li>Degree of a Node: The degree of a node is the number of children it has. In a binary tree, this is at most two, but in a general tree, it can be any non-negative integer.</li> <li>Degree of a Tree: The degree of a tree is the maximum degree of any node in the tree. It represents the highest number of children any single node in the tree has.</li> <li>Internal/External Node: Internal nodes are nodes with at least one child. External nodes, also known as leaf nodes, are nodes without children.</li> <li>Levels (start from 1): Levels in a tree structure start from the root. The root is at level 1, its children are at level 2, and so on. The level of a node is a measure of its distance from the root, plus one.</li> <li>Height of a Tree (start from 0): The height of a tree is the length of the longest path from the root to any leaf. It is measured in edges. For an empty tree, the height is -1; for a tree with just a root, the height is 0; and so on.</li> <li>Forest: A forest is a collection of disjoint trees. Removing the root of a tree will result in a forest, with each child of the root becoming the root of a new tree in the forest.</li> </ol>"},{"location":"Graph_and_Search/07_Tree_Basics/#concept-of-binary-tree","title":"Concept of Binary Tree","text":"<p>Definition of Binary Tree:</p> <p>A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.</p> <p>Left Skewed Binary Tree and Right Skewed Binary Tree:</p> <ol> <li> <p>Left Skewed Binary Tree: A left skewed binary tree is a type of binary tree in which every node has either zero or one child, and if the child exists, it is always the left child. This means there are no right children in any of the nodes. Visually, such a tree tends to lean or 'skew' towards the left side. This structure results in a tree that resembles a linked list, with all the nodes aligned to the left. The height of a left skewed binary tree with \\(n\\) nodes is \\(n-1\\), assuming we start counting the height from 0 for a single-node tree. This kind of tree is not balanced and can have inefficient operations in terms of time complexity, as operations like search, insert, or delete would have an average and worst-case complexity of \\(O(n)\\), where \\(n\\) is the number of nodes.</p> </li> <li> <p>Right Skewed Binary Tree: A right skewed binary tree is the mirror image of a left skewed binary tree. In this tree, each node has either no child or only a right child. This results in the tree being heavily biased or 'skewed' towards the right side. Like the left skewed tree, it also resembles a linked list, but with all nodes aligned to the right. The height of a right skewed binary tree with \\(n\\) nodes is also \\(n-1\\). Similarly, this tree is unbalanced and operations on it can be inefficient, with search, insert, and delete operations having an average and worst-case complexity of \\(O(n)\\).</p> </li> </ol>"},{"location":"Graph_and_Search/07_Tree_Basics/#some-properties-of-binary-trees","title":"Some Properties of Binary Trees","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#number-of-possible-binary-trees","title":"Number of Possible Binary Trees","text":"<p>Number of possible binary trees with \\(n\\) nodes ( \\(n\\)-th Catalan number):</p> \\[ C_n=\\frac{1}{n+1}C_{2n}^{n} \\] <p>The Catalan numbers satisfy the recurrence relations:</p> \\[ C_0=1;\\ C_n=\\sum_{i=1}^n{C_{i-1}C_{n-i}},\\ n&gt;0 \\] <p>Among these binary trees, the number of trees with maximum height is \\(2^{n-1}\\).</p> <p>Number of binary trees with \\(n\\) nodes, being labelled with \\(n\\) kinds of labels:</p> \\[ \\frac{C_{2n}^{n}}{n+1}\\cdot n! \\]"},{"location":"Graph_and_Search/07_Tree_Basics/#height-vs-nodes-in-binary-tree","title":"Height VS Nodes in Binary Tree","text":"<p>Given binary tree height \\(h\\), the minimum number of nodes required for the binary tree is \\(h+1\\), and the maximum number of nodes possible for the binary tree is \\(1+2+2^2+\\cdots +2^h=2^{h+1}-1\\).</p> <p>Given the number of nodes of a binary tree as \\(n\\), the minimum height required for the binary tree is \\(\\log _2\\left( n+1 \\right) -1\\), and the maximum height possible for the binary tree is \\(n-1\\).</p> <p>Therefore, we know that the height of the binary tree satisfies</p> \\[ \\underset{O\\left( \\log n \\right)}{\\underbrace{\\log _2\\left( n+1 \\right) -1}}\\leqslant h\\leqslant \\underset{O\\left( n \\right)}{\\underbrace{n-1}} \\] <p>and the number of nodes in a binary tree satisfies</p> \\[ h+1\\leqslant n\\leqslant 2^{h+1}-1 \\]"},{"location":"Graph_and_Search/07_Tree_Basics/#internal-nodes-vs-external-nodes-in-binary-tree","title":"Internal Nodes VS External Nodes in Binary Tree","text":"<p>In a binary tree, there's a specific relationship between the number of nodes with degree 0 (leaf nodes) and the number of nodes with degree 2 (internal nodes with two children). This relationship is:</p> <p>The number of leaf nodes ( degree 0 ) is always one more than the number of nodes with degree 2.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#special-tree-structures","title":"Special Tree Structures","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#strict-full-binary-tree","title":"Strict (Full) Binary Tree","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#concept-of-strict-binary-tree","title":"Concept of Strict Binary Tree","text":"<p>Definition of Strict Binary Tree:</p> <p>A strict binary tree (sometimes referred to as a proper, plane, or full binary tree) is a binary tree in which every node has either 0 or 2 children. In other words, there are no nodes with 1 child.</p> <p>A full binary tree is either (recursive definition):</p> <ul> <li>A single vertex (a single node as the root node).</li> <li>A tree whose root node has two subtrees, both of which are full binary trees.</li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#height-vs-nodes-in-strict-binary-tree","title":"Height VS Nodes in Strict Binary Tree","text":"<p>Given strict binary tree height \\(h\\), the minimum number of nodes required for the strict binary tree is \\(2h+1\\), and the maximum number of nodes possible for the strict binary tree is \\(1+2+2^2+\\cdots +2^h=2^{h+1}-1\\) (same as before).</p> <p>Given the number of nodes of a strict binary tree as \\(n\\), the minimum height required for the strict binary tree is \\(\\log _2\\left( n+1 \\right) -1\\) (same as before), and the maximum height possible for the strict binary tree is \\(\\frac{n-1}{2}\\).</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#internal-nodes-vs-external-nodes-in-strict-binary-tree","title":"Internal Nodes VS External Nodes in Strict Binary Tree","text":"<p>A strict binary tree with \\(n\\) internal nodes has \\(n+1\\) external nodes.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#m-ary-tree","title":"M-ary Tree","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#concept-of-m-ary-tree","title":"Concept of M-ary Tree","text":"<p>Definition of \\(m\\)-ary Tree:</p> <p>An \\(m\\)-ary tree (for nonnegative integers \\(m\\)) (also known as \\(n\\)-ary, \\(k\\)-ary or \\(k\\)-way tree) is an arborescence (i.e., an ordered tree) in which each node has no more than \\(m\\) children. A binary tree is the special case where \\(m=2\\), and a ternary tree is another case with \\(m=3\\) that limits its children to three.</p> <p>A full \\(m\\)-ary tree (i.e., a strict \\(m\\)-ary tree) is an \\(m\\)-ary tree where within each level every node has 0 or \\(m\\) children.</p> <p>A complete \\(m\\)-ary tree (i.e., a perfect \\(m\\)-ary tree) is a full \\(m\\)-ary tree in which all leaf nodes are at the same depth.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#height-vs-nodes-in-m-ary-tree","title":"Height VS Nodes in M-ary Tree","text":"<p>Given \\(m\\)-ary tree height \\(h\\), the minimum number of nodes required for the \\(m\\)-ary tree is \\(mh+1\\), and the maximum number of nodes possible for the \\(m\\)-ary tree is \\(1+m+m^2+\\cdots +m^h=\\frac{m^{h+1}-1}{m-1}\\).</p> <p>Given the number of nodes of an \\(m\\)-ary tree as \\(n\\), the minimum height required for the \\(m\\)-ary tree is \\(\\log _m\\left[ n\\left( m-1 \\right) +1 \\right] -1\\), and the maximum height possible for the \\(m\\)-ary tree is \\(\\frac{n-1}{m}\\).</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#internal-nodes-vs-external-nodes-in-a-strict-m-ary-tree","title":"Internal Nodes VS External Nodes in a Strict M-ary Tree","text":"<p>The number of external nodes \\(e\\) and the number of internal nodes \\(i\\) in a strict \\(m\\)-ary tree satisfies: \\(e=(m-1)\\cdot i+1\\).</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#complete-binary-tree","title":"Complete Binary Tree","text":"<p>Definition of Perfect Binary Tree:</p> <p>A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level (the level of a node defined as the number of edges or links from the root node to a node). A perfect binary tree is a full binary tree.</p> <p>The maximum number of nodes in a perfect binary tree is given by the formula \\(2^{h+1} \u2013 1\\), where \\(h\\) is the height of the tree.</p> <p>Definition of Complete Binary Tree:</p> <p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and \\(2^h\\) nodes at the last level \\(h\\). A perfect tree is therefore always complete but a complete tree is not always perfect. A complete binary tree can be efficiently represented using an array with no blank spaces in between.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#representation-of-binary-tree","title":"Representation of Binary Tree","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#array-representation","title":"Array Representation","text":"<ul> <li>Element at index \\(i\\);</li> <li>Left child at index \\(2i\\);</li> <li>Right child at index \\(2i+1\\);</li> <li>Parent at index \\(\\lfloor \\frac{i}{2} \\rfloor\\).</li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#linked-representation","title":"Linked Representation","text":"<p>\\(n\\) nodes: \\(n+1\\) <code>NULL</code> pointers.</p> <pre><code>struct Node {\n    struct Node *lchild;\n    int data;\n    struct Node *rchild;\n};\n</code></pre>"},{"location":"Graph_and_Search/07_Tree_Basics/#binary-tree-traversal","title":"Binary Tree Traversal","text":"<p>Types of binary tree traversal:</p> <ul> <li>Pre-order Traversal:<ul> <li>Visit the root node.</li> <li>Traverse the left subtree in pre-order.</li> <li>Traverse the right subtree in pre-order.</li> <li>Steps: <code>VISIT[Root] \u2192 PREORDER[Left Subtree] \u2192 PREORDER[Right Subtree]</code></li> </ul> </li> <li>In-order Traversal:<ul> <li>Traverse the left subtree in in-order.</li> <li>Visit the root node.</li> <li>Traverse the right subtree in in-order.</li> <li>Steps: <code>INORDER[Left Subtree] \u2192 VISIT[Root] \u2192 INORDER[Right Subtree]</code></li> </ul> </li> <li>Post-order Traversal:<ul> <li>Traverse the left subtree in post-order.</li> <li>Traverse the right subtree in post-order.</li> <li>Visit the root node.</li> <li>Steps: <code>POSTORDER[Left Subtree] \u2192 POSTORDER[Right Subtree] \u2192 VISIT[Root]</code></li> </ul> </li> <li>Level-order Traversal:<ul> <li>Visit nodes level by level from top to bottom.</li> <li>At each level, visit nodes from left to right.</li> <li>Steps: <code>[Root]</code>, then <code>[Root's Children]</code>, then <code>[Children's Children]</code>, etc., moving left to right at each level.</li> </ul> </li> </ul> <p>Let's consider a binary tree for illustration:</p> <pre><code>        A\n       / \\\n      B   C\n     / \\   \\\n    D   E   F\n</code></pre> <p>For this tree, the traversals would be as follows:</p> <ul> <li>Pre-order Traversal: A, B, D, E, C, F<ul> <li>Visit A, traverse B (visit D, E), traverse C (visit F).</li> </ul> </li> <li>In-order Traversal: D, B, E, A, C, F<ul> <li>Traverse B (visit D, E), visit A, traverse C (visit F).</li> </ul> </li> <li>Post-order Traversal: D, E, B, F, C, A<ul> <li>Traverse B (visit D, E), traverse C (visit F), visit A.</li> </ul> </li> <li>Level-order Traversal: A, B, C, D, E, F<ul> <li>Visit A, visit B and C, visit D, E, and F.</li> </ul> </li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#creating-binary-tree-using-queue","title":"Creating Binary Tree using Queue","text":"<pre><code>// Define the Node structure\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\n// Define the BinaryTree class\nclass BinaryTree {\npublic:\n    Node* root;\n\n    BinaryTree() : root(nullptr) {}\n\n    // Insert a node in the binary tree\n    /*\n    insert a new node with a given value into the binary tree \n    following a level-order approach, \n    meaning the node is added\n    at the first available position from left to right\n    */\n    void insert(int value) {\n        Node* newNode = new Node(value);\n        if (!root) {\n            root = newNode;\n            return;\n        }\n\n        std::queue&lt;Node*&gt; q;\n        q.push(root);\n\n        while (!q.empty()) {\n            Node* temp = q.front();\n            q.pop();\n\n            if (!temp-&gt;left) {\n                temp-&gt;left = newNode;\n                break;\n            } else {\n                q.push(temp-&gt;left);\n            }\n\n            if (!temp-&gt;right) {\n                temp-&gt;right = newNode;\n                break;\n            } else {\n                q.push(temp-&gt;right);\n            }\n        }\n    }\n\n    // Pre-order Traversal\n    void preOrderTraversal(Node* node) {\n        if (node == nullptr) return;\n        std::cout &lt;&lt; node-&gt;data &lt;&lt; \" \";\n        preOrderTraversal(node-&gt;left);\n        preOrderTraversal(node-&gt;right);\n    }\n\n    // In-order Traversal\n    void inOrderTraversal(Node* node) {\n        if (node == nullptr) return;\n        inOrderTraversal(node-&gt;left);\n        std::cout &lt;&lt; node-&gt;data &lt;&lt; \" \";\n        inOrderTraversal(node-&gt;right);\n    }\n\n    // Post-order Traversal\n    void postOrderTraversal(Node* node) {\n        if (node == nullptr) return;\n        postOrderTraversal(node-&gt;left);\n        postOrderTraversal(node-&gt;right);\n        std::cout &lt;&lt; node-&gt;data &lt;&lt; \" \";\n    }\n\n    // Level-order Traversal\n    void levelOrderTraversal() {\n        if (root == nullptr) return;\n\n        std::queue&lt;Node*&gt; q;\n        q.push(root);\n\n        while (!q.empty()) {\n            Node* temp = q.front();\n            q.pop();\n            std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n\n            if (temp-&gt;left != nullptr) q.push(temp-&gt;left);\n            if (temp-&gt;right != nullptr) q.push(temp-&gt;right);\n        }\n    }\n\n    // Height of the tree\n    int height(Node* node) {\n        if (node == nullptr) return 0;\n        int leftHeight = height(node-&gt;left);\n        int rightHeight = height(node-&gt;right);\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n};\n</code></pre> <p>The number of function calls for <code>preOrderTraversal</code> on a binary tree with \\(n\\) nodes is \\(2n+1\\). The size of the call stack is \\(h+2\\), where \\(h\\) is the height of the tree. Same for <code>inOrderTraversal</code> and <code>postOrderTraversal</code>.</p> <p>If the  pre-order/post-order/in-order of a binary tree is given, we cannot generate a unique tree, and the number of possible trees is \\(\\frac{C_{2n}^{n}}{n+1}\\). If the pre-order and post-order of a binary tree is given, we still cannot generate a unique tree.</p> <p>If the pre-order and in-order (or post-order and in-order) of a binary tree is given, we can generate a unique tree.</p> <p>Generate a Tree from Traversal:</p> <p>Time complexity: \\(O(n^2)\\)</p> <p>Example: Tree creation</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#iterative-methods-for-binary-tree-traversal","title":"Iterative Methods for Binary Tree Traversal","text":""},{"location":"Graph_and_Search/07_Tree_Basics/#pre-order-traversal-iterative-method","title":"Pre-order Traversal (Iterative Method)","text":"<p>Pseudocode:</p> <pre><code>function preOrderTraversal(root):\n    if root is null:\n        return\n\n    create a stack and push root into it\n\n    while stack is not empty:\n        node = pop from stack\n        print node's value\n\n        if node's right child is not null:\n            push node's right child into stack\n        if node's left child is not null:\n            push node's left child into stack\n</code></pre> <p>Explanation:</p> <ul> <li>Start with the root node and push it onto a stack.</li> <li>While the stack is not empty, pop the top item from the stack and visit it (e.g., print the node's value).</li> <li>Since pre-order traversal is Root-Left-Right, push the right child first (if it exists) and then the left child onto the stack. This ensures that the left child is processed first, as the stack is LIFO (Last In, First Out).</li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#in-order-traversal-iterative-method","title":"In-order Traversal (Iterative Method)","text":"<p>Pseudocode:</p> <pre><code>function inOrderTraversal(root):\n    if root is null:\n        return\n\n    create a stack\n    set current = root\n\n    while current is not null or stack is not empty:\n        while current is not null:\n            push current into stack\n            set current = current's left child\n\n        current = pop from stack\n        print current's value\n        set current = current's right child\n</code></pre> <p>Explanation:</p> <ul> <li>The in-order traversal follows the Left-Node-Right pattern.</li> <li>Start with the root node. Go to the leftmost node, pushing all the nodes onto the stack along the way.</li> <li>When you reach a null (leftmost), pop from the stack, visit the node (e.g., print its value), and then move to its right child.</li> <li>Repeat this process: traversing left as much as possible, visiting the node, and then going right.</li> <li>The stack keeps track of nodes to be visited after their left subtrees have been fully traversed.</li> <li>This process continues until both the stack is empty and the current node is null, which means that every node has been visited in in-order.</li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#post-order-traversal-iterative-method","title":"Post-order Traversal (Iterative Method)","text":"<p>Pseudocode:</p> <pre><code>function postOrderTraversal(root):\n    if root is null:\n        return\n\n    create two stacks, stack1 and stack2\n    push root into stack1\n\n    while stack1 is not empty:\n        node = pop from stack1 and push it into stack2\n        if node's left child is not null:\n            push node's left child into stack1\n        if node's right child is not null:\n            push node's right child into stack1\n\n    while stack2 is not empty:\n        node = pop from stack2\n        print node's value\n</code></pre> <p>Explanation:</p> <ul> <li>Use two stacks. The first stack is for processing the nodes, and the second stack is for the final post-order traversal output.</li> <li>For each node popped from the first stack, push its left and right children to the first stack, and push the node itself to the second stack.</li> <li>After processing all nodes, the second stack will have the nodes in post-order. Pop and visit each node from the second stack.</li> </ul>"},{"location":"Graph_and_Search/07_Tree_Basics/#level-order-traversal","title":"Level-order Traversal","text":"<p>Pseudocode:</p> <pre><code>function levelOrderTraversal(root):\n    if root is null:\n        return\n\n    create a queue and enqueue root\n\n    while queue is not empty:\n        node = dequeue from queue\n        print node's value\n\n        if node's left child is not null:\n            enqueue node's left child into queue\n        if node's right child is not null:\n            enqueue node's right child into queue\n</code></pre> <p>Explanation:</p> <ul> <li>Use a queue to hold the nodes at each level of the tree.</li> <li>Start with the root node by enqueuing it.</li> <li>While the queue is not empty, dequeue a node, visit it, and then enqueue its left and right children (if they exist).</li> <li>This process is repeated for each level of the tree, ensuring level-order traversal.</li> </ul> <p>Example: Iterative traversal</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#binary-tree-implementation","title":"Binary Tree Implementation","text":"<p>Example: Tree implementation</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#concepts-of-binary-search-tree","title":"Concepts of Binary Search Tree","text":"<p>Definition of Binary Search Tree:</p> <p>A binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree. The time complexity of operations on the binary search tree is linear with respect to the height of the tree.</p> <p>Properties of BST:</p> <ul> <li>No duplicated elements in BST;</li> <li>In-order traversal of BST gives sorted order;</li> <li>Given \\(n\\) nodes (each with unique values), we can generate \\(\\frac{C_{2n}^{n}}{n+1}\\) BSTs.</li> </ul> <p>BST is represented using linked structure.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#operations-of-binary-search-tree","title":"Operations of Binary Search Tree","text":"<p>On average, the insert, delete and search takes \\(O(\\log n)\\) for \\(n\\) nodes. In the worst case, they degrade to that of a singly linked list: \\(O(n)\\).</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#searching-in-bst","title":"Searching in BST","text":"<p>Time complexity of searching in BST is \\(O\\left( h \\right) , \\left( \\log n\\leqslant h\\leqslant n \\right)\\), where \\(h\\) is the height of the BST and \\(n\\) is the number of nodes. We can also write is as \\(O(\\log n)\\).</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#recursive-searching-in-bst","title":"Recursive Searching in BST","text":"<p>Pseudocode (tail recursion):</p> <pre><code>// Define a function that takes a key and a node as parameters \nfunction search(key, node) {\n    // If the node is null, return null \n    if (node == NULL) { \n        return NULL; \n    } \n    // If the key is equal to the node\u2019s key, return the node \n    if (key == node.key) { \n        return node; \n    } \n    // If the key is less than the node\u2019s key, search in the left subtree \n    if (key &lt; node.key) { \n        return search(key, node.left); \n    } \n    // If the key is greater than the node\u2019s key, search in the right subtree \n    if (key &gt; node.key) { \n        return search(key, node.right); \n    } \n}\n</code></pre>"},{"location":"Graph_and_Search/07_Tree_Basics/#iterative-searching-in-bst","title":"Iterative Searching in BST","text":"<p>Pseudocode (iterative method):</p> <pre><code>// Define a function that takes a key and a node as parameters \nfunction search(key, node) { \n    // Initialize a pointer to the node \n    let p = node;\n    // Loop until p is null or the key is found \n    while (p != NULL &amp;&amp; key != p.key) { \n        // If the key is less than the node\u2019s key, move to the left subtree\n        if (key &lt; p.key) { \n            p = p.left;\n        } \n        // If the key is greater than the node\u2019s key, move to the right subtree \n        else {\n            p = p.right; \n        }\n    }\n    // Return p, which is either the node with the matching key or null\n    return p;\n}\n</code></pre>"},{"location":"Graph_and_Search/07_Tree_Basics/#inserting-in-bst","title":"Inserting in BST","text":"<p>Generating a BST with \\(n\\) nodes takes \\(O(n\\log n)\\) time.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#recursive-insertion-in-bst","title":"Recursive Insertion in BST","text":"<p>Pseudocode (recursion):</p> <pre><code>// Define a function that takes a key and a node as parameters \nfunction insert(key, node) { \n    // If the node is null, create a new node with the key and return it \n    if (node == NULL) { \n        return new Node(key); \n    } \n    // If the key is less than the node\u2019s key, insert it in the left subtree \n    if (key &lt; node.key) { \n        node.left = insert(key, node.left); \n    } \n    // If the key is greater than or equal to the node\u2019s key, insert it in the right subtree \n    else { \n        node.right = insert(key, node.right); \n    } \n    // Return the node \n    return node;\n}\n</code></pre>"},{"location":"Graph_and_Search/07_Tree_Basics/#iterative-insertion-in-bst","title":"Iterative Insertion in BST","text":"<p>Pseudocode (iterative method):</p> <pre><code>// Define a function that takes a key and a node as parameters \nfunction insert(key, node) { \n    // Create a new node with the key \n    let newNode = new Node(key); \n    // If the node is null, return the new node \n    if (node == NULL) { \n        return newNode; \n    }\n    // Initialize a pointer to the node and a previous pointer \n    let current = node;\n    let previous = NULL;\n    // Loop until the current pointer is null \n    while (current != NULL) { \n        // Update the previous pointer to the current pointer \n        previous = current;\n        // If the key is less than the current node\u2019s key, move to the left subtree \n        if (key &lt; current.key) { \n            current = current.left; \n        } \n        // If the key is greater than or equal to the current node\u2019s key, move to the right subtree \n        else {\n            current = current.right;\n        } \n    } \n    // If the key is less than the previous node\u2019s key, make the new node the left child of the previous node \n    if (key &lt; previous.key) { \n        previous.left = newNode; \n    } \n    // If the key is greater than or equal to the previous node\u2019s key, make the new node the right child of the previous node\n    else { \n        previous.right = newNode;\n    }\n    // Return the node \n    return node;\n}\n</code></pre>"},{"location":"Graph_and_Search/07_Tree_Basics/#deleting-from-bst","title":"Deleting from BST","text":"<ul> <li>In-order Predecessor of a node: rightmost child its left subtree;</li> <li>In-order Successor of a node: leftmost child its right subtree.</li> </ul> <p>Pseudocode:</p> <pre><code>function deleteNode(root, key) {\n    // If the root is null, the tree is empty.\n    if (root is NULL) {\n        return root;\n    }\n\n    // If key to be deleted is smaller than the root's key, then it lies in left subtree.\n    if (key &lt; root.key) {\n        root.left = deleteNode(root.left, key);\n    }\n    // If key to be deleted is greater than the root's key, then it lies in right subtree.\n    else if (key &gt; root.key) {\n        root.right = deleteNode(root.right, key);\n    }\n    // If key is the same as root's key, then this is the node to be deleted.\n    else {\n        // Node with only one child or no child.\n        if (root.left == NULL) {\n            temp = root.right;\n            free(root);\n            return temp;\n        } else if (root.right == NULL) {\n            temp = root.left;\n            free(root);\n            return temp;\n        }\n\n        // Node with two children: Get the inorder successor (smallest in the right subtree).\n        temp = minValueNode(root.right);\n\n        // Copy the inorder successor's content to this node.\n        root.key = temp.key;\n\n        // Delete the inorder successor.\n        root.right = deleteNode(root.right, temp.key);\n    }\n\n    return root;\n}\n</code></pre> <p>Handling Different Cases:</p> <ol> <li>Node to be deleted is a leaf (no children): Simply remove the node.</li> <li>Node to be deleted has one child: Replace the node with its child.</li> <li>Node to be deleted has two children: Find the node's inorder successor (the smallest node in its right subtree), copy its value to the node, and delete the successor. Since the successor will have at most one child, we can use the same procedure to delete it.</li> </ol> <p>Time Complexity Analysis:</p> <ol> <li>Best Case (Leaf or one child): \\(O(\\log n)\\). This occurs when the tree is balanced, and we're deleting a leaf or a node with one child. The search for the node takes \\(O(\\log n)\\) time in a balanced BST.</li> <li>Worst Case (Two children): \\(O(\\log n)\\) for search + \\(O(\\log n)\\) for finding inorder successor = \\(O(\\log n)\\). This complexity also assumes a balanced BST. In an unbalanced BST, these operations could degrade to \\(O(n)\\) in the worst case.</li> </ol> <p>Space Complexity Analysis:</p> <p>The space complexity is \\(O(h)\\), where \\(h\\) is the height of the tree. This is due to the recursive nature of the algorithm, which consumes space on the call stack proportional to the height of the tree. For a balanced tree, this is \\(O(\\log n)\\), but it can be \\(O(n)\\) in the worst case for an unbalanced tree.</p> <p>Maintaining the balance of a BST is crucial for ensuring optimal performance of operations. AVL trees or Red-Black trees are types of BSTs that automatically ensure balance after insertions and deletions.</p>"},{"location":"Graph_and_Search/07_Tree_Basics/#generating-a-bst-from-pre-order","title":"Generating a BST from Pre-order","text":"<p>In pre-order traversal, the root node is visited first, followed by the left subtree, and then the right subtree. When constructing a BST from a pre-order traversal, we need to identify the root, and then partition the remaining array into two parts: the left subtree (all elements smaller than the root) and the right subtree (all elements greater than the root).</p> <p>Pseudocode:</p> <pre><code>Function constructBSTFromPreorder(preorder) {\n    if (preorder == empty) {\n        return NULL;\n    }\n\n    // Create a new node with the first element in the preorder array as the root.\n    root = newNode(preorder[0]);\n    stack = emptyStack();\n    push(stack, root);\n\n    // Iterate over the rest of the preorder array.\n    for (i from 1 to length(preorder) - 1) {\n        temp = NULL;\n\n        // Keep popping from the stack as long as the current element in preorder\n        // is greater than the top element in the stack. This finds the right\n        // position (parent node) for the current element.\n        while (not isEmpty(stack) and preorder[i] &gt; peek(stack).value) {\n            temp = pop(stack);\n        }\n\n        // Make this element as the right child and push it to the stack\n        if (temp is not NULL) {\n            temp.right = newNode(preorder[i]);\n            push(stack, temp.right);\n        }\n        // If the current element is smaller than the top element, make this\n        // element as the left child of the stack's top node. Push it to the stack.\n        else {\n            peek(stack).left = newNode(preorder[i]);\n            push(stack, peek(stack).left);\n        }\n    }\n\n    return root;\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Initialization: We start by creating the root of the tree from the first element in the preorder traversal array.</li> <li>Stack Utilization: A stack is used to keep track of the path we have taken. We use it to find the correct parent for the next node.</li> <li>Partitioning and Building the Tree:<ul> <li>We iterate through the <code>preorder</code> array.</li> <li>When we find an element greater than the current top of the stack, it means we have completed the left subtree for the current top and now we must add this new element to the right subtree. We keep popping from the stack until we find the correct parent for this element.</li> <li>If the current element is smaller than the stack's top element, it belongs to the left subtree of the top element of the stack.</li> </ul> </li> </ul> <p>Time Complexity:</p> <p>The time complexity of this algorithm is \\(O(n)\\), where \\(n\\) is the number of nodes in the tree. This efficiency is achieved because each node is processed exactly once.</p> <p>Space Complexity:</p> <p>The space complexity is \\(O(h)\\), where \\(h\\) is the height of the tree. In the worst case (a skewed tree), it can become \\(O(n)\\). However, for a balanced tree, it remains \\(O(\\log n)\\). The space is primarily used by the stack for storing the nodes of the tree.</p>"},{"location":"Greedy_Methods/","title":"Greedy Approaches","text":""},{"location":"Leetcode/","title":"Leetcode Problem Records","text":"<p>The problem set originates from Leetcode Master repository.</p> <p>\ud83d\udcdd Update everyday...</p>"},{"location":"Leetcode/#array","title":"Array","text":"<ul> <li>704: Binary Search</li> <li>34: Find First and Last Position of Element in Sorted Array</li> <li>27: Remove Element</li> <li>26: Remove Duplicates from Sorted Array</li> <li>977: Squares of a Sorted Array</li> <li>209: Minimum Size Subarray Sum</li> <li>54: Spiral Matrix</li> <li>59: Spiral Matrix II</li> </ul>"},{"location":"Leetcode/#sort","title":"Sort","text":"<ul> <li>215: Kth Largest Element in an Array</li> <li>148: Sort List</li> <li>912: Sort an Array</li> </ul>"},{"location":"Leetcode/#bit-operations","title":"Bit Operations","text":"<ul> <li>10032: Minimum Number of Operations to Make Array XOR Equal to K</li> </ul>"},{"location":"Leetcode/#hash-map","title":"Hash Map","text":"<ul> <li>242: Valid Anagram</li> <li>1002: Find Common Characters</li> <li>349: Intersection of Two Arrays</li> <li>202: Happy Number</li> <li>1: Two Sum</li> <li>454: 4 Sum II</li> <li>383: Ransom Note</li> <li>15: 3 Sum</li> <li>18: 4 Sum</li> <li>128: Longest Consecutive Sequence</li> <li>36: Valid Sudoku</li> </ul>"},{"location":"Leetcode/#linked-list","title":"Linked List","text":"<ul> <li>203: Remove Linked List Elements</li> <li>707: Design Linked List</li> <li>206: Reverse Linked List</li> <li>24: Swap Node in Pairs</li> <li>19: Remove Nth Node From End of List</li> <li>160: Intersection of Two Linked Lists</li> <li>141: Linked List Cycle</li> <li>142: Linked List Cycle II</li> <li>21: Merge Two Sorted Lists</li> <li>23: Merge k Sorted Lists</li> </ul>"},{"location":"Leetcode/#string","title":"String","text":"<ul> <li>344: Reverse String</li> <li>541: Reverse String II</li> <li>28: Find the Index of the First Occurrence in a String</li> <li>459: Repeated Substring Pattern</li> </ul>"},{"location":"Leetcode/#stack-and-queue","title":"Stack and Queue","text":"<ul> <li>232: Implement Queue using Stacks</li> <li>225: Implement Stack using Queues</li> <li>20: Valid Parentheses</li> <li>1047: Remove All Adjacent Duplicates In String</li> <li>150: Evaluate Reverse Polish Notation</li> <li>239: Sliding Window Maximum</li> <li>347: Top K Frequent Elements</li> </ul>"},{"location":"Leetcode/#trie","title":"Trie","text":"<ul> <li>208: Implement Trie (Prefix Tree)</li> <li>720: Longest Word in Dictionary</li> </ul>"},{"location":"Leetcode/#heap","title":"Heap","text":"<ul> <li>295: Find Median from Data Stream</li> <li>703: Kth Largest Element in a Stream</li> </ul>"},{"location":"Leetcode/#binary-tree","title":"Binary Tree","text":"<ul> <li>144: Binary Tree Preorder Traversal</li> <li>94: Binary Tree Inorder Traversal</li> <li>145: Binary Tree Postorder Traversal</li> <li>102: Binary Tree Level Order Traversal</li> <li>226: Invert Binary Tree</li> <li>100: Same Tree</li> <li>101: Symmetric Tree</li> <li>104: Maximum Depth of Binary Tree</li> <li>111: Minimum Depth of Binary Tree</li> <li>222: Count Complete Tree Nodes</li> <li>110: Balanced Binary Tree</li> <li>257: Binary Tree Paths</li> <li>404: Sum of Left Leaves</li> <li>513: Find Bottom Left Tree Value</li> <li>112: Path Sum</li> <li>113: Path Sum II</li> <li>105: Construct Binary Tree from Preorder and Inorder Traversal</li> <li>106: Construct Binary Tree from Inorder and Postorder Traversal</li> <li>654: Maximum Binary Tree</li> <li>617: Merge Two Binary Trees</li> <li>700: Search in a Binary Search Tree</li> <li>98: Validate Binary Search Tree</li> </ul>"},{"location":"Leetcode/#backtracking-algorithm-bfs","title":"Backtracking Algorithm (BFS)","text":"<ul> <li>77: Combinations</li> <li>216: Combination Sum III</li> <li>17: Letter Combinations of a Phone Number</li> <li>39: Combination Sum</li> <li>40: Combination Sum II</li> <li>131: Palindrome Partitioning</li> <li>93: Restore IP Addresses</li> <li>78: Subsets</li> <li>90: Subsets II</li> <li>491: Non-decreasing Subsequences</li> <li>46: Permutations</li> <li>47: Permutations II</li> <li>51: N Queens</li> <li>52: N-Queens II</li> <li>37: Sudoku Solver</li> </ul>"},{"location":"Leetcode/#monotonic-stack","title":"Monotonic Stack","text":"<ul> <li>739: Daily Temperatures</li> <li>496: Next Greater Element I</li> <li>503: Next Greater Element II</li> <li>42: Trapping Rain Water</li> </ul>"},{"location":"Leetcode/#search","title":"Search","text":"<ul> <li>130: Surrounded Regions</li> <li>200: Number of Islands</li> <li>127: Word Ladder</li> <li>126: Word Ladder II</li> </ul>"},{"location":"Leetcode/#dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>509: Fibonacci Number</li> <li>70: Climbing Stairs</li> <li>746: Min Cost Climbing Stairs</li> <li>62: Unique Paths</li> <li>63: Unique Paths II</li> <li>343: Integer Break</li> <li>96: Unique Binary Search Trees</li> <li>416: Partition Equal Subset Sum</li> <li>1049: Last Stone Weight II</li> <li>494: Target Sum</li> <li>474: Ones and Zeroes</li> <li>518: Coin Change II</li> <li>377: Combination Sum IV</li> <li>322: Coin Change</li> <li>139: Word Break</li> <li>120: Triangle</li> </ul>"},{"location":"Leetcode/0001-0099/0001-two-sum/","title":"Two Sum","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0001-two-sum/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [2,7,11,15], target = 9</code></li> <li>Output: <code>[0,1]</code></li> <li>Explanation: Because <code>nums[0] + nums[1] == 9</code>, we return <code>[0, 1]</code>.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [3,2,4]</code>, <code>target = 6</code></li> <li>Output: <code>[1,2]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>nums = [3,3]</code>, <code>target = 6</code></li> <li>Output: <code>[0,1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>2 &lt;= nums.length &lt;= 104</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>-10^9 &lt;= target &lt;= 10^9</code></li> <li>Only one valid answer exists.</li> </ul>"},{"location":"Leetcode/0001-0099/0001-two-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0001-two-sum/#double-pointer","title":"Double Pointer","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;pair&lt;int, int&gt;&gt; sumPos;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            sumPos.push_back(make_pair(nums[i], i));\n        }\n\n        sort(sumPos.begin(), sumPos.end());\n        for (int i = 0, j = nums.size() - 1; i &lt; nums.size(); i++) {\n            while (j &gt;= 0 &amp;&amp; sumPos[i].first + sumPos[j].first &gt; target) j--;\n            if (sumPos[i].first + sumPos[j].first == target) {\n                vector&lt;int&gt; res = {sumPos[i].second, sumPos[j].second};\n                return res;\n            }\n        }\n        return {};\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0001-two-sum/#hash-map","title":"Hash Map","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; maps;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            int r = target - nums[i];\n            if (maps.count(r)) return {maps[r], i};\n            maps[nums[r]] = i;\n        }\n        return {};\n    }\n}\n</code></pre> <p>Time and space complexity: \\(O(n)\\)</p>"},{"location":"Leetcode/0001-0099/0015-3sum/","title":"3 Sum","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0015-3sum/#description","title":"Description","text":"<p>Given an integer array <code>nums</code>, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p> <p>Notice that the solution set must not contain duplicate triplets.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [-1,0,1,2,-1,-4]</code></li> <li>Output: <code>[[-1,-1,2],[-1,0,1]]</code></li> </ul> <p>Explanation:</p> <ul> <li><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code>.</li> <li><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code>.</li> <li><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code>.</li> <li>The distinct triplets are <code>[-1,0,1]</code> and <code>[-1,-1,2]</code>.</li> <li>Notice that the order of the output and the order of the triplets does not matter.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0,1,1]</code></li> <li>Output: <code>[]</code></li> </ul> <p>Explanation: The only possible triplet does not sum up to 0.</p> <p>Example 3:</p> <ul> <li>Input: <code>nums = [0,0,0]</code></li> <li>Output: <code>[[0,0,0]]</code></li> </ul> <p>Explanation: The only possible triplet sums up to 0.</p> <p>Constraints:</p> <ul> <li><code>3 &lt;= nums.length &lt;= 3000</code></li> <li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li> </ul>"},{"location":"Leetcode/0001-0099/0015-3sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0015-3sum/#double-pointer-starter-way","title":"Double Pointer Starter Way","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (nums[i] &gt; 0) return res;\n\n            // wrong! e.g. [-1, -1, 2]\n            /*\n            if (nums[i] == nums[i + 1]) {\n                continue;\n            }\n            */\n            //the correct way to remove duplicates\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n            int left = i + 1, right = nums.size() - 1;\n            while (left &lt; right) {\n                if (nums[i] + nums[left] + nums[right] &gt; 0) right--;\n                else if (nums[i] + nums[left] + nums[right] &lt; 0) left++;\n                else {\n                    res.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]});\n                    // remove duplicates\n                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;\n                    right--;\n                    left++;\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n^2)\\)</p>"},{"location":"Leetcode/0001-0099/0015-3sum/#double-pointer-simpler-way","title":"Double Pointer Simpler Way","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (i &amp;&amp; nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1, k = nums.size() - 1; j &lt; k; j++) {\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;\n                while (j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;= 0) k--;\n                if (nums[i] + nums[j] + nums[k] == 0)\n                    res.push_back({nums[i], nums[j], nums[k]});\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Note: Why are we checking for <code>nums[i] + nums[j] + nums[k-1]</code> in the <code>while</code> loop, but <code>nums[i] + nums[j] + nums[k]</code> when adding the result? This is because in the <code>while</code> loop, if a <code>k</code> has been found that makes the sum of the three elements less than 0, then the next <code>k</code> (i.e., <code>k-1</code>) must make the sum of the three elements smaller (because <code>nums[k-1] &lt;= nums[k]</code>). So, if <code>nums[i] + nums[j] + nums[k-1]</code> is still greater than or equal to 0, then we need to keep decreasing <code>k</code>. Then at the end of the <code>while</code> loop, since we may have missed the <code>k</code> that makes the sum of the three elements equal to 0, we finally check if <code>nums[i] + nums[j] + nums[k] == 0</code> or not.</p> <p>If we do not use <code>k - 1</code> in that section, we can rewrite the code:</p> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (i &amp;&amp; nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1, k = nums.size() - 1; j &lt; k; j++) {\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;\n                while (j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) k--;\n                // we need to check if j &lt; k here!\n                if (j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] == 0)\n                    res.push_back({nums[i], nums[j], nums[k]});\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/#description","title":"Description","text":"<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p> <p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p> <p></p> <p>Example 1:</p> <ul> <li>Input: <code>digits = \"23\"</code></li> <li>Output: <code>[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>digits = \"\"</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>digits = \"2\"</code></li> <li>Output: <code>[\"a\",\"b\",\"c\"]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>0 &lt;= digits.length &lt;= 4</code></li> <li><code>digits[i]</code> is a digit in the range <code>['2', '9']</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    const string letterMap[10] = {\n    \"\", // 0\n    \"\", // 1\n    \"abc\", // 2\n    \"def\", // 3\n    \"ghi\", // 4\n    \"jkl\", // 5\n    \"mno\", // 6\n    \"pqrs\", // 7\n    \"tuv\", // 8\n    \"wxyz\" // 9\n};\n    vector&lt;string&gt; res;\n    string path;\n    void backtracking(string&amp; digits, int index) {\n        if (digits.length() == index) {\n            res.push_back(path);\n            return;\n        }\n        int digit = digits[index] - '0';\n        string letters = letterMap[digit];\n        for (int i = 0; i &lt; letters.size(); i++) {\n            path.push_back(letters[i]);\n            backtracking(digits, index + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if (digits.empty()) return res;\n        backtracking(digits, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(3^m \\times 4^n)\\) , where \\(m\\) is the number of digits corresponding to 4 letters, and \\(n\\) is the number of digits corresponding to three letters;</li> <li>Space complexity: \\(O(3^m \\times 4^n)\\).</li> </ul> <p>Another way of writing:</p> <pre><code>class Solution {\nprivate:\n    const string letterMap[10] = {\n    \"\", // 0\n    \"\", // 1\n    \"abc\", // 2\n    \"def\", // 3\n    \"ghi\", // 4\n    \"jkl\", // 5\n    \"mno\", // 6\n    \"pqrs\", // 7\n    \"tuv\", // 8\n    \"wxyz\" // 9\n};\n    vector&lt;string&gt; res;\n    void backtracking(const string&amp; digits, int index, const string&amp; path) {\n        if (digits.length() == index) {\n            res.push_back(path);\n            return;\n        }\n\n        int digit = digits[index] - '0';\n        string letters = letterMap[digit];\n        for (int i = 0; i &lt; letters.size(); i++)\n            backtracking(digits, index + 1, path + letters[i]);\n\n        // the 4-line code above can be changed into:\n        // for (auto letter : letterMap[digits[index] - '0'])\n        //     backtracking(digits, index + 1, path + letter);\n    }\npublic:\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if (digits.empty()) return res;\n        backtracking(digits, 0, \"\");\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0018-4sum/","title":"4 Sum","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0018-4sum/#description","title":"Description","text":"<p>Given an array <code>nums</code> of <code>n</code> integers, return an array of all the unique quadruplets <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p> <ul> <li><code>0 &lt;= a, b, c, d &lt; n</code></li> <li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are distinct.</li> <li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li> </ul> <p>You may return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,0,-1,0,-2,2], target = 0</code></li> <li>Output: <code>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [2,2,2,2,2], target = 8</code></li> <li>Output: <code>[[2,2,2,2]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 200</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>-10^9 &lt;= target &lt;= 10^9</code></li> </ul>"},{"location":"Leetcode/0001-0099/0018-4sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0018-4sum/#double-pointer","title":"Double Pointer","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            // Pruning process (optional)\n            if (nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0) break;\n\n            if (i &amp;&amp; nums[i] == nums[i - 1]) continue;\n\n            for (int j = i + 1; j &lt; nums.size(); j++) {\n                // Pruning process (optional)\n                if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= 0) break;\n\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;\n\n                for (int k = j + 1, l = nums.size() - 1; k &lt; l; k++) {\n                    if (k &gt; j + 1 &amp;&amp; nums[k] == nums[k - 1]) continue;\n\n                    // use long to avoid overflow\n                    while (k &lt; l &amp;&amp; (long) nums[i] + nums[j] + nums[k] + nums[l] &gt; target) l--;\n\n                    if (k &lt; l &amp;&amp; (long) nums[i] + nums[j] + nums[k] + nums[l] == target)\n                        res.push_back({nums[i], nums[j], nums[k], nums[l]});\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n^3)\\)</p>"},{"location":"Leetcode/0001-0099/0019-remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0019-remove-nth-node-from-end-of-list/#description","title":"Description","text":"<p>Given the <code>head</code> of a linked list, remove the <code>n</code>-th node from the end of the list and return its head.</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [1,2,3,4,5], n = 2</code></li> <li>Output: <code>[1,2,3,5]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [1], n = 1</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = [1,2], n = 1</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the list is <code>sz</code>.</li> <li><code>1 &lt;= sz &lt;= 30</code></li> <li><code>0 &lt;= Node.val &lt;= 100</code></li> <li><code>1 &lt;= n &lt;= sz</code></li> </ul>"},{"location":"Leetcode/0001-0099/0019-remove-nth-node-from-end-of-list/#solution","title":"Solution","text":"<p>To delete the <code>n</code>-th node from back to front, we need to get a reference to the <code>n+1</code>-th node from back to front.</p> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *dummyHead = new ListNode(-1);\n        dummyHead-&gt;next = head;\n        ListNode *slow = dummyHead;\n        ListNode *fast = dummyHead;\n\n        while (n-- &amp;&amp; fast) {\n            fast = fast-&gt;next;\n        }\n        fast = fast-&gt;next;\n        while (fast) {\n            fast = fast-&gt;next;\n            slow = slow-&gt;next;\n        }\n        slow-&gt;next = slow-&gt;next-&gt;next;\n\n        return dummyHead-&gt;next;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0020-valid-parentheses/","title":"Valid Parentheses","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0020-valid-parentheses/#description","title":"Description","text":"<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p> <p>An input string is valid if:</p> <ul> <li>Open brackets must be closed by the same type of brackets.</li> <li>Open brackets must be closed in the correct order.</li> <li>Every close bracket has a corresponding open bracket of the same type.</li> </ul> <p>Example 1:</p> <ul> <li>Input: <code>s = \"()\"</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"()[]{}\"</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>s = \"(]\"</code></li> <li>Output: <code>false</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^4</code></li> <li><code>s</code> consists of parentheses only <code>'()[]{}'</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0020-valid-parentheses/#solution","title":"Solution","text":"<p>Three situations when the string is not valid:</p> <ul> <li>The first case: the string has been traversed, but the stack is not empty, indicating that there is a corresponding left bracket does not have a right bracket to match, so return <code>false</code>;</li> <li>The second case: during the process of traversing the string to match, it is found that there is no character to match in the stack. So return <code>false</code>;</li> <li>The third case: traversing the string matching process, the stack is already empty, there is no matching character, that is, the right bracket did not find the corresponding left bracket. Also return <code>false</code>.</li> </ul> <pre><code>class Solution {\npublic:\n    bool isValid(string s) {\n        // If the length of the string is odd, it cannot be a valid parentheses sequence\n        if (s.size() % 2) return false;\n\n        stack&lt;char&gt; stk; // Using a stack to keep track of the parentheses\n\n        // Iterating through each character in the string\n        for (int i = 0; i &lt; s.size(); i++) {\n            // If the current character is an opening parenthesis, push the corresponding closing one onto the stack\n            if (s[i] == '(') stk.push(')');\n            else if (s[i] == '[') stk.push(']');\n            else if (s[i] == '{') stk.push('}');\n\n            // If the current character is a closing parenthesis, check for matching with the top of the stack\n            else if (stk.empty() || stk.top() != s[i]) \n                return false; // If no match or the stack is empty, the string is not valid\n            else \n                stk.pop(); // If there is a match, pop the top element from the stack\n        }\n\n        // If the stack is empty at the end, all parentheses were matched correctly\n        return stk.empty();\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    bool isValid(string s) {\n        stack&lt;char&gt; stk;\n        for (auto c : s) {\n            if (c == '(' || c == '[' || c =='{') stk.push(c);\n            else {\n                // The ASCII code difference between ( and ), [ and ], { and } is no more than 2.\n                if (stk.size() &amp;&amp; abs(stk.top() - c) &lt;= 2) stk.pop();\n                else return false;\n            }\n        }\n        return stk.empty();\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/","title":"Merge Two Sorted Lists","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/#description","title":"Description","text":"<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p> <p>Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.</p> <p>Return the head of the merged linked list.</p> <p>Example 1:</p> <ul> <li>Input: <code>list1 = [1,2,4], list2 = [1,3,4]</code></li> <li>Output: <code>[1,1,2,3,4,4]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>list1 = [], list2 = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>list1 = [], list2 = [0]</code></li> <li>Output: <code>[0]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> <li>Both <code>list1</code> and <code>list2</code> are sorted in non-decreasing order.</li> </ul>"},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if (!list1) return list2;\n        if (!list2) return list1;\n        ListNode* tail = new ListNode();\n        ListNode* preHead = tail;\n        auto p = list1, q = list2;\n        while (p &amp;&amp; q) {\n            if (p-&gt;val &lt;= q-&gt;val) {\n                tail-&gt;next = new ListNode(p-&gt;val);\n                p = p-&gt;next;\n            } else {\n                tail-&gt;next = new ListNode(q-&gt;val);\n                q = q-&gt;next;\n            }\n            tail = tail-&gt;next;\n        }\n        while (p) {\n            tail-&gt;next = new ListNode(p-&gt;val);\n            p = p-&gt;next;\n            tail = tail-&gt;next;\n        }\n        while (q) {\n            tail-&gt;next = new ListNode(q-&gt;val);\n            q = q-&gt;next;\n            tail = tail-&gt;next;\n        }\n        return preHead-&gt;next;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/#way-2-in-place","title":"Way 2 (In Place)","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        auto dummy = new ListNode(), tail = dummy;\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                tail = tail-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                tail = tail-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n        }\n        if (list1) tail-&gt;next = list1;\n        if (list2) tail-&gt;next = list2;\n\n        return dummy-&gt;next;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m+n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0021-merge-two-sorted-lists/#way-3-recursive","title":"Way 3 (Recursive)","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if (!list1) return list2;\n        if (!list2) return list1;\n        if (list1-&gt;val &lt; list2-&gt;val) {\n            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);\n            return list1;\n        } else {\n            list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);\n            return list2;\n        }\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m+n)\\);</li> <li>Space complexity: \\(O(m+n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0023-merge-k-sorted-lists/","title":"Merge k Sorted Lists","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0023-merge-k-sorted-lists/#description","title":"Description","text":"<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p> <p>Merge all the linked-lists into one sorted linked-list and return it.</p> <p>Example 1:</p> <ul> <li>Input: <code>lists = [[1,4,5],[1,3,4],[2,6]]</code></li> <li>Output: <code>[1,1,2,3,4,4,5,6]</code></li> <li>Explanation:</li> </ul> <pre><code>The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>lists = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>lists = [[]]</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>k == lists.length</code></li> <li><code>0 &lt;= k &lt;= 10^4</code></li> <li><code>0 &lt;= lists[i].length &lt;= 500</code></li> <li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li> <li><code>lists[i]</code> is sorted in ascending order.</li> <li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0023-merge-k-sorted-lists/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0023-merge-k-sorted-lists/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        auto cmp = [](ListNode* a, ListNode* b) {\n            return a-&gt;val &gt; b-&gt;val;\n        };\n\n        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; q(cmp);\n\n        for (auto head : lists) {\n            if (head) q.push(head);\n        }\n\n        auto dummy = new ListNode(), tail = dummy;\n\n        while (!q.empty()) {\n            auto node = q.top(); q.pop();\n            tail-&gt;next = node;\n            tail = tail-&gt;next;\n            if (node-&gt;next) q.push(node-&gt;next);\n        }\n\n        auto mergeHead = dummy-&gt;next;\n        delete dummy;\n        return mergeHead;\n    }\n};\n</code></pre> <ul> <li>Time Complexity:<ul> <li>Inserting an element into a priority queue takes \\(O(\\log k)\\) time, where \\(k\\) is the number of linked lists.</li> <li>Each of the \\(n\\) nodes is inserted into the queue once, thus the overall time complexity is \\(O(n \\log k)\\).</li> </ul> </li> <li>Space Complexity:<ul> <li>The space complexity is \\(O(k)\\) because the priority queue contains at most \\(k\\) pointers to the head of each linked list.</li> </ul> </li> </ul>"},{"location":"Leetcode/0001-0099/0023-merge-k-sorted-lists/#way-2","title":"Way 2","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        auto dummy = new ListNode(), tail = dummy;\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                tail-&gt;next = list1;\n                tail = tail-&gt;next;\n                list1 = list1-&gt;next;\n            } else {\n                tail-&gt;next = list2;\n                tail = tail-&gt;next;\n                list2 = list2-&gt;next;\n            }\n        }\n        tail-&gt;next = list1 ? list1 : list2;\n        return dummy-&gt;next;\n    }\n\n    ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int l, int r) {\n        if (l == r) return lists[l];\n        int mid = (l + r) &gt;&gt; 1;\n        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));\n    }\n\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        int n = lists.size();\n        if (!n) return nullptr;\n        return merge(lists, 0, n - 1);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0024-swap-nodes-in-pairs/","title":"Swap Nodes in Pairs","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0024-swap-nodes-in-pairs/#description","title":"Description","text":"<p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [1,2,3,4]</code></li> <li>Output: <code>[2,1,4,3]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = [1]</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[0, 100]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0001-0099/0024-swap-nodes-in-pairs/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0024-swap-nodes-in-pairs/#classical-solution","title":"Classical Solution","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // Create a dummy node to simplify edge cases like empty list or list with single node\n        ListNode *dummyHead = new ListNode(-1);\n        dummyHead-&gt;next = head;\n\n        // Use curr to traverse the list\n        ListNode *curr = dummyHead;\n\n        // Loop through the list in pairs\n        while (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next) {\n            // Identify the two nodes to be swapped\n            ListNode *temp1 = curr-&gt;next; // First node in the pair\n            ListNode *temp2 = curr-&gt;next-&gt;next-&gt;next; // Node right after the second node in the pair\n\n            // Perform the swap\n            curr-&gt;next = curr-&gt;next-&gt;next; // Point current to the second node\n            curr-&gt;next-&gt;next = temp1; // Point second node to the first node\n            curr-&gt;next-&gt;next-&gt;next = temp2; // Connect the first node to the rest of the list\n\n            // Move curr two nodes forward for the next pair\n            curr = curr-&gt;next-&gt;next;\n        }\n\n        // Return the new head of the list\n        return dummyHead-&gt;next;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0024-swap-nodes-in-pairs/#recursive-solution","title":"Recursive Solution","text":"<pre><code>class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head-&gt;next) return head;\n\n        ListNode *first = head;\n        ListNode *second = head-&gt;next;\n        ListNode *after = head-&gt;next-&gt;next;\n\n        second-&gt;next = first;\n        first-&gt;next = swapPairs(after);\n        return second;\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // Base case: if list is empty or has only one node\n        if (head == nullptr || head-&gt;next == nullptr) {\n            return head;\n        }\n\n        // Nodes to be swapped\n        ListNode *node1 = head;\n        ListNode *node2 = head-&gt;next;\n\n        // Swap the nodes and recursively call for the rest of the list\n        node1-&gt;next = swapPairs(node2-&gt;next);\n        node2-&gt;next = node1;\n\n        // After swapping, node2 is now the head of this part of the list\n        return node2;\n    }\n};\n</code></pre> <p>The function <code>swapPairs</code> is called with the current head of the list. If the list is empty or has only one node, it returns the head as is. Otherwise, it swaps the first two nodes and then recursively calls itself for the rest of the list, starting from the third node.</p> <p>The returned node from the recursive call is linked with the first node of the current pair, and the second node of the pair becomes the new head of this part of the list. This process repeats until all pairs are swapped, or the end of the list is reached.</p>"},{"location":"Leetcode/0001-0099/0026-remove-duplicates-from-sorted-array/","title":"Remove Duplicates from Sorted Array","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0026-remove-duplicates-from-sorted-array/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in <code>nums</code>.</p> <p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p> <ul> <li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li> <li>Return <code>k</code>.</li> </ul> <p>Custom Judge:</p> <p>The judge will test your solution with the following code:</p> <pre><code>int[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</code></pre> <p>If all assertions pass, then your solution will be accepted.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,1,2]</code></li> <li>Output: <code>2, nums = [1,2,_]</code></li> </ul> <p>Explanation: Your function should return <code>k = 2</code>, with the first two elements of <code>nums</code> being 1 and 2 respectively. It does not matter what you leave beyond the returned <code>k</code> (hence they are underscores).</p> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0,0,1,1,1,2,2,3,3,4]</code></li> <li>Output: <code>5, nums = [0,1,2,3,4,_,_,_,_,_]</code></li> </ul> <p>Explanation: Your function should return <code>k = 5</code>, with the first five elements of <code>nums</code> being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned <code>k</code> (hence they are underscores).</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li> <li><code>-100 &lt;= nums[i] &lt;= 100</code></li> <li><code>nums</code> is sorted in non-decreasing order.</li> </ul>"},{"location":"Leetcode/0001-0099/0026-remove-duplicates-from-sorted-array/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0026-remove-duplicates-from-sorted-array/#double-pointer","title":"Double Pointer","text":"<pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int slowIndex = 1, fastIndex;\n        for (fastIndex = 1; fastIndex &lt; nums.size(); fastIndex++) {\n            if (nums[fastIndex] != nums[fastIndex - 1])\n                nums[slowIndex++] = nums[fastIndex];\n        }\n        return slowIndex;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n)\\)</p> <p>Another way to handle index:</p> <pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int slowIndex = 0;\n        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) {\n            if (!fastIndex || nums[fastIndex] != nums[fastIndex - 1])\n                nums[slowIndex++] = nums[fastIndex];\n        }\n        return slowIndex;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0026-remove-duplicates-from-sorted-array/#library-functions","title":"Library Functions","text":"<ul> <li>The <code>unique</code> function rearranges the elements in <code>nums</code> so that all unique elements appear at the start of the vector, and then returns an iterator to the new logical end of the range.</li> <li>The <code>distance</code> function then calculates how many elements are between the start of the vector and this new logical end, which is the count of unique elements.</li> </ul> <pre><code>class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        return distance(nums.begin(), unique(nums.begin(), nums.end()));\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0027-remove-element/","title":"Remove Element","text":""},{"location":"Leetcode/0001-0099/0027-remove-element/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> in-place. The order of the elements may be changed. Then return the number of elements in <code>nums</code> which are not equal to <code>val</code>.</p> <p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p> <ul> <li>Change the array <code>nums</code> such that the first <code>k</code> elements of nums contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li> <li>Return <code>k</code>.</li> </ul> <p>Custom Judge:</p> <p>The judge will test your solution with the following code:</p> <pre><code>int[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</code></pre> <p>If all assertions pass, then your solution will be accepted.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [3,2,2,3], val = 3</code></li> <li>Output: <code>2, nums = [2,2,_,_]</code></li> </ul> <p>Explanation: Your function should return <code>k = 2</code>, with the first two elements of <code>nums</code> being 2. It does not matter what you leave beyond the returned <code>k</code> (hence they are underscores).</p> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0,1,2,2,3,0,4,2], val = 2</code></li> <li>Output: <code>5, nums = [0,1,4,0,3,_,_,_]</code></li> </ul> <p>Explanation: Your function should return <code>k = 5</code>, with the first five elements of <code>nums</code> containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned <code>k</code> (hence they are underscores).</p> <p>Constraints:</p> <ul> <li><code>0 &lt;= nums.length &lt;= 100</code></li> <li><code>0 &lt;= nums[i] &lt;= 50</code></li> <li><code>0 &lt;= val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0001-0099/0027-remove-element/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0027-remove-element/#classical-solution","title":"Classical Solution","text":"<pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int nums_size = nums.size();\n        for (int i = 0; i &lt; nums_size; i++) {\n            // When the element that needs to be removed is found, \n            // the array is collectively moved forward by one position.\n            if (nums[i] == val) {\n                for (int j = i + 1; j &lt; nums_size; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                // Because the values after subscript i are moved forward by one position, \n                // i is also moved forward by one position.\n                i--;\n                // size of array -1\n                nums_size--;\n            }\n        }\n        return nums_size;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0027-remove-element/#double-pointer-solution","title":"Double Pointer Solution","text":"<p>Define fast and slow pointers:</p> <ul> <li>Fast pointer: looks for an element of the new array, which is an array that does not contain the <code>target</code> element;</li> <li>Slow pointer: points to the location where the subscript of the new array is updated.</li> </ul> <pre><code>class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int slowIndex = 0;\n        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) {\n            if (val != nums[fastIndex])\n                nums[slowIndex++] = nums[fastIndex];\n        }\n        return slowIndex;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/","title":"Find the Index of the First Occurrence in a String","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#description","title":"Description","text":"<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>haystack = \"sadbutsad\", needle = \"sad\"</code></li> <li>Output: <code>0</code></li> <li>Explanation: <code>\"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>haystack = \"leetcode\", needle = \"leeto\"</code></li> <li>Output: <code>-1</code></li> <li>Explanation: <code>\"leeto\" did not occur in \"leetcode\", so we return -1.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= haystack.length, needle.length &lt;= 10^4</code></li> <li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li> </ul>"},{"location":"Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#brute-force-solution","title":"Brute-Force Solution","text":"<pre><code>class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        for (int i = 0; i &lt; haystack.size(); i++) {\n            bool flag = true;\n            for (int j = 0; j &lt; needle.size(); j++) {\n                if (haystack[i + j] != needle[j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return i;\n        }\n        return -1;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#kmp-solution","title":"KMP Solution","text":"<pre><code>class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n = haystack.size(), m = needle.size();\n        haystack = ' ' + haystack;\n        needle = ' ' + needle;\n        vector&lt;int&gt; ne(m + 1);\n        for (int i = 2, j = 0; i &lt;= m; i++) {\n            while (j &amp;&amp; needle[i] != needle[j + 1]) j = ne[j];\n            if (needle[i] == needle[j + 1]) j++;\n            ne[i] = j;\n        }\n        for (int i = 1, j = 0; i &lt;= n; i++) {\n            while (j &amp;&amp; haystack[i] != needle[j + 1]) j = ne[j];\n            if (haystack[i] == needle[j + 1]) j++;\n            if (j == m) return i - m;\n        }\n        return -1;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0034-find-first-and-last-position-of-element-in-sorted-array/","title":"Find First and Last Position of Element in Sorted Array","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0034-find-first-and-last-position-of-element-in-sorted-array/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p> <p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p> <p>You must write an algorithm with \\(O(\\log n)\\) runtime complexity.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [5,7,7,8,8,10], target = 8</code></li> <li>Output: <code>[3,4]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [5,7,7,8,8,10], target = 6</code></li> <li>Output: <code>[-1,-1]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>nums = [], target = 0</code></li> <li>Output: <code>[-1,-1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>0 &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>nums</code> is a non-decreasing array.</li> <li><code>-10^9 &lt;= target &lt;= 10^9</code></li> </ul>"},{"location":"Leetcode/0001-0099/0034-find-first-and-last-position-of-element-in-sorted-array/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0034-find-first-and-last-position-of-element-in-sorted-array/#binary-search-template-1","title":"Binary Search Template 1","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; res;\n        // (NOTE!!!) We need to check if the array is empty\n        if (nums.empty()) {\n            return vector&lt;int&gt;{-1, -1};\n        }\n        int l = -1, r = nums.size();\n        while (l + 1 &lt; r) {\n            int mid = l + (r - l) / 2;\n            if (nums[mid] &gt;= target) r = mid;\n            else l = mid;\n        }\n\n        // (NOTE!!!) Check if r is within bounds and if the target is found\n        if (r &gt;= nums.size() || nums[r] != target) {\n            return vector&lt;int&gt;{-1, -1};\n        } else {\n            res.push_back(r);\n            l = -1, r = nums.size();\n            while (l + 1 &lt; r) {\n                int mid = l + (r - l) / 2;\n                if (nums[mid] &lt;= target) l = mid;\n                else r = mid;\n            }\n            res.push_back(l);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0034-find-first-and-last-position-of-element-in-sorted-array/#binary-search-template-2","title":"Binary Search Template 2","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; res;\n        if (nums.empty()) {\n            return vector&lt;int&gt;{-1, -1};\n        }\n        int l = 0, r = nums.size() - 1;\n        while (l &lt; r) {\n            int mid = l + (r - l) / 2;\n            if (nums[mid] &gt;= target) r = mid;\n            else l = mid + 1;\n        }\n        if (nums[r] != target) return {-1, -1};\n        int left_res = r;\n\n        l = 0, r = nums.size() - 1;\n        while (l &lt; r) {\n            int mid = l + (r - l + 1) / 2;\n            if (nums[mid] &lt;= target) l = mid;\n            else r = mid - 1;\n        }\n        return {left_res, r};  //return {left_res, l}; is also OK\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0036-valid-sudoku/","title":"Valid Sudoku","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0036-valid-sudoku/#description","title":"Description","text":"<p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p> <ul> <li>Each row must contain the digits <code>1-9</code> without repetition.</li> <li>Each column must contain the digits <code>1-9</code> without repetition.</li> <li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li> </ul> <p>Note:</p> <ul> <li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li> <li>Only the filled cells need to be validated according to the mentioned rules.</li> </ul> <p>Example 1:</p> <p></p> <ul> <li>Input:</li> </ul> <pre><code>board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n</code></pre> <ul> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input:</li> </ul> <pre><code>board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n</code></pre> <ul> <li>Output: <code>false</code></li> <li>Explanation: <code>Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>board.length == 9</code></li> <li><code>board[i].length == 9</code></li> <li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>'.'</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0036-valid-sudoku/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int row[9][9];\n        int col[9][9];\n        int box[3][3][9];\n        memset(row, 0, sizeof(row));\n        memset(col, 0, sizeof(col));\n        memset(box, 0, sizeof(box));\n        for (int i = 0; i &lt; board.size(); i++) {\n            for (int j = 0; j &lt; board[0].size(); j++) {\n                if (board[i][j] == '.') continue;\n                int num = board[i][j] - '1';\n                if (row[i][num] || col[j][num] || box[i / 3][j / 3][num])\n                    return false;\n                row[i][num] = col[j][num] = box[i / 3][j / 3][num] = 1;\n            }\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0037-sudoku-solver/","title":"Sudoku Solver","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0037-sudoku-solver/#description","title":"Description","text":"<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p> <p>A sudoku solution must satisfy all of the following rules:</p> <ol> <li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li> <li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li> <li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li> </ol> <p>The <code>'.'</code> character indicates empty cells.</p> <p>Example 1:</p> <p></p> <ul> <li>Input:</li> </ul> <pre><code>board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n</code></pre> <ul> <li>Output:</li> </ul> <pre><code>[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n</code></pre> <ul> <li>Explanation: The input board is shown above and the only valid solution is shown below:</li> </ul> <p></p> <p>Constraints:</p> <ul> <li><code>board.length == 9</code></li> <li><code>board[i].length == 9</code></li> <li><code>board[i][j]</code> is a digit or <code>'.'</code>.</li> <li>It is guaranteed that the input board has only one solution.</li> </ul>"},{"location":"Leetcode/0001-0099/0037-sudoku-solver/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0037-sudoku-solver/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i = 0; i &lt; board.size(); i++) {\n            for (int j = 0; j &lt; board[0].size(); j++) {\n                if (board[i][j] == '.') {\n                    for (char k = '1'; k &lt;= '9'; k++) {\n                        if (isValid(i, j, k, board)) {\n                            board[i][j] = k;\n                            if (backtracking(board)) return true;\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool isValid(int row, int col, char val, vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i = 0; i &lt; 9; i++) {\n            if (board[row][i] == val)\n                return false;\n        }\n        for (int j = 0; j &lt; 9; j++) {\n            if (board[j][col] == val)\n                return false;\n        }\n        int rowIndex = (row / 3) * 3;\n        int colIndex = (col / 3) * 3;\n        for (int i = rowIndex; i &lt; rowIndex + 3; i++) {\n            for (int j = colIndex; j &lt; colIndex + 3; j++) {\n                if (board[i][j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        backtracking(board);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0037-sudoku-solver/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    bool line[9][9], column[9][9], cell[3][3][9];\n\n    bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col) {\n        if (col == 9) row++, col = 0;\n        if (row == 9) return true;\n\n        if (board[row][col] != '.') return backtracking(board, row, col + 1);\n\n        for (int i = 0; i &lt; 9; i++) {\n            if (!line[row][i] &amp;&amp; !column[col][i] &amp;&amp; !cell[row / 3][col / 3][i]) {\n                board[row][col] = '1' + i;\n                line[row][i] = column[col][i] = cell[row / 3][col / 3][i] = true;\n                if (backtracking(board, row, col + 1)) return true;\n                board[row][col] = '.';\n                line[row][i] = column[col][i] = cell[row / 3][col / 3][i] = false;\n            }\n        }\n        return false;\n    }\npublic:\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(cell, 0, sizeof(cell));\n\n        for (int i = 0; i &lt; 9; i++) {\n            for (int j = 0; j &lt; 9; j++) {\n                if (board[i][j] != '.') {\n                    int t = board[i][j] - '1';\n                    line[i][t] = column[j][t] = cell[i / 3][j / 3][t] = true;\n                }\n            }\n        }\n\n        backtracking(board, 0, 0);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0039-combination-sum/","title":"Combination Sum","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0039-combination-sum/#description","title":"Description","text":"<p>Given an array of distinct integers <code>candidates</code> and a target integer <code>target</code>, return a list of all unique combinations of <code>candidates</code> where the chosen numbers sum to <code>target</code>. You may return the combinations in any order.</p> <p>The same number may be chosen from <code>candidates</code> an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p> <p>Note: The frequency of an element x is the number of times it occurs in the array.</p> <p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p> <p>Example 1:</p> <ul> <li>Input: <code>candidates = [2,3,6,7], target = 7</code></li> <li>Output: <code>[[2,2,3],[7]]</code></li> <li>Explanation:<ul> <li><code>2</code> and <code>3</code> are candidates, and <code>2 + 2 + 3 = 7</code>. Note that <code>2</code> can be used multiple times.</li> <li><code>7</code> is a candidate, and <code>7 = 7</code>.</li> <li>These are the only two combinations.</li> </ul> </li> </ul> <p>Example 2:</p> <ul> <li><code>Input: candidates = [2,3,5], target = 8</code></li> <li><code>Output: [[2,2,2,2],[2,3,3],[3,5]]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>candidates = [2], target = 1</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= candidates.length &lt;= 30</code></li> <li><code>2 &lt;= candidates[i] &lt;= 40</code></li> <li>All elements of <code>candidates</code> are distinct.</li> <li><code>1 &lt;= target &lt;= 40</code></li> </ul>"},{"location":"Leetcode/0001-0099/0039-combination-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0039-combination-sum/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        if (sum &lt; 0) return;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; candidates.size(); i++) {\n            path.push_back(candidates[i]);\n            // No need to use i+1, meaning that the current number can be read repeatedly\n            backtracking(candidates, sum - candidates[i], i);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\times 2^n)\\);</li> <li>Space complexity: \\(O(\\mathrm{target})\\).</li> </ul> <p>Optimized code with pruning:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        if (sum &lt; 0) return ;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; candidates.size(); i++) {\n            if (sum - candidates[i] &lt; 0) break;\n            path.push_back(candidates[i]);\n            backtracking(candidates, sum - candidates[i], i);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre> <p>After sorting the total set, if the <code>sum</code> of the next level (which is the <code>sum + candidates[i]</code> of this level) is already greater than <code>target</code>, we can end this round of traversal of the <code>for</code> loop.</p>"},{"location":"Leetcode/0001-0099/0039-combination-sum/#way-2","title":"Way 2","text":"<p>See reference.</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        if (sum &lt; 0) return;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        // if index crosses the last index, we will return saying that no more element is left to choose\n        if (startIndex == candidates.size()) return;\n\n        // we are not taking the startIndex-th element,\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\n        backtracking(candidates, sum, startIndex + 1);\n\n        // we are taking the startIndex-th element and not moving onto the next element \n        // because it may be possible that this element again contribute in making our sum.\n        // but we decrease our target sum as we are considering that this will help us in making our target sum\n        path.push_back(candidates[startIndex]);\n        backtracking(candidates, sum - candidates[startIndex], startIndex);\n        path.pop_back();\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0040-combination-sum-ii/","title":"Combination Sum II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0040-combination-sum-ii/#description","title":"Description","text":"<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in candidates where the <code>candidate</code> numbers sum to <code>target</code>.</p> <p>Each number in <code>candidates</code> may only be used once in the combination.</p> <p>Note: The solution set must not contain duplicate combinations.</p> <p>Example 1:</p> <ul> <li>Input: <code>candidates = [10,1,2,7,6,1,5], target = 8</code></li> <li>Output:</li> </ul> <pre><code>[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>candidates = [2,5,2,1,2], target = 5</code></li> <li>Output:</li> </ul> <pre><code>[\n[1,2,2],\n[5]\n]\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= candidates.length &lt;= 100</code></li> <li><code>1 &lt;= candidates[i] &lt;= 50</code></li> <li><code>1 &lt;= target &lt;= 30</code></li> </ul>"},{"location":"Leetcode/0001-0099/0040-combination-sum-ii/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        // if (sum &lt; 0) return;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum - candidates[i] &gt;= 0; i++) {\n            if (i != startIndex &amp;&amp; candidates[i] == candidates[i - 1]) continue;\n            path.push_back(candidates[i]);\n            backtracking(candidates, sum - candidates[i], i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/","title":"Trapping Rain Water","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#description","title":"Description","text":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p> <p>Example 1:</p> <p></p> <ul> <li>Input: <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code></li> <li>Output: <code>6</code></li> <li>Explanation: The above elevation map (black section) is represented by array <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>. In this case, 6 units of rain water (blue section) are being trapped.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>height = [4,2,0,3,2,5]</code></li> <li>Output: <code>9</code></li> </ul> <p>Constraints:</p> <ul> <li><code>n == height.length</code></li> <li><code>1 &lt;= n &lt;= 2 * 10^4</code></li> <li><code>0 &lt;= height[i] &lt;= 10^5</code></li> </ul>"},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#double-pointer-solution","title":"Double-Pointer Solution","text":""},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#original-way-of-writing","title":"Original Way of Writing","text":"<pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        if (height.size() &lt;= 2) return 0;\n        vector&lt;int&gt; maxLeft(height.size(), 0);\n        vector&lt;int&gt; maxRight(height.size(), 0);\n        int sizeH = maxRight.size();\n\n        maxLeft[0] = height[0];\n        for (int i = 1; i &lt; sizeH; i++)\n            maxLeft[i] = max(height[i], maxLeft[i - 1]);\n\n        maxRight[sizeH - 1] = height[sizeH - 1];\n        for (int i = sizeH - 2; i &gt;= 0; i--)\n            maxRight[i] = max(height[i], maxRight[i + 1]);\n\n        int res = 0;\n        for (int i = 0; i &lt; sizeH; i++) {\n            int sum = min(maxLeft[i], maxRight[i]) - height[i];\n            if (sum &gt;= 0) res += sum;\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#optimized-way-of-writing","title":"Optimized Way of Writing","text":"<pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        int left = 0, right = height.size() - 1, lMax = INT_MIN, rMax = INT_MIN, sum = 0;\n        while (left &lt; right) {\n            lMax = max(lMax, height[left]);\n            rMax = max(rMax, height[right]);\n            sum += (lMax &lt; rMax) ? (lMax - height[left++]) : (rMax - height[right--]);\n        }\n        return sum;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        // Initialize two pointers and two variables to keep track of the \n        // maximum height from left and right\n        int left = 0, right = height.size() - 1;\n        int lMax = INT_MIN, rMax = INT_MIN;\n        int sum = 0; // Variable to store the total amount of trapped water\n\n        // Loop until the two pointers meet\n        while (left &lt; right) {\n            // Update the left max height\n            lMax = max(lMax, height[left]);\n            // Update the right max height\n            rMax = max(rMax, height[right]);\n\n            // Calculate trapped water and move pointers\n            if (lMax &lt; rMax) {\n                // If left max is smaller, water trapped is limited by left max\n                sum += lMax - height[left];\n                left++; // Move left pointer\n            } else {\n                // If right max is smaller or equal, water trapped is limited by right max\n                sum += rMax - height[right];\n                right--; // Move right pointer\n            }\n        }\n        return sum;\n    }\n};\n</code></pre> <p>Idea and Algorithm:</p> <p>This approach uses a two-pointer technique to solve the problem. The idea is to move from both ends of the array towards the center, keeping track of the maximum height seen so far from both sides. The key observation is that the amount of water that can be trapped at a given position depends on the maximum height to its left and right.</p> <ol> <li>Initialization: Two pointers (<code>left</code> and <code>right</code>) are initialized at the beginning and the end of the array. Two variables (<code>lMax</code> and <code>rMax</code>) are used to keep track of the maximum heights from the left and right sides, respectively.</li> <li>Processing: The algorithm iterates until <code>left</code> and <code>right</code> pointers meet. At each step, it updates <code>lMax</code> and <code>rMax</code>.</li> <li>Trapping Water: The amount of water that can be trapped at the current position is determined by the smaller of the two maximum heights (<code>lMax</code> and <code>rMax</code>) minus the height at the current position. The pointer corresponding to the smaller maximum height is then moved inward.</li> <li> <p>Termination: The loop terminates when the <code>left</code> and <code>right</code> pointers meet, ensuring that each position is visited exactly once.</p> </li> <li> <p>Time Complexity is \\(O(N)\\): The algorithm iterates through the array only once. Each element is processed in constant time;</p> </li> <li>Space Complexity is \\(O(1)\\): No extra space is required apart from the variables used for iteration and tracking maximum heights, making this a space-efficient solution.</li> </ol>"},{"location":"Leetcode/0001-0099/0042-trapping-rain-water/#solution-using-monotonic-stack","title":"Solution Using Monotonic Stack","text":"<pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        // If there are less than 3 bars, no water can be trapped\n        if (height.size() &lt;= 2) return 0;\n\n        // Initialize a stack to store the indices of bars\n        stack&lt;int&gt; stk;\n\n        int sum = 0; // Variable to store the total amount of trapped water\n\n        // Iterate through each bar\n        for (int i = 0; i &lt; height.size(); i++) {\n\n            // While the stack is not empty and the current bar is taller\n            // than the bar at the top of the stack\n            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) {\n                // The top of the stack is the index of the 'valley' or 'pit'\n                int mid = stk.top();\n                stk.pop();\n\n                // If the stack is empty, we cannot trap water here\n                if (!stk.empty()) {\n                    // Calculate the height of trapped water, which is the \n                    // minimum of the current bar and the next bar on the stack\n                    // minus the height of the 'valley'\n                    int h = min(height[stk.top()], height[i]) - height[mid];\n\n                    // Width is the distance between the current bar and the next bar on the stack\n                    int w = i - stk.top() - 1;\n\n                    // Add the trapped water to the sum\n                    sum += h * w;\n                }\n            }\n\n            // Push the current index onto the stack\n            stk.push(i);\n        }\n\n        // Return the total amount of trapped water\n        return sum;\n    }\n};\n</code></pre> <ul> <li>Time Complexity is \\(O(N)\\): The algorithm iterates through each bar once. The while loop inside the for loop does not add additional complexity as each element is pushed and popped from the stack exactly once;</li> <li>Space Complexity is \\(O(N)\\): In the worst case, all bar indices might be stored in the stack. However, this is a rare case and typically the stack will hold fewer elements.</li> </ul>"},{"location":"Leetcode/0001-0099/0046-permutations/","title":"Permutations","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0046-permutations/#description","title":"Description","text":"<p>Given an array <code>nums</code> of distinct integers, return all the possible permutations. You can return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,2,3]</code></li> <li>Output: <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0,1]</code></li> <li>Output: <code>[[0,1],[1,0]]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>nums = [1]</code></li> <li>Output: <code>[[1]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 6</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> <li>All the integers of <code>nums</code> are unique.</li> </ul>"},{"location":"Leetcode/0001-0099/0046-permutations/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0046-permutations/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n\n    void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) {\n        if (path.size() == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (used[i] == true) continue;\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        vector&lt;bool&gt; used(nums.size(), false);\n        backtracking(nums, used);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0046-permutations/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    vector&lt;bool&gt; used;\n    void backtracking(vector&lt;int&gt;&amp; nums, int index) {\n        if (index == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (!used[i]) {\n                path[index] = nums[i];\n                used[i] = true;\n                backtracking(nums, index + 1);\n                used[i] = false;\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        path = vector&lt;int&gt;(nums.size(), 0);\n        used = vector&lt;bool&gt;(nums.size(), false);\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\times n!)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0047-permutations-ii/","title":"Permutations II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0047-permutations-ii/#description","title":"Description","text":"<p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return all possible unique permutations in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,1,2]</code></li> <li>Output: <code>[[1,1,2], [1,2,1], [2,1,1]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1,2,3]</code></li> <li>Output: <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 8</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> </ul>"},{"location":"Leetcode/0001-0099/0047-permutations-ii/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) {\n        if (path.size() == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;\n            if (used[i]) continue;\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;bool&gt; used(nums.size(), false);\n        backtracking(nums, used);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0051-n-queens/","title":"N-Queens","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0051-n-queens/#description","title":"Description","text":"<p>The n-queens puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p> <p>Given an integer <code>n</code>, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.</p> <p>Each solution contains a distinct board configuration of the n-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space, respectively.</p> <p>Example 1:</p> <p></p> <ul> <li>Input: <code>n = 4</code></li> <li>Output: <code>[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]</code></li> <li>Explanation: There exist two distinct solutions to the <code>4</code>-queens puzzle as shown above</li> </ul> <p>Example 2:</p> <ul> <li>Input: n = 1</li> <li>Output: [[\"Q\"]]</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 9</code></li> </ul>"},{"location":"Leetcode/0001-0099/0051-n-queens/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0051-n-queens/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    void backtracking(vector&lt;string&gt;&amp; board, int n, int row) {\n        if (row == n) {\n            res.push_back(board);\n            return;\n        }\n\n        for (int col = 0; col &lt; n; col++) {\n            if (!isValid(row, col, board, n)) continue;\n            board[row][col] = 'Q';\n            backtracking(board, n, row + 1);\n            board[row][col] = '.';\n        }\n    }\n\n    bool isValid(int row, int col, vector&lt;string&gt;&amp; board, int n) {\n        for (int i = 0; i &lt; row; i++) {\n            if (board[i][col] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {\n            if (board[i][j] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {\n            if (board[i][j] == 'Q') return false;\n        }\n        return true;\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        vector&lt;string&gt; board(n, string(n, '.'));\n        backtracking(board, n, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0051-n-queens/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    int sizeBoard;\n    vector&lt;bool&gt; column, lDiagonal, rDiagonal;\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n    void backtracking(int index) {\n        // Base case: if all queens are placed\n        if (index == sizeBoard) {\n            res.push_back(path);  // Add the current board configuration to the result\n            return;\n        }\n\n        // Trying to place a queen in each column of the current row\n        for (int j = 0; j &lt; sizeBoard; j++) {\n            // Check if the current column, left diagonal, and right diagonal are safe\n            if (column[j] || lDiagonal[index + j] || rDiagonal[sizeBoard - index + j]) continue;\n\n            // Place the queen and mark the column, left diagonal, and right diagonal as occupied\n            column[j] = lDiagonal[index + j] = rDiagonal[sizeBoard - index + j] = true;\n            path[index][j] = 'Q';\n\n            // Move to the next row\n            backtracking(index + 1);\n\n            // Backtrack: remove the queen and unmark the column, left diagonal, and right diagonal\n            path[index][j] = '.';\n            column[j] = lDiagonal[index + j] = rDiagonal[sizeBoard - index + j] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        sizeBoard = n;\n        column = vector&lt;bool&gt;(sizeBoard, false);\n        lDiagonal = rDiagonal = vector&lt;bool&gt;(2 * sizeBoard, false);\n        path = vector&lt;string&gt;(sizeBoard, string(sizeBoard, '.'));\n\n        backtracking(0);  // Start backtracking from the first row\n\n        return res;\n    }\n};\n</code></pre> <p>Understanding the Safe Spot Determination:</p> <p>In the N-Queens problem, a spot (or cell) on the board is considered \"safe\" if no other queen can attack the queen placed on that spot. Note that a queen in chess can move vertically, horizontally, and diagonally over any number of unoccupied squares. Therefore, a spot is safe if:</p> <ol> <li>No Other Queen in the Same Column: Since a queen can attack any square in her column, we must ensure that no other queen is placed in the same column.</li> <li>No Other Queen in the Same Diagonals: A queen can also attack any square on the diagonals originating from her position. This includes both left and right diagonals.</li> </ol> <p>To efficiently check these conditions, the solution uses three arrays: <code>column</code>, <code>lDiagonal</code>, and <code>rDiagonal</code>.</p> <ul> <li><code>column</code> Array: Tracks whether a column is occupied by a queen.</li> <li><code>lDiagonal</code> and <code>rDiagonal</code> Arrays: Track the diagonals. Diagonals are a bit trickier to handle. Each diagonal can be uniquely identified by a particular property:<ul> <li>Right ( \\(\\searrow\\) ) Diagonals: On these diagonals, the row index minus the column index (<code>row - column</code>) is constant.</li> <li>Left ( \\(\\swarrow\\) ) Diagonals: Here, the row index plus the column index (<code>row + column</code>) is constant.</li> </ul> </li> </ul> <p>However, to use arrays efficiently and avoid negative indices for left diagonals, an offset is added. That's why for right diagonals, we use <code>sizeBoard - index + j</code> to keep indices positive and within the array bounds.</p> <p>Execution of the Solution:</p> <ol> <li>Initialization: When <code>solveNQueens</code> is called, it initializes all necessary arrays and variables. The <code>path</code> array is initialized to represent an empty N\u00d7N chessboard.</li> <li>Recursive Backtracking: The function <code>backtracking</code> is called starting from the first row (index 0).</li> <li>Placing a Queen: For each row, the algorithm iterates through each column (<code>j</code>) and checks if placing a queen there is safe:<ul> <li>It checks <code>column[j]</code>, <code>lDiagonal[index + j]</code>, and <code>rDiagonal[sizeBoard - index + j]</code>. If any of these are <code>true</code>, it means the corresponding column or diagonal is already occupied by another queen, and it moves to the next column.</li> </ul> </li> <li>Marking the Board: If a safe spot is found, the algorithm places a queen there (<code>path[index][j] = 'Q'</code>) and marks the column and diagonals as occupied.</li> <li>Recursion to Next Row: After placing a queen, the algorithm recursively calls <code>backtracking</code> for the next row (<code>index + 1</code>).</li> <li>Backtracking: If it turns out that no further queens can be placed, or after successfully placing all queens, the function backtracks:<ul> <li>It removes the queen from the current cell (<code>path[index][j] = '.'</code>).</li> <li>It unmarks the column and diagonals.</li> <li>The loop then continues to try the next column in the current row.</li> </ul> </li> <li>Adding to Result: Once a queen is successfully placed in the last row (base case), the current board configuration (<code>path</code>) is added to the results (<code>res</code>).</li> </ol> <p>Complexity:</p> <ul> <li>Time Complexity: Worst-Case Time Complexity is \\(O(N!)\\)<ul> <li>In the worst case, the algorithm tries to place a queen in each column of each row. The number of possibilities decreases with each level of recursion, leading to \\(N!\\) (factorial) as the upper bound.</li> </ul> </li> <li>Space Complexity: Space Complexity is \\(O(N)\\)<ul> <li>The space complexity is linear due to the storage of the board state and the recursive call stack. The board state requires \\(O(N)\\) space, and the maximum depth of the recursive call stack is \\(N\\).</li> </ul> </li> </ul> <p>Another way of writing:</p> <pre><code>class Solution {\nprivate:\n    int sz;\n    vector&lt;bool&gt; col, dg, udg;\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n    void backtracking(int row) {\n        if (row == sz) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; sz; i++) {\n            if (!col[i] &amp;&amp; !dg[row - i + sz] &amp;&amp; !udg[row + i]) {\n                col[i] = dg[row - i + sz] = udg[row + i] = true;\n                path[row][i] = 'Q';\n                backtracking(row + 1);\n                path[row][i] = '.';\n                col[i] = dg[row - i + sz] = udg[row + i] = false;\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        sz = n;\n        col = vector&lt;bool&gt;(n);\n        dg = udg = vector&lt;bool&gt;(2 * n);\n        path = vector&lt;string&gt;(n, string(n, '.'));\n        backtracking(0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0052-n-queens-ii/","title":"N-Queens II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0052-n-queens-ii/#description","title":"Description","text":"<p>The n-queens puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p> <p>Given an integer <code>n</code>, return the number of distinct solutions to the n-queens puzzle.</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 4</code></li> <li>Output: <code>2</code></li> <li>Explanation: There are two distinct solutions to the <code>4</code>-queens puzzle as shown.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 1</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 9</code></li> </ul>"},{"location":"Leetcode/0001-0099/0052-n-queens-ii/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    int res;\n    vector&lt;bool&gt; dg, udg, col;\n    int _n;\n    void backtracking(int row) {\n        if (row == _n) {\n            res++;\n            return;\n        }\n        for (int i = 0; i &lt; _n; i++) {\n            if (!col[i] &amp;&amp; !dg[row - i + _n] &amp;&amp; !udg[row + i]) {\n                col[i] = dg[row - i + _n] = udg[row + i] = true;\n                backtracking(row + 1);\n                col[i] = dg[row - i + _n] = udg[row + i] = false;\n            }\n        }\n    }\npublic:\n    int totalNQueens(int n) {\n        _n = n;\n        col = vector&lt;bool&gt;(n, false);\n        dg = udg = vector&lt;bool&gt;(2 * n, false);\n        res = 0;\n        backtracking(0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N!)\\);</li> <li>Space complexity: \\(O(N)\\).</li> </ul> <p>Another way of writing:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;bool&gt; col, dg, udg;\n    int _n;\n    int backtracking(int row) {\n        if (row == _n) return 1;\n        int res = 0;\n        for (int i = 0; i &lt; _n; i++) {\n            if (!col[i] &amp;&amp; !dg[row - i + _n] &amp;&amp; !udg[row + i]) {\n                col[i] = dg[row - i + _n] = udg[row + i] = true;\n                res += backtracking(row + 1);\n                col[i] = dg[row - i + _n] = udg[row + i] = false;\n            }\n        }\n        return res;\n    }\npublic:\n    int totalNQueens(int n) {\n        col = vector&lt;bool&gt;(n);\n        dg = udg = vector&lt;bool&gt;(2 * n);\n        _n = n;\n        return backtracking(0);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0054-spiral-matrix/","title":"Spiral Matrix","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0054-spiral-matrix/#description","title":"Description","text":"<p>Given an \\(m\\times n\\) <code>matrix</code>, return all elements of the <code>matrix</code> in spiral order.</p> <p>Example 1:</p> <ul> <li>Input: <code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code></li> <li>Output: <code>[1,2,3,6,9,8,7,4,5]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</code></li> <li>Output: <code>[1,2,3,4,8,12,11,10,9,5,6,7]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>m == matrix.length</code></li> <li><code>n == matrix[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 10</code></li> <li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0001-0099/0054-spiral-matrix/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0054-spiral-matrix/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; res;\n        int m = matrix.size(), n = matrix[0].size();\n        int upper_bound = 0, lower_bound = m - 1;\n        int left_bound = 0, right_bound = n - 1;\n        // res.size() == m * n then all the array is traversed\n        while (res.size() &lt; m * n) {\n            if (upper_bound &lt;= lower_bound) {\n                // Iterate from left to right at the top\n                for (int j = left_bound; j &lt;= right_bound; j++)\n                    res.push_back(matrix[upper_bound][j]);\n                // Move the upper boundary down\n                upper_bound++;\n            }\n\n            if (left_bound &lt;= right_bound) {\n                // Iterate from top to bottom on the right side\n                for (int i = upper_bound; i &lt;= lower_bound; i++)\n                    res.push_back(matrix[i][right_bound]);\n                // Shift the right boundary left\n                right_bound--;\n            }\n\n            if (upper_bound &lt;= lower_bound) {\n                // Iterate from right to left at the bottom\n                for (int j = right_bound; j &gt;= left_bound; j--)\n                    res.push_back(matrix[lower_bound][j]);\n                // Move the lower boundary up\n                lower_bound--;\n            }\n\n            if (left_bound &lt;= right_bound) {\n                // Iterate from bottom to top on the left side\n                for (int i = lower_bound; i &gt;= upper_bound; i--)\n                    res.push_back(matrix[i][left_bound]);\n                // Move the left boundary right\n                left_bound++;\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(nm)\\);</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"Leetcode/0001-0099/0054-spiral-matrix/#way-2-direction-array-preferred","title":"Way 2: Direction Array (Preferred)","text":"\\[ \\begin{cases}     \\Rightarrow : \\left( 0,1 \\right)\\\\     \\Downarrow : \\left( 1,0 \\right)\\\\     \\Leftarrow : \\left( 0,-1 \\right)\\\\     \\Uparrow : \\left( -1,0 \\right)\\\\ \\end{cases} \\] <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; res;\n        int n = matrix.size();  // # of rows of matrix\n        if (!n) return res;\n        int m = matrix[0].size();  // # of columns of matrix\n\n        // direction array\n        int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n        // track if we have traversed to the element\n        vector&lt;vector&lt;bool&gt;&gt; state(n, vector&lt;bool&gt;(m));\n\n        for (int i = 0, x = 0, y = 0, d = 0; i &lt; n * m; i++) {\n            res.push_back(matrix[x][y]);\n            state[x][y] = true;\n\n            int a = x + dx[d], b = y + dy[d];\n            // change direction\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || state[a][b]) {\n                d = (d + 1) % 4;\n                a = x + dx[d], b = y + dy[d];\n            }\n            x = a, y = b;\n        }\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(nm)\\);</li> <li>Space complexity: \\(O(n)\\)</li> </ul>"},{"location":"Leetcode/0001-0099/0059-spiral-matrix-ii/","title":"Spiral Matrix II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0059-spiral-matrix-ii/#description","title":"Description","text":"<p>Given a positive integer \\(n\\), generate an \\(n\\times n\\) matrix filled with elements from 1 to \\(n^2\\) in spiral order.</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 3</code></li> <li>Output: <code>[[1,2,3],[8,9,4],[7,6,5]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 1</code></li> <li>Output: <code>[[1]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 20</code></li> </ul>"},{"location":"Leetcode/0001-0099/0059-spiral-matrix-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0059-spiral-matrix-ii/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {\n        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));  // define a 2D array using vector\n\n        int start_x, start_y;  //define staring position for looping every circle\n        // This number records how many loops each circle is made, \n        // e.g., if n is an odd number 3, then loop = 1 is just one circle, \n        // and the values in the middle of the matrix need to be handled separately\n        int loop = n / 2;\n\n        int count = 1;  // assign value to every element of matrix\n\n        // The position in the middle of the matrix, \n        // e.g., if n is 3, the position in the middle is (1, 1) \n        // and if n is 5, the position in the middle is (2, 2)\n        int mid = n / 2;\n\n        // The length of each edge traversal needs to be controlled \n        // by shrinking the right boundary one position per loop.\n        int offset = 1;\n\n        int i, j;\n\n        while (loop--) {\n            i = start_x;\n            j = start_y;\n\n            // fills the upper row from left to right (left-closed-right-open intervals)\n            for (j = start_y; j &lt; n - offset; j++) res[start_x][j] = count++;\n            // fills the right column from top to bottom (left-closed right-open intervals)\n            for (i = start_x; i &lt; n - offset; i++) res[i][j] = count++;\n            // fills the lower row from right to left (left-closed-right-open intervals)\n            for (; j &gt; start_y; j--) res[i][j] = count++;\n            // fills the left column from bottom to top (left-closed-right-open intervals)\n            for (; i &gt; start_x; i--) res[i][j] = count++;\n\n            // At the beginning of the second lap, \n            // the starting position should be increased by 1 each, \n            // e.g. the starting position of the first circle is (0, 0), \n            // and the starting position of the second circle is (1, 1)\n            start_x++;\n            start_y++;\n\n            // offset controls the length of each edge traversed in each circle\n            offset++;\n        }\n\n        // If n is odd, we need to assign a separate value \n        // to the middle-most position of the matrix\n        if (n % 2) res[mid][mid] = count;\n\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"Leetcode/0001-0099/0059-spiral-matrix-ii/#way-2-direction-array-preferred","title":"Way 2: Direction Array (Preferred)","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {\n        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));\n\n        int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n        for (int i = 1, x = 0, y = 0, d = 0; i &lt;= n * n; i++) {\n            res[x][y] = i;\n\n            int a = x + dx[d], b = y + dy[d];\n            // change direction\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || res[a][b]) {\n                d = (d + 1) % 4;\n                a = x + dx[d], b = y + dy[d];\n            }\n            x = a, y = b;\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0062-unique-paths/","title":"Unique Paths","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0062-unique-paths/#description","title":"Description","text":"<p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>Given the two integers <code>m</code> and <code>n</code>, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p> <p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10^9</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>m = 3, n = 7</code></li> <li>Output: <code>28</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>m = 3, n = 2</code></li> <li>Output: <code>3</code></li> <li> <p>Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p> </li> <li> <p>Right -&gt; Down -&gt; Down</p> </li> <li>Down -&gt; Down -&gt; Right</li> <li>Down -&gt; Right -&gt; Down</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= m, n &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0001-0099/0062-unique-paths/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0062-unique-paths/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int dp[110][110];\n    int uniquePaths(int m, int n) {\n        for (int i = 0; i &lt; 110; i++) dp[i][0] = dp[0][i] = 1;\n        for (int i = 1; i &lt; m; i++) \n            for (int j = 1; j &lt; n; j++)\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        return dp[m - 1][n - 1];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m\\times n)\\);</li> <li>Space complexity: \\(O(m\\times n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0062-unique-paths/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int dp[110];\n    int uniquePaths(int m, int n) {\n        for (int i = 0; i &lt; n; i++) dp[i] = 1;\n        for (int j = 1; j &lt; m; j++)\n            for (int i = 1; i &lt; n; i++)\n                dp[i] += dp[i - 1];\n        return dp[n - 1];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m\\times n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/","title":"Unique Paths II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/#description","title":"Description","text":"<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in grid. A path that the robot takes cannot include any square that is an obstacle.</p> <p>Return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p> <p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10^9</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</code></li> <li>Output: <code>2</code></li> <li> <p>Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner:</p> </li> <li> <p>Right -&gt; Right -&gt; Down -&gt; Down</p> </li> <li>Down -&gt; Down -&gt; Right -&gt; Right</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>obstacleGrid = [[0,1],[0,0]]</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li><code>m == obstacleGrid.length</code></li> <li><code>n == obstacleGrid[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 100</code></li> <li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));\n        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;\n        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;\n\n        for (int i = 1; i &lt; m; i++) {\n            for (int j = 1; j &lt; n; j++) {\n                if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                else continue;\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m\\times n)\\);</li> <li>Space complexity: \\(O(m\\times n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/#way-2","title":"Way 2","text":"<p>See reference.</p> <pre><code>class Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n        dp[0][1] = 1;\n        for (int i = 1; i &lt;= m; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (obstacleGrid[i - 1][j - 1] == 0)\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m][n];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0063-unique-paths-ii/#way-3","title":"Way 3","text":"<pre><code>class Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector&lt;int&gt; dp(n);\n        dp[0] = (obstacleGrid[0][0] == 0) ? 1 : 0;\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[j] = 0;\n                    continue;\n                }\n                if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid[i][j - 1] == 0)\n                    dp[j] += dp[j - 1];\n            }\n        }\n        return dp.back();\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(m\\times n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0070-climbing-stairs/","title":"Climbing Stairs","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0070-climbing-stairs/#description","title":"Description","text":"<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p> <p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 2</code></li> <li>Output: <code>2</code></li> <li>Explanation: There are two ways to climb to the top.</li> </ul> <pre><code>1. 1 step + 1 step\n2. 2 steps\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>n = 3</code></li> <li>Output: <code>3</code></li> <li>Explanation: There are three ways to climb to the top.</li> </ul> <pre><code>1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 45</code></li> </ul>"},{"location":"Leetcode/0001-0099/0070-climbing-stairs/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0070-climbing-stairs/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int dp[50];\n    int climbStairs(int n) {\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0070-climbing-stairs/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n &lt;= 1) return 1;\n        int a = 1, b = 2;\n        for (int i = 3; i &lt;= n; i++) {\n            int sum = a + b;\n            a = b;\n            b = sum;\n        }\n        return b;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0077-combinations/","title":"Combinations","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0077-combinations/#description","title":"Description","text":"<p>Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k</code> numbers chosen from the range <code>[1, n]</code>.</p> <p>You may return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 4, k = 2</code></li> <li>Output: <code>[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</code></li> <li>Explanation: There are <code>4 choose 2 = 6</code> total combinations. Note that combinations are unordered, i.e., <code>[1,2]</code> and <code>[2,1]</code> are considered to be the same combination.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 1, k = 1</code></li> <li>Output: <code>[[1]]</code></li> <li>Explanation: There is <code>1 choose 1 = 1</code> total combination.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 20</code></li> <li><code>1 &lt;= k &lt;= n</code></li> </ul>"},{"location":"Leetcode/0001-0099/0077-combinations/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0077-combinations/#backtracking-algorithm-recursive","title":"Backtracking Algorithm (Recursive)","text":"<p>Template pseudocode:</p> <pre><code>void backtracking(parameters) {\n    if (termination condition) {\n        store result;\n        return;\n    }\n\n    for (choice : elements in the current level set (the number of children of a node in the tree is the size of the set)) {\n        process node;\n        backtracking(path, choice list); // recursion\n        backtrack, undo processing result\n    }\n}\n</code></pre> <p>Original Solution:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtrack(int n, int k, int startIndex) {\n        if (!k) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt;= n; i++) {\n            path.push_back(i);\n            backtrack(n, k - 1, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        backtrack(n, k, 1);\n        return res;\n    }\n};\n</code></pre> <p>Solution after pruning:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtrack(int n, int k, int startIndex) {\n        if (path.size() == k) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) {\n            path.push_back(i);\n            backtrack(n, k, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        backtrack(n, k, 1);\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;  // To store all combinations\n    vector&lt;int&gt; path;         // To store the current combination\n\n    // The backtrack function to generate all combinations\n    void backtrack(int n, int k, int startIndex) {\n        // Base case: if the combination is of size k, add it to the result\n        if (path.size() == k) {\n            res.push_back(path);\n            return;\n        }\n\n        // Iterate through the numbers starting from startIndex\n        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) {\n            path.push_back(i);      // Include the number i in the current combination\n            backtrack(n, k, i + 1); // Recur with the next number\n            path.pop_back();        // Backtrack: remove the last number added\n        }\n    }\n\npublic:\n    // The public function that initiates the backtracking\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        backtrack(n, k, 1);  // Start backtracking from 1\n        return res;          // Return all generated combinations\n    }\n};\n</code></pre> <p>Algorithm Steps:</p> <ol> <li>Initialization: The class maintains two vectors, <code>res</code> for storing all combinations and <code>path</code> for the current combination being explored.</li> <li>Backtracking Function (<code>backtrack</code>):<ul> <li>Base Case: If the size of <code>path</code> is equal to <code>k</code>, the desired combination size, the current combination is added to <code>res</code>.</li> <li>Recursive Case: The function iterates from <code>startIndex</code> to <code>n - (k - path.size()) + 1</code>. This iteration limit ensures that there are enough elements left to complete the combination. For each iteration:<ul> <li>Add the current element <code>i</code> to <code>path</code>.</li> <li>Recursively call <code>backtrack</code> with the next starting index (<code>i + 1</code>).</li> <li>Perform backtracking by removing the last element from <code>path</code> to explore other combinations.</li> </ul> </li> </ul> </li> <li>Generating Combinations: The public <code>combine</code> function initiates the backtracking process starting from index <code>1</code>.</li> </ol> <p>Backtracking is a DFS (depth-first search) approach to explore all possible combinations. In this problem, backtracking helps in generating all combinations of size <code>k</code> from numbers <code>1</code> to <code>n</code>. Whenever a combination of size <code>k</code> is formed, it is added to the result. The algorithm then backtracks to replace the last element with the next possible number and continues this process until all combinations are explored.</p> <p>Time Complexity:</p> <ul> <li>Worst Case: \\(O\\left( C_{n}^{k}\\times k \\right)\\)</li> <li>There are \\(C_{n}^{k}\\) possible combinations.</li> <li>For each combination, it takes \\(O(k)\\) time to copy the <code>path</code> vector to <code>res</code>.</li> </ul> <p>Space Complexity:</p> <ul> <li>\\(O\\left( n+k \\right) \\approx O\\left( n \\right)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0077-combinations/#backtracking-algorithm-iterative","title":"Backtracking Algorithm (Iterative)","text":"<p>See reference.</p> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        vector&lt;vector&lt;int&gt;&gt; res;  // To store all combinations\n        int index = 0;            // Tracks the current position in the combination\n        vector&lt;int&gt; path(k, 0);   // Current combination, initialized with zeros\n\n        while (index &gt;= 0) {\n            path[index]++;        // Increment the current element\n\n            // If the current element exceeds n, move back to the previous element\n            if (path[index] &gt; n) index--;\n\n            // If a complete combination is formed, add it to the results\n            else if (index == k - 1) res.push_back(path);\n\n            // Move to the next element and initialize it\n            else {\n                index++;\n                path[index] = path[index - 1];\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstring toString(vector&lt;int&gt; v) {\n    string ans = \"[\";\n    for (int i: v) {\n        ans += i + '0';\n        ans += \", \";\n    }\n    ans = ans.substr(0, ans.length() - 2) + \"]\";\n    return ans;\n}\n\nstring toString(vector&lt;vector&lt;int&gt;&gt; v) {\n    string ans = \"[\";\n    for (vector&lt;int&gt; i: v) {\n        ans += toString(i);\n        ans += \", \";\n    }\n    ans = ans.substr(0, ans.length() - 2) + \"]\";\n    return ans;\n}\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; c(k, 0); // vector of length k, all 0s\n        int i = 0;\n        while (i &gt;= 0) {\n            // Increment element at index i\n            c[i]++;\n            cout &lt;&lt; \"Incremented element at index \" &lt;&lt; i &lt;&lt; endl;\n            cout &lt;&lt; toString(c) &lt;&lt; endl;\n\n            /* Move index to the left if the element\n             * at index i has exceeded n.\n             */\n            if (c[i] &gt; n) {\n                i--;\n                cout &lt;&lt; \"n exceeded at \" &lt;&lt; i+1 &lt;&lt; \", moving index to the left\" &lt;&lt; endl;\n            }\n\n            /* If the index is at the end of the vector\n             * c, then (because the other conditions are\n             * obeyed), we know we have a valid combination,\n             * so push it to our ans vector&lt;vector&lt;&gt;&gt;\n             */\n            else if (i == k - 1) {\n                ans.push_back(c);\n                cout &lt;&lt; \"Combination found!\" &lt;&lt; endl;\n                cout &lt;&lt; \"Added \" &lt;&lt; toString(c) &lt;&lt; \" as an answer!\" &lt;&lt; endl;\n            }\n\n            /* Move index to the right and set the\n             * element at that index equal to the\n             * element at the previous index.\n             * \n             * Because of the increment at the beginning\n             * of this while loop, we ensure that the\n             * element at this index will be at least\n             * one more than its neighbor to the left.\n             */\n            else {\n                i++;\n                c[i] = c[i - 1];\n                cout &lt;&lt; \"Moved index to the right, and copied the value\"\n                &lt;&lt; \" from the left\" &lt;&lt; endl;\n                cout &lt;&lt; toString(c) &lt;&lt; endl;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout &lt;&lt; toString(sol.combine(4, 2)) &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Simulation result:</p> <pre><code>Incremented element at index 0\n[1, 0]\nMoved index to the right, and copied the value from the left\n[1, 1]\nIncremented element at index 1\n[1, 2]\nCombination found!\nAdded [1, 2] as an answer!\nIncremented element at index 1\n[1, 3]\nCombination found!\nAdded [1, 3] as an answer!\nIncremented element at index 1\n[1, 4]\nCombination found!\nAdded [1, 4] as an answer!\nIncremented element at index 1\n[1, 5]\nn exceeded at 1, moving index to the left\nIncremented element at index 0\n[2, 5]\nMoved index to the right, and copied the value from the left\n[2, 2]\nIncremented element at index 1\n[2, 3]\nCombination found!\nAdded [2, 3] as an answer!\nIncremented element at index 1\n[2, 4]\nCombination found!\nAdded [2, 4] as an answer!\nIncremented element at index 1\n[2, 5]\nn exceeded at 1, moving index to the left\nIncremented element at index 0\n[3, 5]\nMoved index to the right, and copied the value from the left\n[3, 3]\nIncremented element at index 1\n[3, 4]\nCombination found!\nAdded [3, 4] as an answer!\nIncremented element at index 1\n[3, 5]\nn exceeded at 1, moving index to the left\nIncremented element at index 0\n[4, 5]\nMoved index to the right, and copied the value from the left\n[4, 4]\nIncremented element at index 1\n[4, 5]\nn exceeded at 1, moving index to the left\nIncremented element at index 0\n[5, 5]\nn exceeded at 0, moving index to the left\n[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n</code></pre> <p>Explanation:</p> <ol> <li>Initialization: <code>res</code> is used to store the resulting combinations. <code>index</code> is the position in the current combination being processed, and <code>path</code> is a vector of size <code>k</code>, initially filled with zeros.</li> <li>Iteration: The <code>while</code> loop continues as long as <code>index</code> is non-negative.</li> <li>Incrementing Elements: <code>path[index]++</code> increments the element at the current position.</li> <li>Backtracking: If <code>path[index]</code> becomes greater than <code>n</code>, it means we need to backtrack, i.e., move back to the previous position (<code>index--</code>).</li> <li>Adding a Combination: If <code>index</code> is <code>k - 1</code> and the current element is valid (\u2264 <code>n</code>), a complete combination is formed and added to <code>res</code>.</li> <li>Moving Forward: If neither of the above conditions is met, the algorithm moves to the next position (<code>index++</code>) and initializes <code>path[index]</code> to <code>path[index - 1]</code>.</li> </ol>"},{"location":"Leetcode/0001-0099/0078-subsets/","title":"Subsets","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0078-subsets/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> of unique elements, return all possible subsets (the power set).</p> <p>A subset of an array is a selection of elements (possibly none) of the array.</p> <p>The solution set must not contain duplicate subsets. Return the solution in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,2,3]</code></li> <li>Output: <code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0]</code></li> <li>Output: <code>[[],[0]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> <li>All the numbers of <code>nums</code> are unique.</li> </ul>"},{"location":"Leetcode/0001-0099/0078-subsets/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0078-subsets/#recursive-solution","title":"Recursive Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        res.push_back(path);\n\n        // this terminating condition is optional\n        // if (startIndex &gt;= nums.size()) return;\n\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\times 2^n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0078-subsets/#iterative-solution-using-binary-representation","title":"Iterative Solution Using Binary Representation","text":"<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int n = nums.size();\n        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n            vector&lt;int&gt; path;\n            for (int j = 0; j &lt; n; j++) {\n                if (i &gt;&gt; j &amp; 1)\n                    path.push_back(nums[j]);\n            }\n            res.push_back(path);\n        }\n        return res;\n    }\n};\n</code></pre> <p>Explanation:</p> <p>Outer Loop: Generating Each Subset:</p> <pre><code>for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n    ...\n}\n</code></pre> <ul> <li>This loop iterates through all possible binary representations of numbers from <code>0</code> to <code>2^n - 1</code> (where <code>n</code> is the size of the input set).</li> <li>Each number <code>i</code> in this range represents a unique subset. The binary representation of <code>i</code> determines which elements are included in the subset.</li> </ul> <p>Inner Loop: Deciding Which Elements to Include:</p> <pre><code>vector&lt;int&gt; path;\nfor (int j = 0; j &lt; n; j++) {\n    if (i &gt;&gt; j &amp; 1)\n        path.push_back(nums[j]);\n}\n</code></pre> <ul> <li>For each <code>i</code>, a new vector <code>path</code> is created to store the current subset.</li> <li>The inner loop iterates through each bit of <code>i</code>.</li> <li><code>i &gt;&gt; j</code> shifts the bits of <code>i</code> right by <code>j</code> places. This effectively checks each bit of <code>i</code> from right to left.</li> <li>The <code>&amp; 1</code> operation checks if the rightmost bit is <code>1</code>. If it is, it means the element at index <code>j</code> in <code>nums</code> should be included in the current subset.</li> <li>If the condition is true, <code>nums[j]</code> is added to <code>path</code>.</li> </ul>"},{"location":"Leetcode/0001-0099/0090-subsets-ii/","title":"Subsets II","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0090-subsets-ii/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> that may contain duplicates, return all possible subsets (the power set).</p> <p>A subset of an array is a selection of elements (possibly none) of the array.</p> <p>The solution set must not contain duplicate subsets. Return the solution in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,2,2]</code></li> <li>Output: <code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0]</code></li> <li>Output: <code>[[],[0]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> </ul>"},{"location":"Leetcode/0001-0099/0090-subsets-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0090-subsets-ii/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) {\n        res.push_back(path);\n        unordered_set&lt;int&gt; used;\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (used.find(nums[i]) != used.end()) continue;\n            used.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0090-subsets-ii/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        res.push_back(path);\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1]) continue;\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n       sort(nums.begin(), nums.end());\n       backtracking(nums, 0);\n       return res; \n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0093-restore-ip-addresses/","title":"Restore IP Addresses","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0093-restore-ip-addresses/#description","title":"Description","text":"<p>A valid IP address consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (inclusive) and cannot have leading zeros.</p> <ul> <li>For example, <code>\"0.1.2.201\"</code> and <code>\"192.168.1.1\"</code> are valid IP addresses, but <code>\"0.011.255.245\"</code>, <code>\"192.168.1.312\"</code> and <code>\"192.168@1.1\"</code> are invalid IP addresses.</li> </ul> <p>Given a string <code>s</code> containing only digits, return all possible valid IP addresses that can be formed by inserting dots into <code>s</code>. You are not allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"25525511135\"</code></li> <li>Output: <code>[\"255.255.11.135\",\"255.255.111.35\"]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"0000\"</code></li> <li>Output: <code>[\"0.0.0.0\"]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>s = \"101023\"</code></li> <li>Output: <code>[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 20</code></li> <li><code>s</code> consists of digits only.</li> </ul>"},{"location":"Leetcode/0001-0099/0093-restore-ip-addresses/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0093-restore-ip-addresses/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n    void backtracking(const string &amp;s, int startIndex) {\n        if (startIndex == s.length() &amp;&amp; path.size() == 4) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; s.length(); i++) {\n            if (path.size() &gt;= 4) break;\n            if (!isValidIP(s, startIndex, i)) continue;\n            path.push_back(s.substr(startIndex, i - startIndex + 1));\n            backtracking(s, i + 1);\n            path.pop_back();\n        }\n    }\n\n    bool isValidIP(const string &amp;s, int startIndex, int i) {\n        int len = i - startIndex + 1;\n        if (len &gt; 3 || len == 0) return false;\n        if (len &gt; 1 &amp;&amp; s[startIndex] == '0') return false;\n        if (stoi(s.substr(startIndex, len)) &gt; 255) return false;\n        return true;\n    }\n\n    vector&lt;string&gt; vecStr2Str(const vector&lt;vector&lt;string&gt;&gt; &amp;arr) {\n        vector&lt;string&gt; result{};\n        for (vector&lt;string&gt; elm : arr) {\n            string temp{};\n            for (int i = 0; i &lt; elm.size(); i++) {\n                temp += elm[i];\n                if (i &lt; elm.size() - 1) temp += \".\";\n            }\n            result.push_back(temp);\n        }\n        return result;\n    }\n\npublic:\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        backtracking(s, 0);\n        return vecStr2Str(res);\n    }\n};\n</code></pre> <p>Modified version:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; res; // This vector stores the final results, i.e., all valid IP addresses.\n    vector&lt;string&gt; path; // This vector temporarily holds each part of the currently constructing IP address.\n\n    // The backtracking function tries to build the IP address from the input string 's', starting from 'startIndex'.\n    void backtracking(const string &amp;s, int startIndex) {\n        // If startIndex reaches the end of string 's' and exactly 4 parts are found, add the constructed IP to 'res'.\n        if (startIndex == s.length() &amp;&amp; path.size() == 4) {\n            res.push_back(path2String(path));\n            return;\n        }\n\n        // Iterate through the string to try different splits for IP address parts.\n        for (int i = startIndex; i &lt; s.size(); i++) {\n            // Check if the substring from startIndex to i forms a valid IP segment.\n            if (!isValidIP(s, startIndex, i)) continue;\n            // If more than 4 parts are formed, it's not a valid IP, so break.\n            if (path.size() &gt;= 4) break;\n            // Add the valid segment to the path.\n            path.push_back(s.substr(startIndex, i - startIndex + 1));\n            // Recursively call backtracking for the next segment.\n            backtracking(s, i + 1);\n            // Backtrack: remove the last segment before the next iteration.\n            path.pop_back();\n        }\n    }\n\n    // Function to check if the substring of 's' from 'start' to 'end' is a valid IP segment.\n    bool isValidIP(const string &amp;s, int start, int end) {\n        // If the segment starts with '0' and is longer than 1 character, it's invalid.\n        if (s[start] == '0' &amp;&amp; start != end) return false;\n        int num = 0;\n        // Convert the substring to a number and check if it's &lt;= 255.\n        for (int i = start; i &lt;= end; i++) {\n            num = 10 * num + s[i] - '0';\n            if (num &gt; 255) return false;\n        }\n        return true;\n    }\n\n    // Function to convert the segments in 'path' into a dot-separated IP address string.\n    string path2String(vector&lt;string&gt; &amp;path) {\n        string result = \"\";\n        for (int i = 0; i &lt; path.size(); i++) {\n            result += path[i];\n            // Add '.' between the segments, but not after the last segment.\n            if (i &lt; path.size() - 1) result += \".\";\n        }\n        return result;\n    }\npublic:\n    // Public function to initiate the backtracking process and return all possible valid IP addresses.\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        backtracking(s, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0093-restore-ip-addresses/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; res;\n    void backtracking(const string &amp;s, int startIndex, int currSize, string path) {\n        if (startIndex == s.length()) {\n            if (currSize == 4) {\n                path.pop_back();  // delete the final \".\"\n                res.push_back(path);\n            }\n            return;\n        }\n\n        if (currSize == 4) return;\n\n        for (int i = startIndex, temp = 0; i &lt; s.length(); i++) {\n            if (i &gt; startIndex &amp;&amp; s[startIndex] == '0') break;\n            temp = temp * 10 + s[i] - '0';\n            if (temp &lt;= 255) // implicit backtracking\n                backtracking(s, i + 1, currSize + 1, path + to_string(temp) + '.');\n            else break;\n        }\n    }\npublic:\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        backtracking(s, 0, 0, \"\");\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time Complexity: In general, if there are \\(n\\) digits in total, the time complexity is \\(C_{n-1}^{3}\\). It can also be represented as \\(O(3^4\\times n)\\) in the worst case. This is because at each part of the IP address, a maximum of 3 characters can be considered (IP address parts range from 0 to 255), and there are 4 parts;</li> <li>Space Complexity: \\(O(4)\\) for the recursion stack, as the maximum depth of recursion is 4 (for the 4 parts of the IP address).</li> </ul>"},{"location":"Leetcode/0001-0099/0094-binary-tree-inorder-traversal/","title":"Binary Tree Inorder Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the inorder traversal of its nodes' values.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,null,2,3]</code></li> <li>Output: <code>[1,3,2]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#recursive-method","title":"Recursive Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void inOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        inOrder(node-&gt;left, res);\n        res.push_back(node-&gt;val);\n        inOrder(node-&gt;right, res);\n    }\n\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        inOrder(root, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#iterative-method","title":"Iterative Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        vector&lt;int&gt; res;\n        while (root || !stk.empty()) {\n            if (root) {\n                stk.push(root);\n                root = root-&gt;left;\n            } else {\n                auto t = stk.top();\n                stk.pop();\n                res.push_back(t-&gt;val);\n                root = t-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        // A stack to hold TreeNode pointers during traversal.\n        stack&lt;TreeNode*&gt; stk;\n\n        // A vector to store the traversal result.\n        vector&lt;int&gt; res;\n\n        // Continue until all nodes are processed.\n        while (root || !stk.empty()) {\n            if (root) {\n                // If the current node (root) is not null, push it onto the stack\n                // and move to its left child.\n                stk.push(root);\n                root = root-&gt;left;\n            } else {\n                // If the current node is null, it means we have reached the leftmost node.\n                // Pop the top node from the stack, process it, and move to its right child.\n                auto t = stk.top();\n                stk.pop();\n                res.push_back(t-&gt;val);  // Process the node.\n                root = t-&gt;right;        // Move to the right child.\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Steps:</p> <ol> <li>Initialize a Stack and Result Vector: The stack is used to track the nodes, and the result vector is for storing the values in the inorder sequence.</li> <li>Traversing the Tree:<ul> <li>The algorithm continues until all nodes are processed, indicated by both the current node being null and the stack being empty.</li> <li>If the current node (<code>root</code>) is not null, it is pushed onto the stack, and the algorithm moves to its left child. This step is repeated until the leftmost node is reached.</li> <li>If the current node is null, the algorithm backtracks by popping a node from the stack. This node's value is then added to the result vector, as it's the node being \"visited\" in the inorder sequence. The algorithm then proceeds to the right child of this node.</li> </ul> </li> <li>Inorder Sequence Completion: The process continues until the stack is empty, ensuring that all nodes are visited in the \"left, root, right\" sequence.</li> </ol> <p>Time Complexity Analysis:</p> <ul> <li>\\(O(n)\\): The time complexity is \\(O(n)\\) as each node in the tree is visited exactly once.</li> </ul> <p>Space Complexity Analysis:</p> <ul> <li>Best Case (Balanced Tree): \\(O(\\log n)\\), where \\(n\\) is the number of nodes. In a balanced tree, the stack's size will be proportional to the tree's height.</li> <li>Worst Case (Skewed Tree): \\(O(n)\\), in the case of a skewed tree, like a linked list, where the stack can potentially hold all the nodes.</li> <li>Average Case: Generally between \\(O(\\log n)\\) and \\(O(n)\\), depending on the tree's structure.</li> </ul>"},{"location":"Leetcode/0001-0099/0096-unique-binary-search-trees/","title":"Unique Binary Search Trees","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0096-unique-binary-search-trees/#description","title":"Description","text":"<p>Given an integer <code>n</code>, return the number of structurally unique BST's (binary search trees) which has exactly <code>n</code> nodes of unique values from <code>1</code> to <code>n</code>.</p> <p>Example 1:</p> <p></p> <ul> <li>Input: <code>n = 3</code></li> <li>Output: <code>5</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 1</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 19</code></li> </ul>"},{"location":"Leetcode/0001-0099/0096-unique-binary-search-trees/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0096-unique-binary-search-trees/#way-1-catalan-number","title":"Way 1 (Catalan Number)","text":"<pre><code>class Solution {\npublic:\n    int numTrees(int n) {\n        long long res = 1;\n        for (int i = n + 1; i &lt;= 2 * n; i++) {\n            res = res * i / (i - n);\n        }\n        return res / (n + 1);\n    }\n};\n</code></pre> <p>The \\(n\\)-th Catalan number is \\(\\frac{1}{n+1}C_{2n}^{n}\\).</p> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0096-unique-binary-search-trees/#way-2-dynamic-programming","title":"Way 2 (Dynamic Programming)","text":"<p>Define the <code>dp</code> array (<code>dp</code> table) and the meaning of its index:</p> <p><code>dp[i]</code>: The number of binary search trees composed of nodes <code>1</code> to <code>i</code> is <code>dp[i]</code>.</p> <p>It can also be understood as the number of binary search trees composed of <code>i</code> different element nodes is <code>dp[i]</code>, which is the same.</p> <p>Determine the recurrence relation:</p> <p>The recurrence relation can been observed: <code>dp[i] += dp[number of nodes in the left subtree with j as the root node] * dp[number of nodes in the right subtree with j as the root node]</code>.</p> <p><code>j</code> is equivalent to the element of the root node, iterating from <code>1</code> to <code>i</code>.</p> <p>So the recurrence formula is: <code>dp[i] += dp[j - 1] * dp[i - j]</code>; where <code>j-1</code> is the number of nodes in the left subtree with <code>j</code> as the root, and <code>i-j</code> is the number of nodes in the right subtree with <code>j</code> as the root.</p> <p>How to initialize the dp array:</p> <p>For initialization, only <code>dp[0]</code> needs to be initialized, which is the basis for derivation, all based on <code>dp[0]</code>.</p> <p>So, what should <code>dp[0]</code> be? From a definitional perspective, an empty node is also a binary tree, and it is also a binary search tree, which is reasonable.</p> <p>From the perspective of the recurrence formula, in <code>dp[number of nodes in the left subtree with j as the root node] * dp[number of nodes in the right subtree with j as the root node]</code>, if the number of nodes in the left subtree with <code>j</code> as the root node is <code>0</code>, then <code>dp[number of nodes in the left subtree with j as the root node] = 1</code> is needed, otherwise, the result of the multiplication would become <code>0</code>.</p> <p>Therefore, initialize <code>dp[0] = 1</code>.</p> <pre><code>class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[20] = {0};\n        dp[0] = 1;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= i; j++)\n                dp[i] += dp[j - 1] * dp[i - j];\n        }\n        return dp[n];\n    }\n};\n</code></pre> <p>Formally, let \\(f(n)\\) denotes the total number of binary search trees with \\(n\\) unique nodes. The left subtree can have \\(0,1,\\cdots ,n-2,n-1\\) nodes, and the corresponding right subtree can have \\(n-1, n-2,\\cdots ,1,0\\) nodes. Therefore:</p> \\[ f\\left( n \\right) =\\sum_{k=0}^{n-1}{f\\left( k \\right) \\cdot f\\left( n-1-k \\right)} \\] <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/","title":"Validate Binary Search Tree","text":"<p>Link</p>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, determine if it is a valid binary search tree (BST).</p> <p>A valid BST is defined as follows:</p> <ul> <li>The left subtree of a node contains only nodes with keys less than the node's key.</li> <li>The right subtree of a node contains only nodes with keys greater than the node's key.</li> <li>Both the left and right subtrees must also be binary search trees.</li> </ul> <p>(A subtree of <code>treeName</code> is a tree consisting of a node in treeName and all of its descendants.)</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [2,1,3]</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [5,1,4,null,null,3,6]</code></li> <li>Output: <code>false</code></li> <li>Explanation: The root node's value is <code>5</code> but its right child's value is <code>4</code>.</li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 10^4]</code>.</li> <li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li> </ul>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    vector&lt;int&gt; inorder = {};\n    void traversal(TreeNode* root) {\n        if (!root) return;\n        traversal(root-&gt;left);\n        inorder.push_back(root-&gt;val);\n        traversal(root-&gt;right);\n    }\npublic:\n    bool isValidBST(TreeNode* root) {\n        traversal(root);\n        for (int i = 1; i &lt; inorder.size(); i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n};\n</code></pre> <p>Idea and Algorithm:</p> <ul> <li>The idea behind this approach is based on the property of BSTs: an in-order traversal of a BST produces a sorted list of values in ascending order.</li> <li>The <code>traversal</code> function recursively visits all nodes in the tree in in-order fashion (left, root, right) and adds their values to the <code>inorder</code> vector.</li> <li>After the traversal, the <code>isValidBST</code> function checks if the <code>inorder</code> vector is sorted in strictly ascending order. If not, the tree is not a valid BST.</li> </ul> <p>Complexity:</p> <ul> <li>Time Complexity: The time complexity is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because each node is visited exactly once to build the <code>inorder</code> vector, and then we iterate through the vector once to check if it is sorted.</li> <li>Space Complexity: The space complexity is \\(O(N)\\), mainly due to the space used by the <code>inorder</code> vector, which can potentially hold all \\(N\\) node values in the tree. Additionally, the space complexity of the recursion stack in the worst case (a skewed tree) can be \\(O(N)\\). In the best case (a balanced tree), it would be \\(O(\\log N)\\), but the dominant factor is the space for the <code>inorder</code> vector.</li> </ul>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#way-2","title":"Way 2","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    // The traversal function checks if the subtree rooted at 'node' is a valid BST.\n    bool traversal(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\n        // Base case: An empty node is always a valid BST.\n        if (!node) return true;\n\n        // Check if the current node's value violates the BST properties.\n        // If 'minNode' is not null and the current node's value is not greater than 'minNode',\n        // then it's not a valid BST.\n        if (minNode &amp;&amp; node-&gt;val &lt;= minNode-&gt;val) return false;\n\n        // Similarly, if 'maxNode' is not null and the current node's value is not less than 'maxNode',\n        // then it's not a valid BST.\n        if (maxNode &amp;&amp; node-&gt;val &gt;= maxNode-&gt;val) return false;\n\n        // Recursively check the left and right subtrees, updating the constraints.\n        // For the left subtree, the current node becomes the new 'maxNode', and\n        // for the right subtree, it becomes the new 'minNode'.\n        return traversal(node-&gt;left, minNode, node) &amp;&amp; traversal(node-&gt;right, node, maxNode);\n    }\npublic:\n    // Public interface to start the BST validation from the root.\n    bool isValidBST(TreeNode* root) {\n        // Initiate the traversal with null pointers for minNode and maxNode,\n        // as the root has no constraints initially.\n        return traversal(root, nullptr, nullptr);\n    }\n};\n</code></pre> <ul> <li>Time Complexity: The time complexity is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because we visit each node exactly once during the traversal.</li> <li>Space Complexity: The space complexity is \\(O(H)\\), where \\(H\\) is the height of the tree. This is due to the recursive stack used for DFS. In the worst case (a skewed tree), the height of the tree can be \\(O(N)\\), leading to \\(O(N)\\) space complexity. In the best case (a balanced tree), it would be \\(O(\\log N)\\).</li> </ul>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#way-3","title":"Way 3","text":"<pre><code>class Solution {\nprivate:\n    TreeNode *pre = nullptr;  // Pointer to keep track of the previously visited node in in-order traversal.\n\npublic:\n    bool isValidBST(TreeNode* root) {\n        if (!root) return true;  // Base case: An empty tree is a valid BST.\n\n        // Recursively check the left subtree.\n        bool l = isValidBST(root-&gt;left);\n\n        // Check if the current node's value is greater than the previous node's value.\n        if (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;\n        pre = root;  // Update 'pre' to the current node.\n\n        // Recursively check the right subtree.\n        bool r = isValidBST(root-&gt;right);\n\n        // The tree is a valid BST if both left and right subtrees are valid BSTs.\n        return l &amp;&amp; r;\n    }\n};\n</code></pre> <p>Idea and Algorithm:</p> <ul> <li>Similar to an in-order traversal, this approach visits nodes in a left-root-right order.</li> <li>The difference lies in how it uses the <code>pre</code> pointer to remember the last node visited (in the in-order sequence).</li> <li>When visiting each node, it checks if its value is greater than the value of the <code>pre</code> node. If not, the BST property is violated, and it returns <code>false</code>.</li> <li>After checking, it updates <code>pre</code> to the current node and then proceeds to the right subtree.</li> <li>Finally, the tree is a valid BST if both the left and right subtree checks return <code>true</code>.</li> </ul> <p>Complexity:</p> <ul> <li>Time Complexity: The time complexity is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. Despite the recursive calls, each node is visited exactly once.</li> <li>Space Complexity: The space complexity is \\(O(H)\\), where \\(H\\) is the height of the tree. This space is used by the recursion stack. In the worst case (a skewed tree), \\(H\\) can be \\(O(N)\\). In a balanced tree, \\(H\\) would be \\(O(\\log N)\\). The <code>pre</code> pointer does not add significant space complexity, as it's just a single additional pointer.</li> </ul>"},{"location":"Leetcode/0001-0099/0098-validate-binary-search-tree/#way-4-iterative-solution","title":"Way 4 (Iterative Solution)","text":"<pre><code>class Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        TreeNode* curr = root;\n        TreeNode* pre = nullptr;\n        while (curr || !stk.empty()) {\n            if (curr) {\n                stk.push(curr);\n                curr = curr-&gt;left;\n            } else {\n                TreeNode *t = stk.top();\n                stk.pop();\n                if (pre &amp;&amp; t-&gt;val &lt;= pre-&gt;val) return false;\n                pre = t;\n                curr = t-&gt;right;\n            }\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0100-same-tree/","title":"Same Tree","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0100-same-tree/#description","title":"Description","text":"<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p> <p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p> <p>Example 1:</p> <ul> <li>Input: <code>p = [1,2,3], q = [1,2,3]</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>p = [1,2], q = [1,null,2]</code></li> <li>Output: <code>false</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>p = [1,2,1], q = [1,1,2]</code></li> <li>Output: <code>false</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li> <li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0100-0199/0100-same-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0100-same-tree/#iterative-method","title":"Iterative Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        // Base case: if both trees are null, they are identical\n        if (!p &amp;&amp; !q) return true;\n        // If only one tree is null or the values are different, they are not identical\n        if (!p || !q || p-&gt;val != q-&gt;val) return false;\n        // Recursively check if the left and right subtrees are identical\n        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O\\left( \\min \\left( n,m \\right) \\right)\\), where \\(n\\) and \\(m\\) are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be \\(O(n)\\);</li> <li>Space complexity: \\(O\\left( \\min \\left( h_1,h_2 \\right) \\right)\\), where \\(h_1\\) and \\(h_2\\) are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to \\(O(n)\\) or \\(O(m)\\), depending on which tree is larger.</li> </ul>"},{"location":"Leetcode/0100-0199/0100-same-tree/#tree-hashing","title":"Tree Hashing","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    string computeHash(TreeNode* node) {\n        if (!node) return \"NULL\";\n        string leftHash = computeHash(node-&gt;left);\n        string rightHash = computeHash(node-&gt;right);\n        return \"(\" + to_string(node-&gt;val) + leftHash + rightHash + \")\";\n    }\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        return computeHash(p) == computeHash(q);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0101-symmetric-tree/","title":"Symmetric Tree","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,2,2,3,4,4,3]</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,2,2,null,3,null,3]</code></li> <li>Output: <code>false</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#recursive-solution-post-order","title":"Recursive Solution (Post-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool compare(TreeNode* lNode, TreeNode* rNode) {\n        if (!lNode &amp;&amp; !rNode) return true;\n        if (!lNode || !rNode || lNode-&gt;val != rNode-&gt;val) return false;\n        return compare(lNode-&gt;left, rNode-&gt;right) &amp;&amp; compare(lNode-&gt;right, rNode-&gt;left);\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if (!root) return true;\n        return compare(root-&gt;left, root-&gt;right);\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    // A helper function to compare two nodes.\n    bool compare(TreeNode* lNode, TreeNode* rNode) {\n        // If both nodes are null, they are symmetric.\n        if (!lNode &amp;&amp; !rNode) return true;\n\n        // If one of the nodes is null or their values are not equal, they are not symmetric.\n        if (!lNode || !rNode || lNode-&gt;val != rNode-&gt;val) return false;\n\n        // Recursively compare the left child of lNode with the right child of rNode\n        // and the right child of lNode with the left child of rNode.\n        return compare(lNode-&gt;left, rNode-&gt;right) &amp;&amp; compare(lNode-&gt;right, rNode-&gt;left);\n    }\n\n    // Main function to check if the tree is symmetric.\n    bool isSymmetric(TreeNode* root) {\n        // An empty tree is symmetric. (optional)\n        if (!root) return true;\n\n        // Check if the left subtree and right subtree are symmetric.\n        return compare(root-&gt;left, root-&gt;right);\n    }\n};\n</code></pre> <p>Algorithm Idea and Steps:</p> <ol> <li>Symmetry Definition: A tree is symmetric if the left subtree is a mirror reflection of the right subtree. This means each node's left child in the left subtree must be equal to the right child of the corresponding node in the right subtree, and vice versa.</li> <li>Recursive Approach: The <code>compare</code> function is a recursive function that takes two nodes (<code>lNode</code> and <code>rNode</code>) as arguments and checks whether they are mirror images of each other.</li> <li>Base Cases:<ul> <li>If both nodes are null, they are symmetric (mirror images of each other).</li> <li>If one is null and the other is not, or their values are different, they are not symmetric.</li> </ul> </li> <li>Recursive Calls:<ul> <li>The function recursively checks two pairs of nodes:<ul> <li>The left child of <code>lNode</code> and the right child of <code>rNode</code>.</li> <li>The right child of <code>lNode</code> and the left child of <code>rNode</code>.</li> </ul> </li> </ul> </li> <li>Starting the Check: The <code>isSymmetric</code> function starts the process by calling <code>compare</code> with the left and right children of the root.</li> </ol> <p>Complexity Analysis:</p> <ul> <li>Time Complexity: \\(O(n)\\), where \\(n\\) is the number of nodes in the tree. Each node in the tree is visited once;</li> <li>Space Complexity: \\(O(h)\\), where \\(h\\) is the height of the tree. This is due to the recursive stack. In the worst case (a skewed tree), this can become \\(O(n)\\), but in the best case (a balanced tree), it's \\(O(\\log n)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#iterative-solution","title":"Iterative Solution","text":""},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#using-stack","title":"Using Stack","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (!root) return true;\n\n        stack&lt;TreeNode*&gt; stk;\n        stk.push(root-&gt;left);\n        stk.push(root-&gt;right);\n\n        while (!stk.empty()) {\n            TreeNode *leftNode = stk.top(); stk.pop();\n            TreeNode *rightNode = stk.top(); stk.pop();\n\n            if (!leftNode &amp;&amp; !rightNode) continue;\n            if (!leftNode || !rightNode || leftNode-&gt;val != rightNode-&gt;val) return false;\n\n            stk.push(leftNode-&gt;left);\n            stk.push(rightNode-&gt;right);\n            stk.push(leftNode-&gt;right);\n            stk.push(rightNode-&gt;left);\n        }\n        return true;\n    }\n};\n</code></pre> <p>Algorithm Idea and Steps:</p> <ol> <li>Initialization: Start by pushing the left and right children of the root onto the stack.</li> <li>Iterative Process:<ul> <li>Pop two nodes from the stack and compare them.</li> <li>If both are null, continue to the next iteration (they are symmetric in this case).</li> <li>If only one is null or their values are different, return false (tree is not symmetric).</li> </ul> </li> <li>Mirrored Order Insertion:<ul> <li>For each pair of nodes, push their children onto the stack in a mirrored order: left child of the first node with the right child of the second node, and right child of the first node with the left child of the second node.</li> </ul> </li> <li>Completion: If the stack becomes empty and no asymmetry is found, the tree is symmetric.</li> </ol> <p>Complexity Analysis:</p> <p>Time Complexity:</p> <ul> <li>\\(O(n)\\): Each node is visited exactly once.</li> </ul> <p>Space Complexity:</p> <ul> <li>\\(O(n)\\) in the worst case: The stack might hold all the nodes at the tree's breadth at its maximum level, which can be up to \\(\\frac{n}{2}\\) nodes in a complete binary tree.</li> <li>\\(O(\\log n)\\) in the best case for a balanced tree: The stack will hold at most a number of nodes proportional to the height of the tree.</li> </ul>"},{"location":"Leetcode/0100-0199/0101-symmetric-tree/#using-queue","title":"Using Queue","text":"<pre><code>class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (!root) return true;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root-&gt;left);\n        q.push(root-&gt;right);\n        while (!q.empty()) {\n            TreeNode *leftNode = q.front(); q.pop();\n            TreeNode *rightNode = q.front(); q.pop();\n            if (!leftNode &amp;&amp; !rightNode) continue;\n            if (!leftNode || !rightNode || leftNode-&gt;val != rightNode-&gt;val) return false;\n            q.push(leftNode-&gt;left);\n            q.push(rightNode-&gt;right);\n            q.push(leftNode-&gt;right);\n            q.push(rightNode-&gt;left);\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0102-binary-tree-level-order-traversal/","title":"Binary Tree Level Order Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0102-binary-tree-level-order-traversal/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [3,9,20,null,null,15,7]</code></li> <li>Output: <code>[[3],[9,20],[15,7]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>[[1]]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0100-0199/0102-binary-tree-level-order-traversal/#solution","title":"Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        queue&lt;TreeNode*&gt; q;\n        if (root) q.push(root);\n\n        while (!q.empty()) {\n            int len = q.size();\n            vector&lt;int&gt; level;\n\n            while (len--) {\n                auto t = q.front();\n                q.pop();\n                level.push_back(t-&gt;val);\n                if (t-&gt;left) q.push(t-&gt;left);\n                if (t-&gt;right) q.push(t-&gt;right);\n            }\n\n            res.push_back(level);\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; res; // To store the final result\n        queue&lt;TreeNode*&gt; q; // Queue to help in BFS\n\n        // Check if the root is not null\n        if (root) q.push(root);\n\n        // Loop until the queue is empty\n        while (!q.empty()) {\n            int len = q.size(); // Current level size\n            vector&lt;int&gt; level; // To store nodes at the current level\n\n            // Process nodes of the current level\n            while (len--) {\n                auto t = q.front(); // Get the front node in the queue\n                q.pop(); // Remove the node from the queue\n                level.push_back(t-&gt;val); // Add the node's value to the current level\n\n                // Add child nodes to the queue for next level\n                if (t-&gt;left) q.push(t-&gt;left);\n                if (t-&gt;right) q.push(t-&gt;right);\n            }\n\n            // Add the current level to the final result\n            res.push_back(level);\n        }\n        return res; // Return the final result\n    }\n};\n</code></pre> <p>Algorithm Analysis:</p> <ol> <li>Initialize Data Structures:<ul> <li>Create an empty queue (<code>q</code>) that will be used to store the nodes of the tree at each level.</li> <li>Create an empty list (<code>res</code>) that will eventually hold the level order traversal result. This list will contain sublists, each representing one level of the tree.</li> </ul> </li> <li>Start with the Root Node:<ul> <li>If the root node of the tree is not <code>nullptr</code>, add it to the queue. This step initiates the process of level order traversal.</li> </ul> </li> <li>Traverse the Tree Level by Level:<ul> <li>While the queue is not empty, perform the following steps. Each iteration of this loop corresponds to processing one level of the tree:<ul> <li>Determine the number of nodes at the current level. This is given by the current size of the queue (<code>int len = q.size()</code>).</li> <li>Create an empty list (<code>level</code>) that will store the values of the nodes at this current level.</li> </ul> </li> </ul> </li> <li>Process Nodes at the Current Level:<ul> <li>Repeat the following steps <code>len</code> times (the number of nodes at the current level):<ul> <li>Remove the front node from the queue and refer to it as <code>t</code>.</li> <li>Add the value of <code>t</code> to the <code>level</code> list.</li> <li>If <code>t</code> has a left child, add the left child to the queue.</li> <li>If <code>t</code> has a right child, add the right child to the queue.</li> </ul> </li> <li>After processing all nodes at the current level, add the <code>level</code> list to the <code>res</code> list.</li> </ul> </li> <li>Repeat for All Levels:<ul> <li>The while loop continues until the queue is empty. When the queue is empty, it means that all levels of the tree have been processed.</li> </ul> </li> <li>Return the Result:<ul> <li>After the while loop completes, <code>res</code> contains the level order traversal of the tree, and is returned as the result.</li> </ul> </li> </ol> <p>Complexity Analysis:</p> <ul> <li>Time Complexity: The time complexity of this algorithm is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because every node in the tree is processed exactly once.</li> <li>Space Complexity: The space complexity of this algorithm is \\(O(N)\\) as well, in the worst case when the tree is completely unbalanced (e.g., every node has only one child), the queue will hold all nodes. For a balanced tree, the maximum size of the queue will be proportional to the width of the tree, which can be \\(O(N)\\) in the worst case.</li> </ul>"},{"location":"Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/","title":"Maximum Depth of Binary Tree","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return its maximum depth.</p> <p>A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [3,9,20,null,null,15,7]</code></li> <li>Output: <code>3</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,null,2]</code></li> <li>Output: <code>2</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 10^4]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#recursive-solution","title":"Recursive Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#iterative-solution-level-order","title":"Iterative Solution (Level-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        int depth = 0;\n\n        while (!q.empty()) {\n            int len = q.size();\n            depth++;\n            while (len--) {\n                auto curr = q.front();\n                q.pop();\n                if (curr-&gt;left) q.push(curr-&gt;left);\n                if (curr-&gt;right) q.push(curr-&gt;right);\n            }\n        }\n        return depth;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/","title":"Construct Binary Tree from Preorder and Inorder Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#description","title":"Description","text":"<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.</p> <p>Example 1:</p> <ul> <li>Input: <code>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</code></li> <li>Output: <code>[3,9,20,null,null,15,7]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>preorder = [-1], inorder = [-1]</code></li> <li>Output: <code>[-1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= preorder.length &lt;= 3000</code></li> <li><code>inorder.length == preorder.length</code></li> <li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li> <li><code>preorder</code> and <code>inorder</code> consist of unique values.</li> <li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li> <li><code>preorder</code> is guaranteed to be the preorder traversal of the tree.</li> <li><code>inorder</code> is guaranteed to be the inorder traversal of the tree.</li> </ul>"},{"location":"Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#solution","title":"Solution","text":"<ol> <li>First, use pre-order traversal to find the root node: the first number in the pre-order traversal is the value of the root node;</li> <li>Find the position of the root node in the in-order traversal, <code>pos</code>. Then, the left side of <code>pos</code> is the in-order traversal of the left subtree, and the right side is the in-order traversal of the right subtree;</li> <li>Assume that the length of the in-order traversal of the left subtree is <code>index</code>. Then, in the pre-order traversal, the <code>index</code> numbers following the root node are the pre-order traversal of the left subtree, and the remaining numbers are the pre-order traversal of the right subtree;</li> <li>With the pre-order and in-order traversals of the left and right subtrees, we can first recursively create the root node, then recursively create the left and right subtrees, and finally attach these two subtrees to the left and right positions of the root node.</li> </ol> <p>Illustration:</p> <pre><code>preorder: |      |------------------------|                   |-------------------------|\n         preL  preL+1         (preL+1)+(index-1-inL)  (preL+1)+(index-1-inL)+1         preR\n\n\ninorder:  |------------------------|           |              |-------------------------|\n         inL                     index-1     index         index+1                     inR\n</code></pre> <p>Code:</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    unordered_map&lt;int, int&gt; pos;\n    TreeNode* treeBuilder(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preorderLeft, int preorderRight, int inorderLeft, int inorderRight) {\n        if (preorderLeft &gt; preorderRight) return nullptr;\n        auto root = new TreeNode(preorder[preorderLeft]);\n        int index = pos[root-&gt;val];\n        root-&gt;left = treeBuilder(preorder, inorder, \n            preorderLeft + 1, preorderLeft + 1 + index - 1 - inorderLeft, \n            inorderLeft, index - 1);\n        root-&gt;right = treeBuilder(preorder, inorder, \n            preorderLeft + 1 + index - 1 - inorderLeft + 1, preorderRight, \n            index + 1, inorderRight);\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        int treeSize = inorder.size();\n        for (int i = 0; i &lt; treeSize; i++) pos[inorder[i]] = i;\n        return treeBuilder(preorder, inorder, 0, treeSize - 1, 0, treeSize - 1);\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\nprivate:\n    // A hash map to store the position of each value in the inorder traversal.\n    unordered_map&lt;int, int&gt; pos;\n\n    // Helper function to build the tree.\n    TreeNode* treeBuilder(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, \n                          int preorderLeft, int preorderRight, \n                          int inorderLeft, int inorderRight) {\n        // Base case: if the current subtree is empty.\n        if (preorderLeft &gt; preorderRight) return nullptr;\n\n        // The first element in preorder traversal is the root of the subtree.\n        auto root = new TreeNode(preorder[preorderLeft]);\n\n        // Find the position of the root in inorder traversal.\n        int index = pos[root-&gt;val];\n\n        // Recursively construct the left subtree.\n        root-&gt;left = treeBuilder(preorder, inorder, \n                                 preorderLeft + 1, preorderLeft + index - inorderLeft, \n                                 inorderLeft, index - 1);\n\n        // Recursively construct the right subtree.\n        root-&gt;right = treeBuilder(preorder, inorder, \n                                  preorderLeft + index - inorderLeft + 1, preorderRight, \n                                  index + 1, inorderRight);\n\n        return root;\n    }\n\npublic:\n    // Public function to be called to build the tree.\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        int treeSize = inorder.size();\n        // Fill the hash map with elements from the inorder traversal.\n        for (int i = 0; i &lt; treeSize; i++) pos[inorder[i]] = i;\n        // Start the tree construction process.\n        return treeBuilder(preorder, inorder, 0, treeSize - 1, 0, treeSize - 1);\n    }\n};\n</code></pre> <p>Explanation of Algorithm:</p> <p>The algorithm uses recursion to construct the binary tree. It leverages the property that the first element of a preorder traversal is always the root of the tree, and then finds this root's index in the inorder traversal to divide the tree into left and right subtrees.</p> <ol> <li>Initializing Hash Map: The <code>unordered_map</code> named <code>pos</code> maps each value in the inorder traversal to its index. This speeds up the search operation which is required to find the root node in the inorder sequence.</li> <li>Recursive Tree Construction: The <code>treeBuilder</code> function is the core of the algorithm. It takes the current interval of preorder and inorder traversals to construct the tree. The first element of the current preorder interval is the root. The function then finds this root in the inorder interval, which divides the tree into left and right subtrees. The left and right child nodes are then recursively constructed.</li> <li>Interval Changes in Recursion: The preorder and inorder intervals are updated in each recursive call to reflect the current subtree being constructed. The index found in the inorder traversal helps in determining the size of the left and right subtrees, which is then used to update the intervals.</li> </ol> <p>Time and Space Complexity Analysis:</p> <ul> <li>Time Complexity: \\(O(n)\\)<ul> <li>The hash map reduces the search operation for the root in the inorder traversal to \\(O(1)\\).</li> <li>Each node is visited exactly once, leading to a linear time complexity.</li> </ul> </li> <li>Space Complexity: \\(O(n)\\)<ul> <li>The space for the hash map, which contains n elements.</li> <li>The recursive stack space, which, in the worst case, can go up to \\(O(n)\\) in the case of a skewed tree.</li> </ul> </li> </ul> <p>Additional Notes:</p> <p>Constructing the Left Subtree:</p> <pre><code>root-&gt;left = treeBuilder(preorder, inorder, \n                         preorderLeft + 1, preorderLeft + index - inorderLeft, \n                         inorderLeft, index - 1);\n</code></pre> <p>In this line, the algorithm is constructing the left subtree of the current root node. Here's how it works:</p> <ol> <li>Finding the Root of the Left Subtree:<ul> <li><code>preorderLeft + 1</code>: The left child of the current root in the preorder sequence is always the next element (<code>preorderLeft + 1</code>).</li> </ul> </li> <li>Determining the Bounds of the Left Subtree:<ul> <li><code>preorderLeft + index - inorderLeft</code>: This expression calculates the right bound of the left subtree in the preorder sequence. </li> <li><code>index</code> is the position of the current root in the inorder sequence. </li> <li><code>inorderLeft</code> is the left bound of the inorder sequence for the current subtree.</li> <li>The difference <code>index - inorderLeft</code> gives the size of the left subtree. Adding this to <code>preorderLeft</code> (and adjusting by 1 for the root) sets the right boundary in the preorder sequence.</li> </ul> </li> <li>Setting the Inorder Interval:<ul> <li><code>inorderLeft, index - 1</code>: In the inorder sequence, the left subtree is always to the left of the root. So, the left subtree spans from <code>inorderLeft</code> to <code>index - 1</code> (one element before the root).</li> </ul> </li> </ol> <p>Constructing the Right Subtree:</p> <pre><code>root-&gt;right = treeBuilder(preorder, inorder, \n                          preorderLeft + index - inorderLeft + 1, preorderRight, \n                          index + 1, inorderRight);\n</code></pre> <p>In this line, the algorithm constructs the right subtree:</p> <ol> <li>Finding the Root of the Right Subtree:<ul> <li><code>preorderLeft + index - inorderLeft + 1</code>: This expression finds the starting point of the right subtree in the preorder sequence. The logic is similar to the left subtree, but it includes an additional <code>+1</code> to skip over the entire left subtree.</li> </ul> </li> <li>Determining the Bounds of the Right Subtree:<ul> <li><code>preorderRight</code>: The right boundary in the preorder sequence remains the same as the parent's right boundary, as we are now dealing with the right subtree.</li> </ul> </li> <li>Setting the Inorder Interval:<ul> <li><code>index + 1, inorderRight</code>: In the inorder sequence, the right subtree is always to the right of the root. Therefore, the interval for the right subtree starts from <code>index + 1</code> (one element after the root) to <code>inorderRight</code>.</li> </ul> </li> </ol>"},{"location":"Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/","title":"Construct Binary Tree from Inorder and Postorder Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#description","title":"Description","text":"<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return the binary tree.</p> <p>Example 1:</p> <ul> <li>Input: <code>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</code></li> <li>Output: <code>[3,9,20,null,null,15,7]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>inorder = [-1], postorder = [-1]</code></li> <li>Output: <code>[-1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= inorder.length &lt;= 3000</code></li> <li><code>postorder.length == inorder.length</code></li> <li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li> <li><code>inorder</code> and <code>postorder</code> consist of unique values.</li> <li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li> <li><code>inorder</code> is guaranteed to be the inorder traversal of the tree.</li> <li><code>postorder</code> is guaranteed to be the postorder traversal of the tree.</li> </ul>"},{"location":"Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/","title":"Balanced Binary Tree","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/#description","title":"Description","text":"<p>Given a binary tree, determine if it is height-balanced.</p> <p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [3,9,20,null,null,15,7]</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,2,2,3,3,null,null,4,4]</code></li> <li>Output: <code>false</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>true</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li> <li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int depth(TreeNode* node) {\n        if (!node) return 0;\n        return max(depth(node-&gt;left), depth(node-&gt;right)) + 1;\n    }\npublic:\n    bool isBalanced(TreeNode* root) {\n        if (!root) return true;\n        return (abs(depth(root-&gt;left) - depth(root-&gt;right)) &lt;= 1) &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N\\log N)\\);</li> <li>Space complexity: \\(O(N)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/#way-2","title":"Way 2","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool ans;\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n        int lDepth = dfs(root-&gt;left), rDepth = dfs(root-&gt;right);\n        if (abs(lDepth - rDepth) &gt; 1) ans = false;\n        return max(lDepth, rDepth) + 1;\n    }\n    bool isBalanced(TreeNode* root) {\n        ans = true;\n        dfs(root);\n        return ans;\n    }\n};\n</code></pre> <p>Analysis:</p> <p>Depth Calculation and Balance Check (<code>dfs</code> Function):</p> <ul> <li>Functionality: The <code>dfs</code> function calculates the depth of the tree and simultaneously checks if the tree is balanced.</li> <li>Implementation:<ul> <li>If the current node is null, it returns 0 (base case of recursion).</li> <li>It recursively calculates the depth of the left (<code>lDepth</code>) and right (<code>rDepth</code>) subtrees.</li> <li>The balance condition is checked by comparing the absolute difference between <code>lDepth</code> and <code>rDepth</code>. If this difference is greater than 1 at any node, <code>ans</code> is set to <code>false</code>, indicating that the tree is not balanced.</li> <li>The function returns the maximum depth of either subtree plus 1 (to include the current node).</li> </ul> </li> </ul> <p>Overall Check (<code>isBalanced</code> Function):</p> <ul> <li>Functionality: This function initiates the DFS and returns the final answer.</li> <li>Implementation:<ul> <li>It initializes <code>ans</code> to <code>true</code>.</li> <li>It calls <code>dfs(root)</code> to perform the depth calculation and balance check.</li> <li>It returns the value of <code>ans</code>, which indicates whether the tree is balanced.</li> </ul> </li> </ul> <p>Complexity:</p> <ul> <li>Time Complexity: \\(O(N)\\), as each node is visited only once.</li> <li>Space Complexity: \\(O(N)\\) due to the recursion stack. In a skewed tree, the recursion depth could be as deep as the tree.</li> </ul>"},{"location":"Leetcode/0100-0199/0110-balanced-binary-tree/#way-3-post-order","title":"Way 3 (Post-order)","text":"<p>We use post-order traversal and pruning (bottom to top).</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int height(TreeNode* node) {\n        if (!node) return 0;\n        int lHeight = height(node-&gt;left);\n        if (lHeight == -1) return -1;\n        int rHeight = height(node-&gt;right);\n        if (rHeight == -1) return -1;\n        return (abs(lHeight - rHeight) &lt;= 1) ? (max(lHeight, rHeight) + 1) : -1;\n    }\npublic:\n    bool isBalanced(TreeNode* root) {\n        return height(root) != -1;\n    }\n};\n</code></pre> <p>How the Recursion is Performed:</p> <ul> <li>The recursion starts from the root.</li> <li>For each node, it first computes the height of its left subtree, then its right subtree.</li> <li>If either subtree is unbalanced (indicated by <code>-1</code>), the function returns <code>-1</code> immediately without further computations.</li> <li>The height of a node is the maximum height of its two subtrees plus one. If the difference in heights is more than one, it returns <code>-1</code>.</li> </ul> <p>Code with comments:</p> <pre><code>class Solution {\nprivate:\n    // Helper function to calculate the height of a tree rooted at 'node'.\n    int height(TreeNode* node) {\n        // Base case: An empty tree has a height of 0.\n        if (!node) return 0;\n\n        // Recursively calculate the height of the left subtree.\n        int lHeight = height(node-&gt;left);\n        // If the left subtree is unbalanced, propagate the -1 flag upwards.\n        if (lHeight == -1) return -1;\n\n        // Recursively calculate the height of the right subtree.\n        int rHeight = height(node-&gt;right);\n        // If the right subtree is unbalanced, propagate the -1 flag upwards.\n        if (rHeight == -1) return -1;\n\n        // Check if the current node is balanced.\n        // If balanced, return the height of the tree rooted at this node.\n        // If not balanced, return -1 as a flag.\n        return (abs(lHeight - rHeight) &lt;= 1) ? (max(lHeight, rHeight) + 1) : -1;\n    }\n\npublic:\n    // Public function to check if the tree is balanced.\n    bool isBalanced(TreeNode* root) {\n        // A non-negative value indicates the tree is balanced.\n        return height(root) != -1;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>This approach optimizes the process of checking tree balance by integrating the balance check directly into the height calculation.</li> <li>If at any point the tree is found to be unbalanced (i.e., the difference in height between the left and right subtrees of any node is greater than 1), the function immediately returns -1.</li> <li>This early termination prevents unnecessary calculations once an imbalance is detected.</li> </ul> <p>Complexity:</p> <ul> <li>Time Complexity: \\(O(n)\\), each node in the tree is visited once. For each node, the algorithm performs a constant amount of work aside from the recursive function calls;</li> <li>Space Complexity: \\(O(h)\\), where \\(h\\) is the height of the tree. This space is used by the call stack due to recursion. In the worst case (a skewed tree), the space complexity can become \\(O(n)\\), but for a balanced tree, it's typically \\(O(\\log n)\\).</li> </ul> <p>Comparison:</p> <ul> <li>Compared to the First Solution: The first solution separately calculated the depth for each node and then checked for balance, leading to a less efficient time complexity. In contrast, this solution combines these steps and uses early termination for efficiency, bringing the complexity down to \\(O(N)\\).</li> <li>Compared to the Second Solution: The second solution also combined the height calculation and balance check in one pass but did not use early termination. This current solution improves upon that by immediately stopping further height calculations once an imbalance is detected, which can potentially reduce the number of recursive calls in certain scenarios.</li> </ul>"},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/","title":"Minimum Depth of Binary Tree","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#description","title":"Description","text":"<p>Given a binary tree, find its minimum depth.</p> <p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p> <p>Note: A leaf is a node with no children.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [3,9,20,null,null,15,7]</code></li> <li>Output: <code>2</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [2,null,3,null,4,null,5,null,6]</code></li> <li>Output: <code>5</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 10^5]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#recursive-solution","title":"Recursive Solution","text":""},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#way-1","title":"Way 1","text":"<p>The recursion is based on the following ideas:</p> <ol> <li>Base Case: If the current node (<code>root</code>) is <code>nullptr</code>, it means we've reached beyond a leaf node, and we return 0. This case handles an empty tree or reaching the end of a branch.</li> <li>Only Right Child Exists: If the current node has no left child but has a right child, we recursively find the minimum depth of the right subtree and add 1 (for the current node).</li> <li>Only Left Child Exists: If the current node has a left child but no right child, we similarly find the minimum depth of the left subtree and add 1.</li> <li>Both Children Exist: If both children exist, we find the minimum depth of both subtrees and take the minimum of these two values, then add 1.</li> </ol> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root) return 0;\n        if (!root-&gt;left &amp;&amp; root-&gt;right) return 1 + minDepth(root-&gt;right);\n        if (root-&gt;left &amp;&amp; !root-&gt;right) return 1 + minDepth(root-&gt;left);\n        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));\n    }\n};\n</code></pre> <p>Recursive Cases Explained:</p> <ul> <li>Case 1: No Children (Leaf Node): If a node is a leaf (no children), the recursion ends, and it returns 1 (the depth of a leaf node is 1).</li> <li>Case 2: One Child: If a node has only one child, the algorithm only considers the subtree with the child. It ignores the null side as it's not a valid path to a leaf.</li> <li>Case 3: Two Children: If a node has two children, it compares the depth of both subtrees and takes the smaller one. This ensures we are finding the minimum path to a leaf.</li> </ul> <p>Complexity Analysis:</p> <ul> <li>Time Complexity: The time complexity of this algorithm is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because, in the worst case, the algorithm needs to visit every node once to determine the minimum depth;</li> <li>Space Complexity: The space complexity is \\(O(H)\\), where \\(H\\) is the height of the tree. This is due to the recursive stack. In the worst case (a skewed tree), the space complexity can be \\(O(N)\\), but for a balanced tree, it's \\(O(\\log N)\\).</li> </ul> <p>Additional Insights:</p> <ul> <li>Tail Recursion: This is not a tail-recursive solution because the recursive call is not the last operation in the function (there is an addition after it).</li> <li>Efficiency: The solution is efficient as it avoids unnecessary computation by stopping as soon as it finds a leaf node and also handles cases where a node has only one child.</li> <li>Improvement: In some cases, iterative solutions (like BFS) might be more efficient, especially for finding the minimum depth, as they can stop early once the first leaf is reached.</li> </ul>"},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#way-2","title":"Way 2","text":"<p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root) return 0;\n        int res = INT_MAX;\n        if (root-&gt;left) res = min(res, minDepth(root-&gt;left) + 1);\n        if (root-&gt;right) res = min(res, minDepth(root-&gt;right) + 1);\n        if (res == INT_MAX) res = 1;\n        return res;\n    }\n};\n</code></pre> <p>Analysis:</p> <ol> <li>Base Case: If the <code>root</code> is <code>nullptr</code>, the function returns 0, indicating that there is no tree or it has reached the end of a branch.</li> <li>Initialize <code>res</code>: The variable <code>res</code> is initialized to <code>INT_MAX</code>, which represents a very high value. This is a common approach in minimum computation problems to ensure that any real result found will be less than this initial value.</li> <li>Left Subtree: If there is a left child, the function calculates the minimum depth of the left subtree and updates <code>res</code> if this value is smaller than the current <code>res</code>.</li> <li>Right Subtree: Similarly, if there is a right child, the function does the same for the right subtree.</li> <li>Leaf Node Handling: If <code>res</code> remains <code>INT_MAX</code> after checking both children, it means the current node is a leaf node (since neither left nor right subtree depth was calculated). Thus, <code>res</code> is set to 1.</li> <li>Return Value: The function returns <code>res</code>, which represents the minimum depth from the current node to the nearest leaf node.</li> </ol>"},{"location":"Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#iterative-solution","title":"Iterative Solution","text":"<pre><code>class Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        // If the root is null, the tree is empty, so the depth is 0\n        if (!root) return 0;\n\n        // Queue for level order traversal\n        queue&lt;TreeNode*&gt; q;\n        q.push(root); // Start with the root\n\n        int depth = 0; // Initialize depth\n\n        // Continue until the queue is empty\n        while (!q.empty()) {\n            int len = q.size(); // Number of nodes at the current level\n            depth++; // Increase depth as we move to a new level\n\n            // Iterate over all nodes at the current level\n            while (len--) {\n                auto node = q.front(); // Get the front node\n                q.pop(); // Remove the node from the queue\n\n                // If it's a leaf node, return the current depth\n                if (!node-&gt;left &amp;&amp; !node-&gt;right) return depth;\n\n                // Add the left and right children to the queue if they exist\n                if (node-&gt;left) q.push(node-&gt;left);\n                if (node-&gt;right) q.push(node-&gt;right);\n            }\n        }\n\n        // Depth of the tree, this line is technically not reachable as the function will return upon finding a leaf\n        return depth;\n    }\n};\n</code></pre> <p>Details of the Algorithm:</p> <ul> <li>The algorithm performs a breadth-first search (BFS) or level-order traversal on the tree.</li> <li>A queue is used to keep track of nodes at each level.</li> <li>For each level, all nodes are processed, and their children are added to the queue for the next level.</li> <li>The depth is incremented as the algorithm moves to a new level.</li> <li>The first time a leaf node (node with no children) is encountered, the current depth is returned. This ensures that the minimum depth is found, as BFS processes nodes level by level.</li> </ul> <p>Time Complexity Analysis:</p> <ul> <li>The time complexity is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree.</li> <li>Each node is visited exactly once in the level-order traversal.</li> </ul> <p>Space Complexity Analysis:</p> <ul> <li>The space complexity is primarily dependent on the breadth of the tree, which can vary.</li> <li>In the worst case (a completely unbalanced tree), it could be \\(O(N)\\) if all nodes are on a single level.</li> <li>In the best case (a perfectly balanced tree), it would be \\(O(\\log N)\\) due to the properties of a complete binary tree where the maximum number of nodes at any level is proportional to the height of the tree.</li> </ul> <p>Iterative vs Recursive Solutions:</p> <ul> <li>Unlike the recursive approach, which uses the call stack for recursion, this iterative approach explicitly manages the queue.</li> <li>This makes the iterative solution more suitable for situations where the tree is highly unbalanced, as it avoids the potential stack overflow that might occur with deep recursion.</li> </ul>"},{"location":"Leetcode/0100-0199/0112-path-sum/","title":"Path Sum","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0112-path-sum/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a root-to-leaf path such that adding up all the values along the path equals <code>targetSum</code>.</p> <p>A leaf is a node with no children.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</code></li> <li>Output: <code>true</code></li> <li>Explanation: The root-to-leaf path with the target sum is shown.</li> </ul> <p></p> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,2,3], targetSum = 5</code></li> <li>Output: <code>false</code></li> <li>Explanation:<ul> <li>There two root-to-leaf paths in the tree:<ul> <li><code>(1 --&gt; 2)</code>: The sum is <code>3</code>.</li> <li><code>(1 --&gt; 3)</code>: The sum is <code>4</code>.</li> </ul> </li> <li>There is no root-to-leaf path with <code>sum = 5</code>.</li> </ul> </li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [], targetSum = 0</code></li> <li>Output: <code>false</code></li> <li>Explanation: Since the tree is empty, there are no root-to-leaf paths.</li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> <li><code>-1000 &lt;= targetSum &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0100-0199/0112-path-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0112-path-sum/#way-1-recursion","title":"Way 1 (Recursion)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (!root) return false;\n        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val) return true;\n        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N)\\), where \\(N\\) is the number of nodes in the tree;</li> <li>Space complexity: \\(O(H)\\), where \\(H\\) is the height of the tree (Worst: \\(O(N)\\); Best: \\(O(\\log N)\\) ).</li> </ul>"},{"location":"Leetcode/0100-0199/0112-path-sum/#way-2-pre-order","title":"Way 2 (Pre-order)","text":"<pre><code>class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (!root) return false;\n        stack&lt;pair&lt;TreeNode*, int&gt;&gt; stk;\n        stk.push(make_pair(root, root-&gt;val));\n        while (!stk.empty()) {\n            auto node = stk.top();\n            stk.pop();\n            if (!(node.first)-&gt;left &amp;&amp; !(node.first)-&gt;right &amp;&amp; targetSum == node.second) return true;\n            if ((node.first)-&gt;right)\n                stk.push(make_pair((node.first)-&gt;right, node.second + (node.first)-&gt;right-&gt;val));\n            if ((node.first)-&gt;left)\n                stk.push(make_pair((node.first)-&gt;left, node.second + (node.first)-&gt;left-&gt;val));\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0112-path-sum/#way-3-level-order","title":"Way 3 (Level-order)","text":"<pre><code>class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (!root) return false;\n        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\n        q.push(make_pair(root, root-&gt;val));\n        while (!q.empty()) {\n            auto t = q.front();\n            q.pop();\n            if (!t.first-&gt;left &amp;&amp; !t.first-&gt;right &amp;&amp; t.second == targetSum) return true;\n            if (t.first-&gt;left) q.push(make_pair(t.first-&gt;left, t.first-&gt;left-&gt;val + t.second));\n            if (t.first-&gt;right) q.push(make_pair(t.first-&gt;right, t.first-&gt;right-&gt;val + t.second));\n        }\n        return false;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N)\\);</li> <li>Space complexity: \\(O(N)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0113-path-sum-ii/","title":"Path Sum II","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0113-path-sum-ii/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return all root-to-leaf paths where the sum of the node values in the path equals <code>targetSum</code>. Each path should be returned as a list of the node values, not node references.</p> <p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</code></li> <li>Output: <code>[[5,4,11,2],[5,8,4,5]]</code></li> <li>Explanation:<ul> <li>There are two paths whose sum equals targetSum:</li> <li><code>5 + 4 + 11 + 2 = 22</code></li> <li><code>5 + 8 + 4 + 5 = 22</code></li> </ul> </li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,2,3], targetSum = 5</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [1,2], targetSum = 0</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> <li><code>-1000 &lt;= targetSum &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0100-0199/0113-path-sum-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0113-path-sum-ii/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void traversal(TreeNode* node, int count) {\n        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; count == 0) {\n            res.push_back(path);\n            return;\n        }\n        if (node-&gt;left) {\n            path.push_back(node-&gt;left-&gt;val);\n            traversal(node-&gt;left, count - node-&gt;left-&gt;val);\n            path.pop_back();\n        }\n        if (node-&gt;right) {\n            path.push_back(node-&gt;right-&gt;val);\n            traversal(node-&gt;right, count - node-&gt;right-&gt;val);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        if (!root) return res;\n        path.push_back(root-&gt;val);\n        traversal(root, targetSum - root-&gt;val);\n        return res;\n    }\n};\n</code></pre> <p>Easier way of writing:</p> <p>See reference.</p> <pre><code>class Solution {\nprivate:\n    vector&lt;int&gt; path;\n    vector&lt;vector&lt;int&gt;&gt; res;\n    void findPaths(TreeNode* root, int sum) {\n        if (!root) return;\n        path.push_back(root-&gt;val);\n        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) res.push_back(path);\n        findPaths(root-&gt;left, sum - root-&gt;val);\n        findPaths(root-&gt;right, sum - root-&gt;val);\n        path.pop_back();\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        findPaths(root, targetSum);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0113-path-sum-ii/#way-2-pass-by-value","title":"Way 2 (Pass by Value)","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void findPaths(TreeNode* root, vector&lt;int&gt; path, int sum) {\n        if (!root) return;\n        sum -= root-&gt;val;\n        path.push_back(root-&gt;val);\n        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        findPaths(root-&gt;left, path, sum);\n        findPaths(root-&gt;right, path, sum);\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        findPaths(root, path, targetSum);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time Complexity: \\(O(N\\cdot H)\\), where \\(N\\) is the number of nodes and \\(H\\) is the average length of the path. The extra factor of H comes from the time taken to copy the path vector at each node. In the worst case, the top half of the tree is in the form of a chain, the bottom half is in the form of a fully binary tree, and the paths from the root node to each leaf node meet the requirements of the question. In this case, the number of paths is \\(O(N)\\) and the number of nodes in each path is also \\(O(N)\\), so the time complexity to add all these paths to the answer is \\(O(N^2)\\);</li> <li>Space complexity: \\(O(H)\\) for each recursive call, but since they are not shared, the maximum simultaneous space used is still \\(O(H)\\). In the worst case, it is \\(O(N)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0113-path-sum-ii/#note","title":"Note","text":"<p>Way 1: Not Using Return After Adding Path</p> <p>In Way 1, the <code>path</code> vector is a class member and is modified in place. Here's the corresponding section:</p> <pre><code>if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {\n    res.push_back(path);\n    // No return here\n}\n</code></pre> <ul> <li>Why <code>return</code> is Not Used: After adding a valid path to <code>res</code>, the function does not return immediately. Instead, it continues to the end, where <code>path.pop_back()</code> is called. This is crucial to maintain the correct state of <code>path</code> for other branches of the recursion.</li> <li>Control Flow Management: The absence of <code>return</code> here allows the function to reach <code>path.pop_back()</code> at the end, which is necessary to backtrack correctly in the recursive tree.</li> </ul> <p>Way 2: Returning After Adding Path</p> <p>In Way 2, the <code>path</code> vector is passed by value. Here's the key section:</p> <pre><code>if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) {\n    res.push_back(path);\n    return;\n}\n</code></pre> <ul> <li>Why <code>return</code> is Used: Once a valid path is found (i.e., a leaf node where the sum equals the target), this path is added to <code>res</code>, and the function returns immediately. This return is crucial because the function's further execution (calling left and right subtrees) is unnecessary\u2014the path has been completed and recorded.</li> <li>Effect of <code>return</code>: It prevents further unnecessary recursive calls for the current path.</li> </ul> <p>Summary:</p> <ul> <li>Way 1: Does not use <code>return</code> immediately after finding a path, as it needs to reach the <code>pop_back</code> operation to correctly manage the state of the shared <code>path</code> vector for ongoing recursion.</li> <li>Way 2: Uses <code>return</code> to avoid unnecessary recursive calls after a complete path is found, as each recursive call works on its own copy of <code>path</code>.</li> </ul>"},{"location":"Leetcode/0100-0199/0120-triangle/","title":"Triangle","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0120-triangle/#description","title":"Description","text":"<p>Given a <code>triangle</code> array, return the minimum path sum from top to bottom.</p> <p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p> <p>Example 1:</p> <ul> <li>Input: <code>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</code></li> <li>Output: <code>11</code></li> <li>Explanation: The triangle looks like:</li> </ul> <pre><code>   2\n  3 4\n 6 5 7\n4 1 8 3\n</code></pre> <p>The minimum path sum from top to bottom is <code>2 + 3 + 5 + 1 = 11</code> (underlined above).</p> <p>Example 2:</p> <ul> <li>Input: <code>triangle = [[-10]]</code></li> <li>Output: <code>-10</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= triangle.length &lt;= 200</code></li> <li><code>triangle[0].length == 1</code></li> <li><code>triangle[i].length == triangle[i - 1].length + 1</code></li> <li><code>-10^4 &lt;= triangle[i][j] &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0100-0199/0120-triangle/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0120-triangle/#way-1-top-down","title":"Way 1 (Top-down)","text":"<pre><code>class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        const int N = 210;\n        int n = triangle.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(N, vector&lt;int&gt;(N, 0x3f3f3f3f));\n\n        dp[1][1] = triangle[0][0];\n        for (int i = 2; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= i; j++) {\n                dp[i][j] = min(dp[i - 1][j - 1] + triangle[i - 1][j - 1], dp[i - 1][j] + triangle[i - 1][j - 1]);\n            }\n        }\n\n        int res = 0x3f3f3f3f;\n        for (int i = 1; i &lt;= n; i++) res = min(res, dp[n][i]);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(n^2)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0120-triangle/#way-2-bottom-up","title":"Way 2 (Bottom-up)","text":"<pre><code>class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        for (int i = triangle.size() - 2; i &gt;= 0; i--) {\n            for (int j = 0; j &lt;= i; j++) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n};\n</code></pre> <p><code>DP[i][j] = triangle[i][j] + min(DP[i+1][j], DP[i+1][j+1])</code></p> <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0126-word-ladder-ii/","title":"Word Ladder II","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0126-word-ladder-ii/#description","title":"Description","text":"<p>A transformation sequence from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p> <ul> <li>Every adjacent pair of words differs by a single letter.</li> <li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li> <li><code>sk == endWord</code></li> </ul> <p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return all the shortest transformation sequences from <code>beginWord</code> to <code>endWord</code>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words <code>[beginWord, s1, s2, ..., sk]</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code></li> <li>Output: <code>[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]</code></li> <li>Explanation:</li> </ul> <pre><code>There are 2 shortest transformation sequences:\n\"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\"\n\"hit\" -&gt; \"hot\" -&gt; \"lot\" -&gt; \"log\" -&gt; \"cog\"\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]</code></li> <li>Output: <code>[]</code></li> <li>Explanation: <code>The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= beginWord.length &lt;= 5</code></li> <li><code>endWord.length == beginWord.length</code></li> <li><code>1 &lt;= wordList.length &lt;= 500</code></li> <li><code>wordList[i].length == beginWord.length</code></li> <li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li> <li><code>beginWord != endWord</code></li> <li>All the words in <code>wordList</code> are unique.</li> <li>The sum of all shortest transformation sequences does not exceed <code>10^5</code>.</li> </ul>"},{"location":"Leetcode/0100-0199/0126-word-ladder-ii/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    void dfs(string&amp; beginWord, string word, vector&lt;string&gt;&amp; path, unordered_map&lt;string, int&gt;&amp; dist) {\n        if (word == beginWord) {\n            reverse(path.begin(), path.end());\n            res.push_back(path);\n            reverse(path.begin(), path.end());\n        } else {\n            for (int i = 0; i &lt; word.size(); i++) {\n                string oldWord = word;\n                for (int j = 'a'; j &lt;= 'z'; j++) {\n                    oldWord[i] = j;\n                    if (dist.count(oldWord) &amp;&amp; dist[oldWord] + 1 == dist[word]) {\n                        path.push_back(oldWord);\n                        dfs(beginWord, oldWord, path, dist);\n                        path.pop_back();\n                    }\n                }\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) return res;\n\n        unordered_map&lt;string, int&gt; dist;\n        dist[beginWord] = 0;\n\n        queue&lt;string&gt; que;\n        que.push(beginWord);\n\n        while (!que.empty()) {\n            string word = que.front();\n            que.pop();\n\n            for (int i = 0; i &lt; word.size(); i++) {\n                string newWord = word;\n                for (char j = 'a'; j &lt;= 'z'; j++) {\n                    newWord[i] = j;\n                    if (wordSet.count(newWord) &amp;&amp; !dist.count(newWord)) {\n                        dist[newWord] = dist[word] + 1;\n                        if (newWord == endWord) break;\n                        que.push(newWord);\n                    }\n                }\n            }\n        }\n\n        vector&lt;string&gt; path;\n        path.push_back(endWord);\n        dfs(beginWord, endWord, path, dist);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0127-word-ladder/","title":"Word Ladder","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0127-word-ladder/#description","title":"Description","text":"<p>A transformation sequence from word <code>beginWord</code> to word <code>endWord</code> using a dictionary wordList is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p> <ul> <li>Every adjacent pair of words differs by a single letter.</li> <li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li> <li><code>sk == endWord</code></li> </ul> <p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return the number of words in the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>, or <code>0</code> if no such sequence exists.</p> <p>Example 1:</p> <ul> <li>Input: <code>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code></li> <li>Output: <code>5</code></li> <li>Explanation: <code>One shortest transformation sequence is \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; cog\", which is 5 words long.</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]</code></li> <li>Output: <code>0</code></li> <li>Explanation: <code>The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= beginWord.length &lt;= 10</code></li> <li><code>endWord.length == beginWord.length</code></li> <li><code>1 &lt;= wordList.length &lt;= 5000</code></li> <li><code>wordList[i].length == beginWord.length</code></li> <li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li> <li><code>beginWord != endWord</code></li> <li>All the words in <code>wordList</code> are unique.</li> </ul>"},{"location":"Leetcode/0100-0199/0127-word-ladder/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) return 0;\n\n        unordered_map&lt;string, int&gt; visitMap;\n        queue&lt;string&gt; que;\n        que.push(beginWord);\n        visitMap[beginWord] = 1;\n\n        while (!que.empty()) {\n            string word = que.front();\n            que.pop();\n\n            int path = visitMap[word];\n            for (int i = 0; i &lt; word.size(); i++) {\n                string newWord = word;\n                for (int j = 0; j &lt; 26; j++) {\n                    newWord[i] = j + 'a';\n                    if (newWord == endWord) return path + 1;\n                    if (wordSet.count(newWord) &amp;&amp; !visitMap.count(newWord)) {\n                        visitMap[newWord] = path + 1;\n                        que.push(newWord);\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n};\n</code></pre> <p>Code with Comments:</p> <pre><code>class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        // Convert wordList into a set for O(1) access\n        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());\n\n        // If the endWord is not in the wordSet, no solution exists\n        if (!wordSet.count(endWord)) return 0;\n\n        // Map to keep track of visited words and their path lengths\n        unordered_map&lt;string, int&gt; visitMap;\n\n        // Queue for BFS\n        queue&lt;string&gt; que;\n        que.push(beginWord); // Start from the beginWord\n        visitMap[beginWord] = 1; // Starting word has path length 1\n\n        // BFS\n        while (!que.empty()) {\n            string word = que.front(); // Current word\n            que.pop();\n\n            int path = visitMap[word]; // Current path length\n            // Try changing each letter of the word\n            for (int i = 0; i &lt; word.size(); i++) {\n                string newWord = word;\n                // Try replacing the i-th character with every possible lowercase letter\n                for (int j = 0; j &lt; 26; j++) {\n                    newWord[i] = j + 'a'; // Replace with the j-th letter\n                    // If the new word is the endWord, return the path length + 1\n                    if (newWord == endWord) return path + 1;\n                    // If newWord is in the wordSet and not visited, add to queue and mark as visited\n                    if (wordSet.count(newWord) &amp;&amp; !visitMap.count(newWord)) {\n                        visitMap[newWord] = path + 1; // Increment path length\n                        que.push(newWord); // Add to BFS queue\n                    }\n                }\n            }\n        }\n\n        // If no path is found\n        return 0;\n    }\n};\n</code></pre> <p>Algorithm:</p> <ol> <li>Initialization: Convert the <code>wordList</code> into an <code>unordered_set</code> for \\(O(1)\\) access. This helps in quickly checking if a word exists in the word list. Additionally, a queue for BFS and a map to track visited words are initialized.</li> <li>Breadth-First Search (BFS): The algorithm uses BFS to find the shortest path from <code>beginWord</code> to <code>endWord</code>. For each word, it iteratively changes each letter to all possible 26 letters and checks if the new word is in the word set.</li> <li>Path Tracking: The <code>visitMap</code> keeps track of each word and the length of the shortest path to reach it from <code>beginWord</code>.</li> <li>Termination: If <code>endWord</code> is reached, the shortest path length is returned. If BFS completes without finding <code>endWord</code>, return 0.</li> </ol> <p>Complexity Analysis:</p> <ol> <li>Time Complexity:</li> <li>The main contributing factor to time complexity is the double loop inside the BFS, where we iterate over each letter of the word and then over 26 possible replacements.</li> <li>For a word of length <code>L</code> and a total of <code>N</code> words in the word list, the worst-case time complexity is \\(O(26NL)\\). This is because we potentially explore \\(26\\) different transformations for each of the \\(L\\) characters in each of the \\(N\\) words.</li> <li>Space Complexity:</li> <li>The space complexity is primarily dictated by the storage of the word set and the visit map.</li> <li>Both the <code>unordered_set</code> and the <code>unordered_map</code> store a number of elements equal to the size of the <code>wordList</code>, giving a space complexity of \\(O(N)\\).</li> <li>Additionally, the queue in the worst case might store a significant number of words, but this also will not exceed \\(O(N)\\).</li> </ol>"},{"location":"Leetcode/0100-0199/0128-longest-consecutive-sequence/","title":"Longest Consecutive Sequence","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0128-longest-consecutive-sequence/#description","title":"Description","text":"<p>Given an unsorted array of integers <code>nums</code>, return the length of the longest consecutive elements sequence.</p> <p>You must write an algorithm that runs in \\(O(n)\\) time.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [100,4,200,1,3,2]</code></li> <li>Output: <code>4</code></li> <li>Explanation: <code>The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [0,3,7,2,5,8,4,6,0,1]</code></li> <li>Output: <code>9</code></li> </ul> <p>Constraints:</p> <ul> <li><code>0 &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> </ul>"},{"location":"Leetcode/0100-0199/0128-longest-consecutive-sequence/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0128-longest-consecutive-sequence/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        unordered_set&lt;int&gt; s(nums.begin(), nums.end());\n        int best = 0;\n        for (int x : s) {\n            if (s.find(x - 1) == s.end()) {\n                int curr = x + 1;\n                while (s.find(curr) != s.end()) curr++;\n                best = max(best, curr - x);\n            }\n        }\n        return best;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0128-longest-consecutive-sequence/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    unordered_map&lt;int, int&gt; fa, cnt;\n\n    int find(int x) {\n        if (fa[x] != x) fa[x] = find(fa[x]);\n        return fa[x];\n    }\n\n    void join_sets(int x, int y) {\n        int m = find(x), n = find(y);\n        if (m != n) {\n            fa[m] = n;\n            cnt[n] += cnt[m];\n        }\n    }\n\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        for (int i : nums) {\n            if (!fa.count(i)) {\n                fa[i] = i;\n                cnt[i] = 1;\n            } else continue;\n\n            if (fa.count(i - 1)) join_sets(i, i - 1);\n            if (fa.count(i + 1)) join_sets(i, i + 1);\n        }\n        int res = 0;\n        for (auto p : cnt) res = max(res, p.second);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0130-surrounded-regions/","title":"Surrounded Regions","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0130-surrounded-regions/#description","title":"Description","text":"<p>Given an <code>m x n</code> matrix board containing <code>'X'</code> and <code>'O'</code>, capture all regions that are 4-directionally surrounded by <code>'X'</code>.</p> <p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p> <p>Example 1:</p> <p></p> <ul> <li>Input: <code>board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</code></li> <li>Output: <code>[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</code></li> <li>Explanation:</li> </ul> <pre><code>Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>board = [[\"X\"]]</code></li> <li>Output: <code>[[\"X\"]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>m == board.length</code></li> <li><code>n == board[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 200</code></li> <li><code>board[i][j] is 'X' or 'O'</code>.</li> </ul>"},{"location":"Leetcode/0100-0199/0130-surrounded-regions/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    int n, m;\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) {\n        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != 'O') return;\n        board[x][y] = '#';\n        dfs(board, x + 1, y);\n        dfs(board, x - 1, y);\n        dfs(board, x, y - 1);\n        dfs(board, x, y + 1);\n    }\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        n = board.size(), m = board[0].size();\n        for (int i = 0; i &lt; n; i++) {\n            dfs(board, i, 0);\n            dfs(board, i, m - 1);\n        }\n        for (int i = 1; i &lt; m - 1; i++) {\n            dfs(board, 0, i);\n            dfs(board, n - 1, i);\n        }\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (board[i][j] == '#') board[i][j] = 'O';\n                else if (board[i][j] == 'O') board[i][j] = 'X';\n            }\n        }\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(nm)\\);</li> <li>Space complexity: \\(O(nm)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0131-palindrome-partitioning/","title":"Palindrome Partitioning","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0131-palindrome-partitioning/#description","title":"Description","text":"<p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of <code>s</code>.</p> <p>A substring is a contiguous non-empty sequence of characters within a string. A palindrome is a string that reads the same forward and backward.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"aab\"</code></li> <li>Output: <code>[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"a\"</code></li> <li>Output: <code>[[\"a\"]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 16</code></li> <li><code>s</code> contains only lowercase English letters.</li> </ul>"},{"location":"Leetcode/0100-0199/0131-palindrome-partitioning/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0131-palindrome-partitioning/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n\n    void backtracking(string &amp;s, int index) {\n        if (index == s.length()) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = index; i &lt; s.length(); i++) {\n            if (!isPalindrome(s, index, i)) continue;\n            path.push_back(s.substr(index, i - index + 1));\n            backtracking(s, i + 1);\n            path.pop_back();\n        }\n    }\n\n    bool isPalindrome(string &amp;s, int l, int r) {\n        while (l &lt; r) {\n            if (s[l] != s[r]) return false;\n            l++, r--;\n        }\n        return true;\n    }\n\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        backtracking(s, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\cdot 2^n)\\);</li> <li>Space complexity: \\(O(n^2)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0131-palindrome-partitioning/#way-2-optimized-solution","title":"Way 2: Optimized Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n    vector&lt;vector&lt;bool&gt;&gt; isPalindrome; \n\n    void backtracking(const string &amp;s, int index) {\n        if (index == s.length()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = index; i &lt; s.length(); i++) {\n            if (!isPalindrome[index][i]) continue;\n            path.push_back(s.substr(index, i - index + 1));\n            backtracking(s, i + 1);\n            path.pop_back();\n        }\n    }\n\n    void computeMemo(const string &amp;s) {\n        isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false));\n        for (int i = s.size() - 1; i &gt;= 0; i--) {\n            for (int j = i; j &lt; s.size(); j++) {\n                if (j == i) isPalindrome[i][j] = true;\n                else if (j - i == 1) isPalindrome[i][j] = (s[i] == s[j]);\n                else isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i + 1][j - 1]);\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        computeMemo(s);\n        backtracking(s, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0139-word-break/","title":"Word Break","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0139-word-break/#description","title":"Description","text":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p> <p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"leetcode\", wordDict = [\"leet\",\"code\"]</code></li> <li>Output: <code>true</code></li> <li>Explanation: <code>Return true because \"leetcode\" can be segmented as \"leet code\".</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]</code></li> <li>Output: <code>true</code></li> <li>Explanation: <code>Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word.</code></li> </ul> <p>Example 3:</p> <p>Input: <code>s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]</code> Output: <code>false</code></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 300</code></li> <li><code>1 &lt;= wordDict.length &lt;= 1000</code></li> <li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li> <li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li> <li>All the strings of <code>wordDict</code> are unique.</li> </ul>"},{"location":"Leetcode/0100-0199/0139-word-break/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());\n        vector&lt;bool&gt; dp(s.size() + 1, false);\n        dp[0] = true;\n        for (int i = 1; i &lt;= s.size(); i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if ((wordSet.find(s.substr(j, i - j)) != wordSet.end()) &amp;&amp; dp[j])\n                    dp[i] = true;\n            }\n        }\n        return dp[s.size()];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0141-linked-list-cycle/","title":"Linked List Cycle","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0141-linked-list-cycle/#description","title":"Description","text":"<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p> <p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to. Note that <code>pos</code> is not passed as a parameter.</p> <p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [3,2,0,-4], pos = 1</code></li> <li>Output: <code>true</code></li> <li>Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [1,2], pos = 0</code></li> <li>Output: <code>true</code></li> <li>Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = [1], pos = -1</code></li> <li>Output: <code>false</code></li> <li>Explanation: There is no cycle in the linked list.</li> </ul> <p>Constraints:</p> <ul> <li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li> <li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li> <li><code>pos</code> is <code>-1</code> or a valid index in the linked-list.</li> </ul>"},{"location":"Leetcode/0100-0199/0141-linked-list-cycle/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0141-linked-list-cycle/#double-pointer","title":"Double Pointer","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        auto slow = head, fast = head;\n        while (fast &amp;&amp; fast-&gt;next) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0142-linked-list-cycle-ii/","title":"Linked List Cycle II","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0142-linked-list-cycle-ii/#description","title":"Description","text":"<p>Given the <code>head</code> of a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p> <p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to (0-indexed). It is <code>-1</code> if there is no cycle. Note that <code>pos</code> is not passed as a parameter.</p> <p>Do not modify the linked list.</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [3,2,0,-4], pos = 1</code></li> <li>Output: tail connects to node index 1</li> <li>Explanation: There is a cycle in the linked list, where tail connects to the second node.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [1,2], pos = 0</code></li> <li>Output: tail connects to node index 0</li> <li>Explanation: There is a cycle in the linked list, where tail connects to the first node.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = [1], pos = -1</code></li> <li>Output: no cycle</li> <li>Explanation: There is no cycle in the linked list.</li> </ul> <p>Constraints:</p> <ul> <li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li> <li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li> <li><code>pos</code> is <code>-1</code> or a valid index in the linked-list.</li> </ul>"},{"location":"Leetcode/0100-0199/0142-linked-list-cycle-ii/#solution","title":"Solution","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *fast = head;\n        ListNode *slow = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n            if (fast == slow) {\n                ListNode *index1 = fast;\n                ListNode *index2 = head;\n                while (index1 != index2) {\n                    index1 = index1-&gt;next;\n                    index2 = index2-&gt;next;\n                }\n                return index1;\n            }\n        }\n\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/","title":"Binary Tree Preorder Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the preorder traversal of its nodes' values.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,null,2,3]</code></li> <li>Output: <code>[1,2,3]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#recursive-method","title":"Recursive Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void preOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        res.push_back(node-&gt;val);\n        preOrder(node-&gt;left, res);\n        preOrder(node-&gt;right, res);\n    }\n\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        preOrder(root, res);\n        return res;\n    }\n};\n</code></pre> <p>Extra: Python solution:</p> <pre><code>class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:\n        if not root:\n            return []\n        # * sign in python is an unpacking symbol that unformats a data structure to get the inner elements directly\n        return [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]\n</code></pre>"},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#iterative-method","title":"Iterative Method","text":""},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        vector&lt;int&gt; res{};\n        if (root == nullptr) return res;\n        stk.push(root);\n\n        while (!stk.empty()) {\n            auto node = stk.top();\n            stk.pop();\n            res.push_back(node-&gt;val);\n            if (node-&gt;right) stk.push(node-&gt;right);\n            if (node-&gt;left) stk.push(node-&gt;left);\n        }\n        return res;\n    }\n};\n</code></pre> <p>The right child is pushed before the left child. This is crucial because stacks are LIFO (Last In, First Out) structures, meaning the left child will be popped and processed first in the next iteration, maintaining the correct order for preorder traversal: root, left, right.</p>"},{"location":"Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#way-2-preferred","title":"Way 2 (Preferred)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        vector&lt;int&gt; res;\n        while (root || !stk.empty()) {\n            if (root) {\n                res.push_back(root-&gt;val);\n                stk.push(root);\n                root = root-&gt;left;\n            } else {\n                auto t = stk.top();\n                stk.pop();\n                root = t-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        // A stack to hold the TreeNode pointers during traversal.\n        stack&lt;TreeNode*&gt; stk;\n\n        // A vector to store the result of the preorder traversal.\n        vector&lt;int&gt; res;\n\n        // The loop continues as long as there are nodes to process. This is determined\n        // by checking if either the current node (root) is not null or the stack is not empty.\n        while (root || !stk.empty()) {\n\n            // If the current node (root) is not null, it means there is a node to process.\n            if (root) {\n                // Add the value of the current node to the result as per preorder traversal.\n                res.push_back(root-&gt;val);\n\n                // Push the current node to the stack so that we can return to it after\n                // traversing its left subtree.\n                stk.push(root);\n\n                // Move to the left child of the current node.\n                root = root-&gt;left;\n            } \n            // If the current node is null, it means we have reached the end of a subtree.\n            else {\n                // Retrieve the most recently visited node from the stack.\n                auto t = stk.top();\n                stk.pop();\n\n                // Move to the right child of the retrieved node.\n                root = t-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Detailed Steps of the Algorithm:</p> <ol> <li>Initialize a Stack: A stack is used to keep track of nodes. The stack is initially empty.</li> <li>Start from the Root Node: The traversal begins from the root node of the binary tree.</li> <li>Process the Current Node: If the current node is not null, several steps are followed:<ol> <li>The value of the current node is added to the result list. This is because, in preorder traversal, the node is processed before its children.</li> <li>The current node is pushed onto the stack. This is done to keep a reference to the node, so we can later access its right child.</li> <li>The current node is then moved to its left child.</li> </ol> </li> <li>Backtracking using the Stack: If the current node is null (which happens when there's no left child), the algorithm 'backtracks' by popping a node from the stack. This node is the parent of the previously visited node.</li> <li>Visit the Right Child: After backtracking to the parent node, the algorithm then proceeds to visit the right child of that node.</li> <li>Repeat the Process: Steps 3 to 5 are repeated until there are no more nodes to visit, which is determined by both the current node being null and the stack being empty.</li> </ol> <p>Time Complexity Analysis:</p> <ol> <li>Best and Average Case: \\(O(n)\\) where \\(n\\) is the number of nodes in the binary tree. Each node is visited exactly once.</li> <li>Worst Case: The worst-case time complexity is also \\(O(n)\\) as even in the case of a skewed tree (like a linked list), each node is visited once.</li> </ol> <p>Space Complexity Analysis:</p> <ol> <li>Best Case (Completely Balanced Tree): \\(O(\\log n)\\), where \\(n\\) is the number of nodes. In a balanced tree, the stack size will be proportional to the height of the tree, which is \\(\\log n\\).</li> <li>Average Case: The average space complexity is \\(O(\\log n)\\) for the same reason as above. However, the tree might not be perfectly balanced, so the average height could be slightly more than \\(\\log n\\).</li> <li>Worst Case (Skewed Tree): \\(O(n)\\). In the worst case (like a linked list), the stack will hold all the nodes of one branch of the tree, which can be \\(n\\) in the case of a skewed tree.</li> </ol>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/","title":"Binary Tree Postorder Traversal","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the postorder traversal of its nodes' values.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,null,2,3]</code></li> <li>Output: <code>[3,2,1]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#recursive-method","title":"Recursive Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void postOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        postOrder(node-&gt;left, res);\n        postOrder(node-&gt;right, res);\n        res.push_back(node-&gt;val);\n    }\n\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        postOrder(root, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#iterative-method","title":"Iterative Method","text":""},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        vector&lt;int&gt; res;\n        if (root == nullptr) return res;\n        stk.push(root);\n        while (!stk.empty()) {\n            auto node = stk.top();\n            stk.pop();\n            res.push_back(node-&gt;val);\n            if (node-&gt;left) stk.push(node-&gt;left);\n            if (node-&gt;right) stk.push(node-&gt;right);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n</code></pre> <p>Breakdown:</p> <ol> <li>Initialization and Base Case Check:<ul> <li>The solution begins by initializing a stack (<code>stk</code>) and a result vector (<code>res</code>).</li> <li>It checks if the <code>root</code> is <code>nullptr</code>, returning an empty <code>res</code> if true. This handles the edge case of an empty tree.</li> </ul> </li> <li>Starting the Traversal:<ul> <li>The <code>root</code> node is pushed onto the stack. This is the starting point of the traversal.</li> </ul> </li> <li>Iterative Traversal:<ul> <li>The traversal occurs inside a <code>while</code> loop, continuing as long as the stack is not empty.</li> <li>In each iteration, the top node of the stack is popped and its value is added to <code>res</code>.</li> <li>Then, if the left child of this node exists, it is pushed onto the stack, followed by the right child if it exists.</li> </ul> </li> <li>Order of Pushing Children:<ul> <li>The left child is pushed before the right child. This is crucial because stacks are LIFO (Last In, First Out) structures. By pushing the right child last, it ensures that the right child will be processed after the left child in subsequent iterations.</li> </ul> </li> <li>Reverse the Result:<ul> <li>After the traversal, the <code>res</code> vector, which is in root-right-left order, is reversed to achieve the left-right-root order of postorder traversal.</li> </ul> </li> </ol>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#way-2","title":"Way 2","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        vector&lt;int&gt; res;\n        while (root || !stk.empty()) {\n            if (root) {\n                res.push_back(root-&gt;val);\n                stk.push(root);\n                root = root-&gt;right;\n            } else {\n                auto t = stk.top();\n                stk.pop();\n                root = t-&gt;left;\n            }\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        // A stack to hold TreeNode pointers during traversal.\n        stack&lt;TreeNode*&gt; stk;\n\n        // A vector to store the traversal result.\n        vector&lt;int&gt; res;\n\n        // Continue until all nodes are processed.\n        while (root || !stk.empty()) {\n            if (root) {\n                // Instead of processing the current node, push its value to the result.\n                // This is the reverse of the postorder.\n                res.push_back(root-&gt;val);\n\n                // Push the current node to the stack for later processing.\n                stk.push(root);\n\n                // Move to the right child, opposite of the usual left move in postorder.\n                root = root-&gt;right;\n            } else {\n                // Retrieve the most recently visited node.\n                auto t = stk.top();\n                stk.pop();\n\n                // Move to the left child.\n                root = t-&gt;left;\n            }\n        }\n\n        // Reverse the result to convert it into the correct postorder sequence.\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n</code></pre> <p>Steps of the Solution:</p> <ol> <li>Initialize a Stack and Result Vector: A stack and a result vector are initialized to manage the traversal and store the results, respectively.</li> <li>Iterative Traversal:<ul> <li>If the current node (<code>root</code>) is not null, its value is added to the <code>res</code> vector (mimicking postorder but in reverse).</li> <li>The current node is then pushed to the stack, and the traversal moves to the right child (not the left, as would be typical in postorder).</li> <li>If <code>root</code> is null, which indicates the end of a branch, the algorithm backtracks using the stack, retrieving the last visited node and moving to its left child.</li> </ul> </li> <li>Reverse the Result: After the traversal, the <code>res</code> vector, which is in root-right-left order, is reversed to align with the left-right-root order of postorder traversal.</li> </ol> <p>Time Complexity Analysis:</p> <ul> <li>\\(O(n)\\): Each node in the tree is visited exactly once, leading to a time complexity of \\(O(n)\\), where \\(n\\) is the number of nodes in the tree.</li> </ul> <p>Space Complexity Analysis:</p> <ul> <li>Best Case (Balanced Tree): \\(O(\\log n)\\), where the height of the tree is \\(\\log n\\) and the stack's size will be proportional to the tree's height.</li> <li>Worst Case (Skewed Tree): \\(O(n)\\), where the tree is like a linked list, and the stack can potentially hold all the nodes.</li> <li>Average Case: Generally between \\(O(\\log n)\\) and \\(O(n)\\), depending on the tree's structure.</li> </ul>"},{"location":"Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#way-3","title":"Way 3","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; postOrder;\n        if (root == nullptr) return postOrder;\n\n        stack&lt;TreeNode*&gt; stk;\n        TreeNode *curr = root;\n        TreeNode *lastVisited = nullptr;\n\n        while (curr || ! stk.empty()) {\n            if (curr) {\n                stk.push(curr);\n                curr = curr-&gt;left;\n            } else {\n                TreeNode *peekNode = stk.top();\n                if (peekNode-&gt;right &amp;&amp; peekNode-&gt;right != lastVisited) {\n                    curr = peekNode-&gt;right;\n                } else {\n                    stk.pop();\n                    postOrder.push_back(peekNode-&gt;val);\n                    lastVisited = peekNode;\n                }\n            }\n        }\n        return postOrder;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        // Vector to store the postorder traversal\n        vector&lt;int&gt; postOrder;\n        // If the root is null, return an empty vector\n        if (root == nullptr) return postOrder;\n\n        // Stack to hold the nodes during the traversal\n        stack&lt;TreeNode*&gt; stk;\n        // 'curr' will point to the current node being processed\n        TreeNode *curr = root;\n        // 'lastVisited' keeps track of the last visited node\n        TreeNode *lastVisited = nullptr;\n\n        // Continue until all nodes are processed\n        while (curr || !stk.empty()) {\n            if (curr) {\n                // If the current node is not null, push it onto the stack and go to its left child\n                stk.push(curr);\n                curr = curr-&gt;left;\n            } else {\n                // Peek at the node at the top of the stack without removing it\n                TreeNode *peekNode = stk.top();\n                // If the right child exists and hasn't been visited yet, go to the right child\n                if (peekNode-&gt;right &amp;&amp; peekNode-&gt;right != lastVisited) {\n                    curr = peekNode-&gt;right;\n                } else {\n                    // If there is no right child or it's already visited, then process this node\n                    stk.pop(); // Remove the node from the stack\n                    postOrder.push_back(peekNode-&gt;val); // Add the node's value to the result vector\n                    lastVisited = peekNode; // Mark this node as visited\n                }\n            }\n        }\n        return postOrder; // Return the postorder traversal\n    }\n};\n</code></pre> <p>Explanation of the Algorithm:</p> <ol> <li>Initialization: The algorithm starts by initializing a vector <code>postOrder</code> to store the result of the postorder traversal. A stack <code>stk</code> is used to keep track of nodes, and two pointers <code>curr</code> and <code>lastVisited</code> are initialized.</li> <li>Traversal Loop: The while loop continues as long as there are unprocessed nodes, indicated by either <code>curr</code> not being null or the stack not being empty.</li> <li>Left Subtree Processing: If <code>curr</code> is not null, it means we are going down the left subtree. The current node is pushed onto the stack, and we move <code>curr</code> to its left child.</li> <li>Right Subtree and Node Processing: If <code>curr</code> is null, it means we have reached a leaf or are backtracking. We then peek at the top of the stack. If the right child of the peeked node exists and hasn't been visited, we set <code>curr</code> to this right child. Otherwise, it's time to visit the peeked node: we pop it from the stack, add its value to <code>postOrder</code>, and mark it as <code>lastVisited</code>.</li> <li>Completion: Once all nodes are processed, the <code>postOrder</code> vector contains the elements in postorder traversal order.</li> </ol>"},{"location":"Leetcode/0100-0199/0148-sort-list/","title":"Sort List","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0148-sort-list/#description","title":"Description","text":"<p>Given the <code>head</code> of a linked list, return the list after sorting it in ascending order.</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [4,2,1,3]</code></li> <li>Output: <code>[1,2,3,4]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [-1,5,3,4,0]</code></li> <li>Output: <code>[-1,0,3,4,5]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[0, 5 * 10^4]</code>.</li> <li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li> </ul>"},{"location":"Leetcode/0100-0199/0148-sort-list/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0148-sort-list/#merge-sort-top-to-bottom","title":"Merge Sort (top to bottom)","text":"<p>The process of top-down merge sorting of a linked list is as follows.</p> <ul> <li>Find the midpoint of the linked list and use the midpoint as a divider to split the linked list into two sub linked lists. To find the midpoint of a linked list, we can use the fast and slow pointers, the fast pointer moves 2 steps at a time, and the slow pointer moves 1 steps at a time. When the fast pointer reaches the end of the linked list, the node of the linked list pointed to by the slow pointer is the midpoint of the linked list.</li> <li>Sort the two sub-lined lists separately.</li> <li>Merge the two sorted sub-linking lists to get the complete sorted linking list.</li> </ul> <p>The above process can be realized by recursion. The termination condition for recursion is that the number of nodes in the linked list is less than or equal to 1, i.e., when the linked list is empty or contains only 1 nodes, there is no need to split and sort the linked list.</p> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode* merge_sort_top_to_bottom(ListNode* head, ListNode* tail) {\n        if (head == nullptr) return head;\n        if (head-&gt;next == tail) {\n            head-&gt;next = nullptr;\n            return head;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != tail) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n            if (fast != tail) fast = fast-&gt;next;\n        }\n        ListNode* mid = slow;\n        return merge(merge_sort_top_to_bottom(head, mid), merge_sort_top_to_bottom(mid, tail));\n    }\n\n    ListNode* merge(ListNode* head1, ListNode* head2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;\n        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) {\n            if (temp1-&gt;val &lt;= temp2-&gt;val) {\n                temp-&gt;next = temp1;\n                temp1 = temp1-&gt;next;\n            } else {\n                temp-&gt;next = temp2;\n                temp2 = temp2-&gt;next;\n            }\n            temp = temp-&gt;next;\n        }\n        if (temp1 != nullptr) temp-&gt;next = temp1;\n        if (temp2 != nullptr) temp-&gt;next = temp2;\n        return dummyHead-&gt;next;\n    }\n\npublic:\n    ListNode* sortList(ListNode* head) {\n        return merge_sort_top_to_bottom(head, nullptr);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\log n)\\);</li> <li>Space complexity: \\(O(\\log n)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0148-sort-list/#merge-sort-bottom-to-top","title":"Merge Sort (bottom to top)","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        int n = 0;\n        for (auto p = head; p; p = p-&gt;next) n++;\n\n        auto dummy = new ListNode();\n        dummy-&gt;next = head;\n\n        for (int i = 1; i &lt; n; i *= 2) {\n            auto curr = dummy;\n            for (int j = 1; j + i &lt;= n; j += i * 2) {\n                auto p = curr-&gt;next, q = p;\n                for (int k = 0; k &lt; i; k++) q = q-&gt;next;\n\n                int x = 0, y = 0;\n                while (x &lt; i &amp;&amp; y &lt; i &amp;&amp; p &amp;&amp; q) {\n                    if (p-&gt;val &lt;= q-&gt;val) {\n                        curr = curr-&gt;next = p;\n                        p = p-&gt;next;\n                        x++;\n                    } else {\n                        curr = curr-&gt;next = q;\n                        q = q-&gt;next;\n                        y++;\n                    }\n                }\n\n                while (x &lt; i &amp;&amp; p) {\n                    curr = curr-&gt;next = p;\n                    p = p-&gt;next;\n                    x++;\n                }\n                while (y &lt; i &amp;&amp; q) {\n                    curr = curr-&gt;next = q;\n                    q = q-&gt;next;\n                    y++;\n                }\n                curr-&gt;next = q;\n            }\n        }\n\n        return dummy-&gt;next;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\log n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0148-sort-list/#algorithm-overview-bottom-up-merge-sort","title":"Algorithm Overview: Bottom-Up Merge Sort","text":"<ol> <li>Initialization: First, the length of the list is calculated. This is needed to control the iterations as we'll be merging sublists of increasing sizes.</li> <li>Dummy Head: A dummy head node is used for ease of operations. It points to the head of the list and is used to handle edge cases smoothly.</li> <li>Iterative Merging: The list is split into pairs of sublists of size <code>i</code>, where <code>i</code> starts from 1 and doubles each iteration (1, 2, 4, 8, ...). These pairs of sublists are merged in a sorted manner.</li> <li>Merging Sublists: For each pair of sublists, the elements are compared and merged into a single sorted sublist. This process continues until all sublists are merged into one sorted list.</li> </ol>"},{"location":"Leetcode/0100-0199/0148-sort-list/#code-explanation","title":"Code Explanation","text":"<p>Sorting Initialization:</p> <pre><code>int n = 0;\nfor (auto p = head; p; p = p-&gt;next) n++;\nauto dummy = new ListNode();\ndummy-&gt;next = head;\n</code></pre> <ul> <li>Counts the total number of nodes in the list.</li> <li>Creates a dummy node to simplify edge cases.</li> </ul> <p>Outer Loop - Sublist Size Doubling</p> <pre><code>for (int i = 1; i &lt; n; i *= 2) {\n    auto curr = dummy;\n    for (int j = 1; j + i &lt;= n; j += i * 2) {\n</code></pre> <ul> <li><code>i</code> represents the size of the sublists to be merged, starting from 1 and doubling each time.</li> <li>The outer loop iterates over the list, doubling the size of the sublists in each iteration.</li> </ul> <p>Inner Loop - Processing Each Pair of Sublists</p> <pre><code>auto p = curr-&gt;next, q = p;\nfor (int k = 0; k &lt; i; k++) q = q-&gt;next;\n</code></pre> <ul> <li><code>p</code> and <code>q</code> are pointers to the heads of the two sublists to be merged.</li> <li><code>q</code> is advanced <code>i</code> steps ahead to reach the start of the second sublist.</li> </ul> <p>Merging Two Sublists</p> <pre><code>int x = 0, y = 0;\nwhile (x &lt; i &amp;&amp; y &lt; i &amp;&amp; p &amp;&amp; q) {\n    if (p-&gt;val &lt;= q-&gt;val) {\n        curr = curr-&gt;next = p;\n        p = p-&gt;next;\n        x++;\n    } else {\n        curr = curr-&gt;next = q;\n        q = q-&gt;next;\n        y++;\n    }\n}\n</code></pre> <ul> <li>The elements of <code>p</code> and <code>q</code> are compared.</li> <li>The smaller element is appended to the sorted sublist.</li> <li>The process continues until one of the sublists is fully traversed.</li> </ul> <p>Handling Remaining Elements</p> <pre><code>while (x &lt; i &amp;&amp; p) {\n    curr = curr-&gt;next = p;\n    p = p-&gt;next;\n    x++;\n}\nwhile (y &lt; i &amp;&amp; q) {\n    curr = curr-&gt;next = q;\n    q = q-&gt;next;\n    y++;\n}\ncurr-&gt;next = q;\n</code></pre> <ul> <li>If any elements remain in either <code>p</code> or <code>q</code> sublist (i.e., one sublist was longer), they are appended to the merged list.</li> <li>After the merging of two sublists (<code>p</code> and <code>q</code>) within the inner loop, we need to ensure that the sorted list is correctly linked to the rest of the list that is yet to be processed. The line <code>curr-&gt;next = q;</code> ensures that this last node is linked to the head of the next section of the list (<code>q</code> at this point).</li> </ul>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/","title":"Evaluate Reverse Polish Notation","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#description","title":"Description","text":"<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a Reverse Polish Notation.</p> <p>Evaluate the expression. Return an integer that represents the value of the expression.</p> <p>Note that:</p> <ul> <li>The valid operators are <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, and <code>'/'</code>.</li> <li>Each operand may be an integer or another expression.</li> <li>The division between two integers always truncates toward zero.</li> <li>There will not be any division by zero.</li> <li>The input represents a valid arithmetic expression in a reverse polish notation.</li> <li>The answer and all the intermediate calculations can be represented in a 32-bit integer.</li> </ul> <p>Example 1:</p> <ul> <li>Input: <code>tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]</code></li> <li>Output: <code>9</code></li> <li>Explanation: <code>((2 + 1) * 3) = 9</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]</code></li> <li>Output: <code>6</code></li> <li>Explanation: <code>(4 + (13 / 5)) = 6</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]</code></li> <li>Output: <code>22</code></li> <li>Explanation:</li> </ul> <pre><code>((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= tokens.length &lt;= 10^4</code></li> <li><code>tokens[i]</code> is either an operator: <code>\"+\"</code>, <code>\"-\"</code>, <code>\"*\"</code>, or <code>\"/\"</code>, or an integer in the range <code>[-200, 200]</code>.</li> </ul>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#solution","title":"Solution","text":"<p>Iterate through the entire array and:</p> <ul> <li>Push each number that we meet to the stack;</li> <li>If we meet operation token - pop two numbers from the stack and evaluate the operation;</li> <li>Push the result of our operation back to the stack.</li> </ul>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#original-solution","title":"Original Solution","text":"<pre><code>class Solution {\n    public:\n        bool isInteger(const string&amp; str) {\n            if (str.empty()) return false;\n            string::size_type sz;\n            try {\n                int num = stoll(str, &amp;sz);\n                return sz == str.size();\n            } catch (const invalid_argument&amp; e) {\n                return false;\n            } catch (const std::out_of_range&amp; e) {\n                return false;\n            }\n        }\n\n        int evalRPN(vector&lt;string&gt;&amp; tokens) {\n            stack&lt;int&gt; stk;\n            for (auto &amp;c : tokens) {\n                if (isInteger(c)) stk.push(stoll(c));\n                else if (!stk.empty()) {\n                    auto num1 = stk.top();\n                    stk.pop();\n                    auto num2 = stk.top();\n                    stk.pop();\n                    if (c == \"+\") stk.push(num1 + num2);\n                    else if (c == \"-\") stk.push(num2 - num1);\n                    else if (c == \"*\") stk.push(num1 * num2);\n                    else stk.push(num2 / num1);\n                }\n            }\n            return stk.top();\n        }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#easier-way-of-writing","title":"Easier Way of Writing","text":"<pre><code>class Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        stack&lt;int&gt; stk;\n        for (auto &amp;s : tokens) {\n            if (s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\") {\n                auto num1 = stk.top(); stk.pop();\n                auto num2 = stk.top(); stk.pop();\n                if (s == \"+\") num2 += num1;\n                else if (s == \"-\") num2 -= num1;\n                else if (s == \"*\") num2 *= num1;\n                else num2 /= num1;\n                stk.push(num2);\n            } else stk.push(stoi(s));\n        }\n        return stk.top();\n    }\n};\n</code></pre> <p>Note: The Polish postfix notation is similar to the post-ordering of a binary tree consisting of all the operators and operands.</p>"},{"location":"Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#other-easy-ways-of-writing","title":"Other Easy Ways of Writing","text":"<p>Fancy way 1:</p> <pre><code>class Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        unordered_map&lt;string, function&lt;int (int, int)&gt; &gt; mapping = {\n            { \"+\", [] (int a, int b) {return a + b; } },\n            { \"-\", [] (int a, int b) {return a - b; } },\n            { \"*\", [] (int a, int b) {return a * b; } },\n            { \"/\", [] (int a, int b) {return a / b; } }\n        };\n\n        stack&lt;int&gt; stk;\n        for (auto &amp;s : tokens) {\n            if (!mapping.count(s)) stk.push(stoi(s));\n            else {\n                auto b = stk.top(); stk.pop();\n                auto a = stk.top(); stk.pop();\n                stk.push(mapping[s](a, b));\n            }\n        }\n        return stk.top();\n    }\n};\n</code></pre> <p>Fancy way 2:</p> <pre><code>int evalRPN(vector&lt;string&gt;&amp; tokens) {\n    stack&lt;int&gt; s;\n    unordered_map&lt;string, function&lt;int(int,int)&gt;&gt; mapping {\n        { \"+\", std::plus&lt;int&gt;() },\n        { \"-\", std::minus&lt;int&gt;() },\n        { \"*\", std::multiplies&lt;int&gt;() },\n        { \"/\", std::divides&lt;int&gt;() }\n    };\n\n    for (const auto&amp; token : tokens) {\n        const auto&amp; op = mapping.find(token);\n        if (op != mapping.end()) {\n            assert(s.size() &gt;= 2);\n            int rhs = s.top(); s.pop();\n            int lhs = s.top(); s.pop();\n            s.push((*op).second(lhs, rhs));\n        } else {\n            s.push(stoi(token));\n        }\n    }\n\n    assert(s.size() == 1);\n    return s.top();\n}\n</code></pre> <p>Fancy way 3:</p> <pre><code>class Solution {\npublic:\n    // Function to evaluate Reverse Polish Notation\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        // Lambda function to return the appropriate arithmetic operation\n        // based on the operator character.\n        constexpr auto eval = [](char op) -&gt; function&lt;int(int, int)&gt; {\n            switch (op) {\n                case '+': return plus&lt;&gt;();      // For addition\n                case '-': return minus&lt;&gt;();     // For subtraction\n                case '*': return multiplies&lt;&gt;();// For multiplication\n                case '/': return divides&lt;&gt;();   // For division\n                default: return nullptr;        // For invalid operators\n            }\n        };\n\n        stack&lt;int&gt; stk; // Stack to store integers\n\n        // Iterate over each token in the input vector\n        for (const auto &amp;str : tokens) {\n            // Check if the token is an operator\n            if (str.length() == 1 &amp;&amp; eval(str[0])) {\n                const auto rhs = stk.top(); stk.pop(); // Right-hand side operand\n                const auto lhs = stk.top(); stk.pop(); // Left-hand side operand\n\n                // Apply the operation and push the result back onto the stack\n                stk.push(eval(str[0])(lhs, rhs));\n            } else {\n                // If the token is a number, convert it to an integer and push onto the stack\n                stk.push(stoi(str));\n            }\n        }\n        // Return the top element of the stack, which is the final result\n        return stk.top();\n    }\n};\n</code></pre> <p>Grammar and Concepts Used:</p> <ul> <li>Lambda Functions: Anonymous functions used for defining the eval function inline.</li> <li>Stack: A LIFO (Last In, First Out) data structure used for storing operands.</li> <li>Auto Keyword: For type inference in C++.</li> <li>Range-based For Loop: To iterate over each element in the tokens vector.</li> <li>Function Objects: Standard library function objects for arithmetic operations.</li> <li>Ternary Operator: Used in the lambda function for concise conditional logic.</li> <li>Constexpr: Indicates that the value of a variable or function can be evaluated at compile time.</li> </ul>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/","title":"Reverse Words in a String","text":"<ul> <li>Reverse Words in a String</li> <li>Description</li> <li>Solution<ul> <li>Original Solution Using Library Functions</li> <li>Code</li> <li>Detailed complexity analysis<ul> <li>Overall Time Complexity Analysis</li> <li>Overall Space Complexity Analysis</li> <li>Summarization: Complexity of C++ Standard Library Functions</li> </ul> </li> <li>Solution Implementing the Function Ourselves</li> <li>Way 1</li> <li>Way 2 (Recommended)</li> <li>Python Solution</li> <li>Function Breakdown</li> <li>Time Complexity Analysis</li> <li>Space Complexity Analysis</li> </ul> </li> </ul> <p>Link</p>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#description","title":"Description","text":"<p>Given an input string <code>s</code>, reverse the order of the words.</p> <p>A word is defined as a sequence of non-space characters. The words in <code>s</code> will be separated by at least one space.</p> <p>Return a string of the words in reverse order concatenated by a single space.</p> <p>Note that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"the sky is blue\"</code></li> <li>Output: <code>\"blue is sky the\"</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"  hello world  \"</code></li> <li>Output: <code>\"world hello\"</code></li> <li>Explanation: Your reversed string should not contain leading or trailing spaces.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>s = \"a good   example\"</code></li> <li>Output: <code>\"example good a\"</code></li> <li>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^4</code></li> <li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>' '</code>.</li> <li>There is at least one word in <code>s</code>.</li> </ul>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#original-solution-using-library-functions","title":"Original Solution Using Library Functions","text":""},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    string reverseWords(string s) {\n        size_t start = s.find_first_not_of(\" \");\n        size_t end = s.find_last_not_of(\" \");\n\n        if (start == string::npos) return \"\";\n\n        s = s.substr(start, end - start + 1);\n\n        vector&lt;string&gt; words;\n        string word;\n        istringstream tokenStream(s);\n        while (tokenStream &gt;&gt; word) {\n            words.push_back(word);\n        }\n\n        reverse(words.begin(), words.end());\n\n        string result;\n        for (size_t i = 0; i &lt; words.size(); i++) {\n            result += words[i];\n            if (i &lt; words.size() - 1) result += \" \";\n        }\n        return result;\n    }\n};\n</code></pre> <p>Full testing code:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstd::string reverseWords(std::string s) {\n    // Step 1: Trim leading and trailing spaces\n    size_t start = s.find_first_not_of(\" \");\n    size_t end = s.find_last_not_of(\" \");\n\n    // Handle the case where the string contains only spaces\n    if (start == std::string::npos) return \"\";\n\n    // Trim the string\n    s = s.substr(start, end - start + 1);\n\n    // Step 2: Split the string into words\n    std::istringstream iss(s);\n    std::vector&lt;std::string&gt; words;\n    std::string word;\n    while (iss &gt;&gt; word) {\n        words.push_back(word);\n    }\n\n    // Step 3: Reverse the words\n    std::reverse(words.begin(), words.end());\n\n    // Step 4: Concatenate the words\n    std::string result;\n    for (size_t i = 0; i &lt; words.size(); ++i) {\n        result += words[i];\n        if (i &lt; words.size() - 1) {\n            result += \" \";  // Add a space between words\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::string s1 = \"the sky is blue\";\n    std::string s2 = \"  hello world  \";\n    std::string s3 = \"a good   example\";\n\n    std::cout &lt;&lt; reverseWords(s1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; reverseWords(s2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; reverseWords(s3) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p><code>iss &gt;&gt; word</code> is an extraction operation that reads data from <code>iss</code> and stores it in <code>word</code>. It automatically splits the input based on whitespace (spaces, tabs, newlines).</p>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#detailed-complexity-analysis","title":"Detailed complexity analysis","text":""},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#overall-time-complexity-analysis","title":"Overall Time Complexity Analysis","text":"<ol> <li>Trimming Spaces:</li> <li>The functions <code>find_first_not_of</code> and <code>find_last_not_of</code> both run in linear time, \\(O(N)\\), where \\(N\\) is the length of the string <code>s</code>.</li> <li>The <code>substr</code> operation is also \\(O(N)\\), as it potentially needs to copy the entire string.</li> <li>Splitting the String into Words:</li> <li>The <code>istringstream</code> constructor and the loop that reads words both operate in \\(O(N)\\) time. Each character is read and processed once to split the string into words.</li> <li>Reversing the Words:</li> <li>The <code>reverse</code> function operates in \\(O(\\frac{W}{2})\\), where W is the number of words. In terms of Big O notation, this simplifies to \\(O(W)\\).</li> <li>Concatenating the Words:</li> <li>The loop for concatenating words runs in \\(O(W)\\), as it iterates over all words. However, the string concatenation inside the loop (<code>result += words[i]</code>) has its own complexity. In the worst case, each concatenation can be \\(O(N)\\) due to potential reallocation and copying of the entire string. Thus, this step could be as bad as \\(O(WN)\\).</li> </ol>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#overall-space-complexity-analysis","title":"Overall Space Complexity Analysis","text":"<ol> <li>Additional String Storage:</li> <li>The <code>substr</code> operation creates a new string, which is \\(O(N)\\) in space.</li> <li>Storing Words:</li> <li>The <code>vector&lt;string&gt;</code> <code>words</code> stores each word separately. In the worst case, if the string is composed entirely of single-character words separated by spaces, the number of words will be approximately \\(\\frac{N}{2}\\) (every other character is a space), leading to a space complexity of \\(O(N)\\).</li> <li>Intermediate String Storage:</li> <li>The <code>result</code> string, in the worst case, will hold the entire input string in reverse order, which is \\(O(N)\\).</li> </ol>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#summarization-complexity-of-c-standard-library-functions","title":"Summarization: Complexity of C++ Standard Library Functions","text":"<ul> <li><code>find_first_not_of</code>, <code>find_last_not_of</code>: \\(O(N)\\)</li> <li><code>substr</code>: \\(O(N)\\) for copying the substring.</li> <li><code>istringstream</code>: The construction is \\(O(N)\\) as it copies the string.</li> <li><code>istringstream::operator&gt;&gt;</code>: \\(O(N)\\) overall for reading the entire string.</li> <li><code>vector::push_back</code>: Amortized \\(O(1)\\) for each call, but can lead to occasional resizing, which is \\(O(N)\\) for that operation.</li> <li><code>reverse</code>: \\(O(\\frac{W}{2})\\) which simplifies to \\(O(W)\\).</li> <li>String concatenation (<code>+=</code>): \\(O(N)\\) in the worst case for each operation due to potential reallocation and copying.</li> </ul> <p>The overall time complexity of the implementation is dominated by the string splitting and concatenation steps, both of which can approach \\(O(N^2)\\) in the worst case due to the way strings are handled in C++. The space complexity is primarily \\(O(N)\\), driven by the storage of the words and the final result string.</p>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#solution-implementing-the-function-ourselves","title":"Solution Implementing the Function Ourselves","text":""},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#way-1","title":"Way 1","text":"<p>The entire string is reversed first, and then each word is reversed back internally.</p> <pre><code>class Solution {\npublic:\n    // Reversing strings; interval: left-closed right-closed []\n    void myReverse(string &amp;s, int start, int end) {\n        for (int i = start, j = end; i &lt; j; i++, j--)\n            swap(s[i], s[j]);\n    }\n\n    // Remove all spaces and add spaces between neighboring words\n    // using fast and slow pointers\n    void removeExtraSpace(string &amp;s) {\n        int slow = 0;\n        for (int i = 0; i &lt; s.size(); i++) {\n            // Handle non-spaces as they are encountered, i.e., remove all spaces\n            if (s[i] != ' ') {\n                // Manually control spaces by adding spaces between words;\n                // slow ! = 0 means that it is not the first word \n                // and a space needs to be added before the word\n                if (slow != 0) s[slow++] = ' ';\n                // Fill in the word \n                // and a space indicates the end of the word\n                while (i &lt; s.size() &amp;&amp; s[i] != ' ') s[slow++] = s[i++];\n            }\n        }\n        // size of slow is the size of the string after removing the extra spaces\n        s.resize(slow); \n    }\n\n    string reverseWords(string s) {\n        // Remove extra spaces, \n        // make sure there is only one space between words \n        // and no space at the beginning and end of the string.\n        removeExtraSpace(s);\n        myReverse(s, 0, s.size() - 1);\n        // RemoveExtraSpace guarantees that the first word \n        // must start with a 0 subscript.\n        int start = 0;\n        // It is i &lt;= s.size() here!\n        for (int i = 0; i &lt;= s.size(); i++) {\n            // Reaching a space or the end of a string indicates the end of a word;\n            // Perform a reversal\n            if (i == s.size() || s[i] == ' ') {\n                // Reversal. Note that it's a left-closed right-closed [] flip\n                myReverse(s, start, i - 1);\n                // Update the start subscript of the next word start\n                start = i + 1;\n            }\n        }\n        return s;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\) for C++.</li> </ul>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#way-2-recommended","title":"Way 2 (Recommended)","text":"<p>Flip each word internally first, then reverse the entire string back.</p> <pre><code>class Solution {\npublic:\n    string reverseWords(string s) {\n        int slow = 0; // Initialize a 'slow' pointer\n\n        for (int i = 0; i &lt; s.size(); i++) {\n            if (s[i] == ' ') continue; // Skip spaces\n\n            // Find the start and end of the next word\n            int j = i, t = slow;\n            while (j &lt; s.size() &amp;&amp; s[j] != ' ') s[t++] = s[j++];\n            // Reverse the word in-place\n            reverse(s.begin() + slow, s.begin() + t);\n\n            // Add a space after the word and update pointers\n            s[t++] = ' ';\n            slow = t;\n            i = j; // Jump to the end of the word\n        }\n\n        // Remove the last space if the string is not empty\n        if (slow) slow--;\n        // Erase the trailing spaces\n        s.erase(s.begin() + slow, s.end());\n        // Reverse the entire string to get words in reverse order\n        reverse(s.begin(), s.end());\n\n        return s;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#python-solution","title":"Python Solution","text":"<pre><code>class Solution:\n    def reverseWords(self, s: str) -&gt; str:\n        return ' '.join(s.strip().split()[::-1])\n</code></pre>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#function-breakdown","title":"Function Breakdown","text":"<ol> <li><code>s.strip()</code>:</li> <li><code>strip()</code> is a string method in Python that removes any leading and trailing whitespace (including spaces, newlines, and tabs) from the string <code>s</code>.</li> <li>For instance, <code>\"  hello world  \".strip()</code> would result in <code>\"hello world\"</code>.</li> <li><code>split()</code>:</li> <li><code>split()</code> is a method that divides a string into a list of substrings, separated by the specified separator. By default, it splits based on any whitespace and removes it.</li> <li>For example, <code>\"hello   world\".split()</code> results in <code>[\"hello\", \"world\"]</code>.</li> <li><code>[::-1]</code>:</li> <li>This is a slicing operation that reverses the list. <code>[::-1]</code> means start at the end of the list and end at position 0, move with the step -1 (one step backward).</li> <li>For a list <code>[\"hello\", \"world\"]</code>, the result of <code>[::-1]</code> would be <code>[\"world\", \"hello\"]</code>.</li> <li><code>' '.join(...)</code>:</li> <li><code>join()</code> is a string method used to join elements of an iterable (like a list) into a single string, with the specified string as a separator. Here, it uses a space <code>' '</code> as the separator.</li> <li>For example, <code>' '.join([\"world\", \"hello\"])</code> would result in <code>\"world hello\"</code>.</li> </ol> <p>Putting it all together, this one-liner first removes leading and trailing spaces from the input string, splits the string into words, reverses the list of words, and then joins them back into a single string with spaces in between.</p>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#time-complexity-analysis","title":"Time Complexity Analysis","text":"<ol> <li>Strip Operation: \\(O(N)\\), where \\(N\\) is the length of the string. This is because it potentially needs to check each character at both ends of the string.</li> <li>Split Operation: \\(O(N)\\), as it goes through the entire string to split it into words.</li> <li>List Reversal: \\(O(W)\\), where \\(W\\) is the number of words in the string. This is typically considered a linear operation with respect to the number of elements in the list.</li> <li>Join Operation: \\(O(N)\\), as it has to combine all the words back into a single string.</li> </ol> <p>The overall time complexity of the function is \\(O(N)\\), as each character in the string is processed a constant number of times.</p>"},{"location":"Leetcode/0100-0199/0151-reverse-words-in-a-string/#space-complexity-analysis","title":"Space Complexity Analysis","text":"<p>Intermediate Lists and Strings: The space complexity is mainly due to the storage of the split words and the final string. This would be \\(O(N)\\), as in the worst case, the number of words and the total length of the words (including the spaces in the final joined string) can be proportional to the length of the original string.</p>"},{"location":"Leetcode/0100-0199/0160-intersection-of-two-linked-lists/","title":"Intersection of Two Linked Lists","text":"<p>Link</p>"},{"location":"Leetcode/0100-0199/0160-intersection-of-two-linked-lists/#description","title":"Description","text":"<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return <code>null</code>.</p> <p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p> <p>Note that the linked lists must retain their original structure after the function returns.</p> <p>Custom Judge:</p> <p>The inputs to the judge are given as follows (your program is not given these inputs):</p> <ul> <li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li> <li><code>listA</code> - The first linked list.</li> <li><code>listB</code> - The second linked list.</li> <li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li> <li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li> </ul> <p>The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.</p> <p>Example 1:</p> <ul> <li>Input: <code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</code></li> <li>Output: Intersected at '8'</li> <li>Explanation:</li> <li>The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as <code>[4,1,8,4,5]</code>. From the head of B, it reads as <code>[5,6,1,8,4,5]</code>. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</li> <li>Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</code></li> <li>Output: Intersected at '2'</li> <li>Explanation:</li> <li>The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).</li> <li>From the head of A, it reads as <code>[1,9,1,2,4]</code>. From the head of B, it reads as <code>[3,2,4]</code>. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</code></li> <li>Output: No intersection</li> <li>Explanation:</li> <li>From the head of A, it reads as <code>[2,6,4]</code>. From the head of B, it reads as <code>[1,5]</code>. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</li> <li>Explanation: The two lists do not intersect, so return null.</li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li> <li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li> <li><code>1 &lt;= m, n &lt;= 3 * 10^4</code></li> <li><code>1 &lt;= Node.val &lt;= 10^5</code></li> <li><code>0 &lt;= skipA &lt; m</code></li> <li><code>0 &lt;= skipB &lt; n</code></li> <li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li> <li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li> </ul>"},{"location":"Leetcode/0100-0199/0160-intersection-of-two-linked-lists/#solution","title":"Solution","text":""},{"location":"Leetcode/0100-0199/0160-intersection-of-two-linked-lists/#classical-solution","title":"Classical Solution","text":"<ol> <li>Given two linked lists, <code>currA</code> points to the head of list A and <code>currB</code> points to the head of list B.</li> <li>We find the lengths of the two lists, and the difference between the two lists, and then we move <code>currA</code> to a position where it is aligned with the end of <code>currB</code>.</li> <li>At this point we can compare <code>currA</code> and <code>currB</code> to see if they are the same, if they are not the same, we move <code>currA</code> and <code>currB</code> backward at the same time, and if we encounter <code>currA == currB</code>, then we find the intersection point.</li> <li>Otherwise, the loop exits and returns the null pointer.</li> </ol> <pre><code>// Definition for singly-linked list.\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // Initialize pointers for traversing both lists\n        ListNode *currA = headA;\n        ListNode *currB = headB;\n\n        // Variables to store the lengths of both lists\n        int lenA = 0, lenB = 0;\n        // Calculate the length of list A\n        while (currA) {\n            lenA++;\n            currA = currA-&gt;next;\n        }\n        // Calculate the length of list B\n        while (currB) {\n            lenB++;\n            currB = currB-&gt;next;\n        }\n\n        // Reset the pointers to the heads of the lists\n        currA = headA;\n        currB = headB;\n\n        // NOTE: Ensure that currA points to the longer list\n        if (lenB &gt; lenA) {\n            swap(lenA, lenB);\n            swap(currA, currB);\n        }\n\n        // Calculate the difference in lengths\n        int gap = lenA - lenB;\n        // Advance the pointer in the longer list by the difference in lengths\n        while (gap--) {\n            currA = currA-&gt;next;\n        }\n\n        // Traverse both lists in tandem until an intersection is found or end of lists is reached\n        while (currA) {\n            if (currA == currB) {\n                return currA; // Intersection node found\n            }\n            currA = currA-&gt;next;\n            currB = currB-&gt;next;\n        }\n\n        // No intersection found\n        return nullptr;\n    }\n};\n</code></pre> <p>If one list is longer than the other, the algorithm advances the pointer in the longer list by the difference in lengths. This ensures that when you traverse both lists in the following steps, you traverse an equal number of nodes until the end of the lists.</p> <ul> <li>Time complexity: \\(O(n+m)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0100-0199/0160-intersection-of-two-linked-lists/#more-elegant-way","title":"More Elegant Way","text":"<p>Algorithm steps:</p> <ul> <li>Scan with two pointers starting at the head of each of the two linked lists, taking one step each time;</li> <li>If the pointers go to <code>null</code>, start from the head of the other linked table;</li> <li>When the two pointers are the same:</li> <li>If the pointer is not <code>null</code>, the pointer position is the meeting point;</li> <li>If the pointer is <code>null</code>, the two linked lists do not intersect.</li> </ul> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        auto p = headA, q = headB;\n        while (p != q) {\n            p = p ? p-&gt;next : headB;\n            q = q ? q-&gt;next : headA;\n        }\n        return p;\n    }\n};\n</code></pre> <p></p> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // Initialize two pointers, p and q, for each list\n        auto p = headA, q = headB;\n\n        // Continue looping until both pointers either meet or reach the end (nullptr)\n        while (p != q) {\n            // Move p to the next node in list A, or to the head of list B if it reaches the end\n            p = p ? p-&gt;next : headB;\n            // Move q to the next node in list B, or to the head of list A if it reaches the end\n            q = q ? q-&gt;next : headA;\n        }\n        // When p and q meet, it's the intersection node or nullptr if there's no intersection\n        return p;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0200-number-of-islands/","title":"Number of Islands","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0200-number-of-islands/#description","title":"Description","text":"<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>'1'</code>s (land) and <code>'0'</code>s (water), return the number of islands.</p> <p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p> <p>Example 1:</p> <ul> <li>Input:</li> </ul> <pre><code>grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n</code></pre> <ul> <li>Output: <code>1</code></li> </ul> <p>Example 2:</p> <ul> <li>Input:</li> </ul> <pre><code>grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n</code></pre> <ul> <li>Output: <code>3</code></li> </ul> <p>Constraints:</p> <ul> <li><code>m == grid.length</code></li> <li><code>n == grid[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 300</code></li> <li><code>grid[i][j]</code> is <code>'0'</code> or <code>'1'</code>.</li> </ul>"},{"location":"Leetcode/0200-0299/0200-number-of-islands/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    int n, m;\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int x, int y) {\n        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return;\n        if (grid[x][y] == '0') return;\n        grid[x][y] = '0';\n        dfs(grid, x + 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y - 1);\n    }\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        int res = 0;\n        n = grid.size(), m = grid[0].size();\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>See reference (Chinese).</p> <ul> <li>Time complexity: \\(O(nm)\\);</li> <li>Space complexity: \\(O(nm)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0202-happy-number/","title":"Happy Number","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0202-happy-number/#description","title":"Description","text":"<p>Write an algorithm to determine if a number <code>n</code> is happy.</p> <p>A happy number is a number defined by the following process:</p> <ul> <li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li> <li>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> <li>Those numbers for which this process ends in 1 are happy.</li> </ul> <p>Return <code>true</code> if <code>n</code> is a happy number, and <code>false</code> if not.</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 19</code></li> <li>Output: <code>true</code></li> </ul> <p>Explanation:</p> <pre><code>12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>n = 2</code></li> <li>Output: <code>false</code></li> </ul> <p>Constraints: <code>1 &lt;= n &lt;= 2^31 - 1</code></p>"},{"location":"Leetcode/0200-0299/0202-happy-number/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0202-happy-number/#hash-set","title":"Hash Set","text":"<p>The question says it will be an infinite loop, so that means the sum will be repeated during the summation process, which is important for solving the problem. When we encountered to quickly determine whether an element occurs in the set, we have to consider the hash method. So this question uses the hash method, to determine whether the sum is repeated, if repeated is return false, otherwise, keep looking for, until the sum is 1. To determine whether the sum is repeated or not, just use <code>unordered_set</code>.</p> <pre><code>class Solution {\npublic:\n    // get the sum of square for all digits of the given number \n    int getSum(int n) {\n        int sum = 0;\n        while (n) {\n            sum += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n    bool isHappy(int n) {\n        unordered_set&lt;int&gt; S;\n        while (true) {\n            int sum = getSum(n);\n            if (sum == 1) return true;\n            // if this \"sum\" has occurred before, it means that we have encounter the infinite loop\n            if (S.find(sum) != S.end()) {\n                return false;\n            } else {\n                S.insert(sum);\n            }\n            n = sum;\n        }\n    }\n};\n</code></pre> <p>Time and space complexity: \\(O(\\log n)\\)</p>"},{"location":"Leetcode/0200-0299/0202-happy-number/#double-pointer","title":"Double Pointer","text":"<p>This problem is actually a wrapped circular chained table, where:</p> <ul> <li>A slow pointer sums the squares once for each digit.</li> <li>A fast pointer is one that sums the squares of the numbers twice each time.</li> </ul> <p>There are two cases:</p> <ul> <li>Happy number: the last two pointers will be 1, and they will merge together.</li> <li>Not a happy number: it is equivalent to a circle, where the fast and slow pointers always meet at a certain number.</li> </ul> <p>i.e., whether it is a happy number or not, the fast and slow pointers will eventually converge on a number, and we only need to determine whether this number is 1 or not.</p> <pre><code>class Solution {\npublic:\n    // get the sum of square for all digits of the given number \n    int getSum(int n) {\n        int sum = 0;\n        while (n) {\n            sum += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n    bool isHappy(int n) {\n        int fast = getSum(n), slow = n;\n        while (fast != slow) {\n            fast = getSum(getSum(fast));\n            slow = getSum(slow);\n        }\n        return fast == 1;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0203-remove-linked-list-elements/","title":"Remove Linked List Elements","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0203-remove-linked-list-elements/#description","title":"Description","text":"<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return the new head.</p> <p>Example:</p> <ul> <li>Input: <code>head = [1,2,6,3,4,5,6], val = 6</code></li> <li>Output: <code>[1,2,3,4,5]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [], val = 1</code></li> <li>Output: <code>[]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = [7,7,7,7], val = 7</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[0, 10^4]</code>.</li> <li><code>1 &lt;= Node.val &lt;= 50</code></li> <li><code>0 &lt;= val &lt;= 50</code></li> </ul>"},{"location":"Leetcode/0200-0299/0203-remove-linked-list-elements/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0203-remove-linked-list-elements/#solution-1","title":"Solution 1","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        // NOTE!!! use \"while\" here! (not \"if\")\n        while (head != NULL &amp;&amp; head-&gt;val == val) {\n            ListNode *temp = head;\n            head = head-&gt;next;\n            delete temp;\n        }\n\n        ListNode *current = head;\n        while (current != NULL &amp;&amp; current-&gt;next != NULL) {\n            if (current-&gt;next-&gt;val == val) {\n                ListNode *temp = current-&gt;next;\n                current-&gt;next = current-&gt;next-&gt;next;\n                delete temp;\n            } else {\n                current = current-&gt;next;\n            }\n        }\n\n        return head;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"Leetcode/0200-0299/0203-remove-linked-list-elements/#solution-2-recommended-dummy-head-node","title":"Solution 2 (Recommended): Dummy Head Node","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead-&gt;next = head;\n\n        ListNode* current = dummyHead;\n        while (current-&gt;next != NULL) {\n            if (current-&gt;next-&gt;val == val) {\n                ListNode *temp = current-&gt;next;\n                current-&gt;next = current-&gt;next-&gt;next;\n                delete temp;\n            } else {\n                current = current-&gt;next;\n            }\n        }\n\n        // NOTE!!! Do not return head directly (because head may have been deleted)\n        head = dummyHead-&gt;next;\n        delete dummyHead;\n        return head;\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        auto dummy = new ListNode(-1);\n        dummy-&gt;next = head;\n        for (auto p = dummy; p; p = p-&gt;next) {\n            auto cur = p-&gt;next;\n            while (cur &amp;&amp; cur-&gt;val == val) cur = cur-&gt;next;\n            p-&gt;next = cur;\n        }\n        return dummy-&gt;next;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/","title":"Reverse Linked List","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#description","title":"Description","text":"<p>Given the <code>head</code> of a singly linked list, reverse the list, and return the reversed list.</p> <p>Example 1:</p> <ul> <li>Input: <code>head = [1,2,3,4,5]</code></li> <li>Output: <code>[5,4,3,2,1]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>head = [1,2]</code></li> <li>Output: <code>[2,1]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>head = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li> <li><code>-5000 &lt;= Node.val &lt;= 5000</code></li> </ul>"},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#double-pointer","title":"Double Pointer","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *curr = head;\n        ListNode *prev = nullptr;\n        while (curr) {\n            ListNode *original_next = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = original_next;\n        }\n        return prev;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#recursion","title":"Recursion","text":""},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#way-1-flip-the-pointer-from-front-to-back","title":"Way 1: Flip the pointer from front to back","text":"<pre><code>class Solution {\npublic:\n    ListNode* reverse(ListNode *prev, ListNode *curr) {\n        if (curr == nullptr) return prev;\n        ListNode *temp = curr-&gt;next;\n        curr-&gt;next = prev;\n        // prev = curr;\n        // curr = temp;\n        return reverse(curr, temp);\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        return reverse(nullptr, head);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0206-reverse-linked-list/#way-2-flip-the-pointer-from-back-to-front","title":"Way 2: Flip the pointer from back to front","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (!head || !head-&gt;next) return head;\n        ListNode *tail = reverseList(head-&gt;next);\n        head-&gt;next-&gt;next = head;\n        head-&gt;next = nullptr;\n        return tail;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>Base Case: The function checks if the <code>head</code> is <code>nullptr</code> (empty list) or if <code>head-&gt;next</code> is <code>nullptr</code> (single node list). In either case, the <code>head</code> is returned as it is, as there is nothing to reverse.</li> <li>Recursive Call: If the list contains more than one node, the function makes a recursive call with the next node (<code>head-&gt;next</code>). This process continues until the function reaches the end of the list.</li> <li>Reversing the Links: Once the end of the list is reached (base case), the function backtracks, reversing the links as it goes. This is done by setting the <code>next</code> pointer of the next node to point back to the current node (<code>head-&gt;next-&gt;next = head</code>).</li> <li>Avoiding Cycles: The current node's <code>next</code> pointer is set to <code>nullptr</code> to avoid cycles. This is necessary because, in the last reversal step, the new tail of the list (which was the original head) must point to <code>nullptr</code>.</li> <li>Returning New Head: The function eventually returns the <code>tail</code> node, which is the new head of the reversed list.</li> </ul> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Base case: if the list is empty or has only one node, return the head as it is\n        if (!head || !head-&gt;next) return head;\n        /*\n        // We can also write the code above as:\n        if (head == NULL) return NULL;\n        if (head-&gt;next == NULL) return head;\n        */\n\n        // Recursively call reverseList on the next node\n        // This call goes deeper until it reaches the end of the list\n        auto tail = reverseList(head-&gt;next);\n\n        // After reaching the end, the function starts to backtrack,\n        // setting the next node's next pointer to the current node\n        // This effectively reverses the direction of the link\n        head-&gt;next-&gt;next = head;\n\n        // Set the current node's next pointer to nullptr to avoid cycles\n        // As we backtrack further, the previous node will set this correctly\n        head-&gt;next = nullptr;\n\n        // Return the new head of the reversed list (which is the original tail)\n        return tail;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0208-implement-trie-prefix-tree/","title":"Implement Trie (Prefix Tree)","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0208-implement-trie-prefix-tree/#description","title":"Description","text":"<p>A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p> <p>Implement the Trie class:</p> <ul> <li><code>Trie()</code> Initializes the trie object.</li> <li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li> <li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and false otherwise.</li> <li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li> </ul> <p>Example 1:</p> <ul> <li>Input:</li> </ul> <pre><code>[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n</code></pre> <ul> <li>Output:</li> </ul> <pre><code>[null, null, true, false, true, null, true]\n</code></pre> <ul> <li>Explanation:</li> </ul> <pre><code>Trie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li> <li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li> <li>At most <code>3 * 10^4</code> calls in total will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li> </ul>"},{"location":"Leetcode/0200-0299/0208-implement-trie-prefix-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0208-implement-trie-prefix-tree/#way-1","title":"Way 1","text":"<pre><code>class Trie {\nprivate:\n    const static int N = 31010;\n    int son[N][26] {0};\n    int cnt[N] {0};\n    int idx = 0;\npublic:\n    Trie() {\n\n    }\n\n    void insert(string word) {\n        int p = 0;\n        for (char ch : word) {\n            int u = ch - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n        }\n        cnt[p]++;\n    }\n\n    bool search(string word) {\n        int p = 0;\n        for (char ch : word) {\n            int u = ch - 'a';\n            if (!son[p][u]) return false;\n            p = son[p][u];\n        }\n        return cnt[p] &gt; 0;\n    }\n\n    bool startsWith(string prefix) {\n        int p = 0;\n        for (char ch : prefix) {\n            int u = ch - 'a';\n            if (!son[p][u]) return false;\n            p = son[p][u];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj-&gt;insert(word);\n * bool param_2 = obj-&gt;search(word);\n * bool param_3 = obj-&gt;startsWith(prefix);\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0208-implement-trie-prefix-tree/#way-2","title":"Way 2","text":"<pre><code>class Trie {\nprivate:\n    struct Node {\n        bool is_tail;\n        Node *son[26];\n        Node() {\n            is_tail = false;\n            for (int i = 0; i &lt; 26; i++) son[i] = nullptr;\n        }\n        ~Node() {\n            for (int i = 0; i &lt; 26; i++) delete son[i];\n        }\n    } *root;\npublic:\n    Trie() {\n        root = new Node();\n    }\n\n    ~Trie() {\n        delete root;\n    }\n\n    void insert(string word) {\n        auto p = root;\n        for (auto ch : word) {\n            int u = ch - 'a';\n            if (!p-&gt;son[u]) p-&gt;son[u] = new Node();\n            p = p-&gt;son[u];\n        }\n        p-&gt;is_tail = true;\n    }\n\n    bool search(string word) {\n        auto p = root;\n        for (auto ch : word) {\n            int u = ch - 'a';\n            if (!p-&gt;son[u]) return false;\n            p = p-&gt;son[u];\n        }\n        return p-&gt;is_tail;\n    }\n\n    bool startsWith(string prefix) {\n        auto p = root;\n        for (auto ch : prefix) {\n            int u = ch - 'a';\n            if (!p-&gt;son[u]) return false;\n            p = p-&gt;son[u];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj-&gt;insert(word);\n * bool param_2 = obj-&gt;search(word);\n * bool param_3 = obj-&gt;startsWith(prefix);\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0209-minimum-size-subarray-sum/","title":"Minimum Size Subarray Sum","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0209-minimum-size-subarray-sum/#description","title":"Description","text":"<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a subarray (A subarray is a contiguous non-empty sequence of elements within an array) whose sum is greater than or equal to <code>target</code>. If there is no such subarray, return 0 instead.</p> <p>Example 1:</p> <ul> <li>Input: <code>target = 7, nums = [2,3,1,2,4,3]</code></li> <li>Output: 2</li> </ul> <p>Explanation: The subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p> <p>Example 2:</p> <ul> <li>Input: <code>target = 4, nums = [1,4,4]</code></li> <li>Output: 1</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>target = 11, nums = [1,1,1,1,1,1,1,1]</code></li> <li>Output: 0</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= target &lt;= 10^9</code></li> <li><code>1 &lt;= nums.length &lt;= 10^5</code></li> <li><code>1 &lt;= nums[i] &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0200-0299/0209-minimum-size-subarray-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0209-minimum-size-subarray-sum/#sliding-window-double-pointer","title":"Sliding Window (Double Pointer)","text":"<p><code>left</code> and <code>right</code> represent the start and end of the sliding window, respectively. We move right forward to expand the window and add to the <code>sum</code>. When the <code>sum</code> reaches or exceeds the <code>target</code>, we update the minimum length and shrink the window from the left by incrementing <code>left</code> and subtracting that element from the sum. This process repeats until <code>right</code> has traversed the entire array.</p> <pre><code>class Solution {\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {\n        int minLength = INT_MAX;\n        int left = 0, sum = 0;\n        for (int right = 0; right &lt; nums.size(); right++) {\n            sum += nums[right];\n            // Check if the current window sum is at least the target\n            while (sum &gt;= target) {\n                minLength = min(minLength, right - left + 1);\n                // Shrink the window from the left, subtracting that element from the sum\n                sum -= nums[left++];\n            }\n        }\n\n        // If minLength is still INT_MAX, no valid subarray was found, return 0\n        // Otherwise, return the minimum length found\n        return minLength == INT_MAX ? 0 : minLength;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0215-kth-largest-element-in-an-array/","title":"Kth Largest Element in an Array","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code>-th largest element in the array.</p> <p>Note that it is the <code>k</code>-th largest element in the sorted order, not the <code>k</code>-th distinct element.</p> <p>Can you solve it without sorting?</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [3,2,1,5,6,4], k = 2</code></li> <li>Output: <code>5</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [3,2,3,1,2,4,5,5,6], k = 4</code></li> <li>Output: <code>4</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n        for (auto num : nums) {\n            q.push(num);\n            if (q.size() &gt; k) q.pop();\n        }\n        return q.top();\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\log k)\\);</li> <li>Space complexity: \\(O(k)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#way-2","title":"Way 2","text":"<p>Quick select:</p> <pre><code>class Solution {\nprivate:\n    int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) {\n        if (l == r) return nums[l];\n        int i = l - 1, j = r + 1, x = nums[(l + r) &gt;&gt; 1];\n        while (i &lt; j) {\n            do i++; while (nums[i] &gt; x);\n            do j--; while (nums[j] &lt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        }\n        int sl = j - l + 1;\n        if (sl &gt;= k) return quick_select(nums, l, j, k);\n\n        return quick_select(nums, j + 1, r, k - sl);  // sl &lt; k\n    }\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\n        return quick_select(nums, 0, nums.size() - 1, k);\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0216-combination-sum-iii/","title":"Combination Sum III","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0216-combination-sum-iii/#description","title":"Description","text":"<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p> <ul> <li>Only numbers <code>1</code> through <code>9</code> are used.</li> <li>Each number is used at most once.</li> </ul> <p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>k = 3, n = 7</code></li> <li>Output: <code>[[1,2,4]]</code></li> <li>Explanation:<ul> <li><code>1 + 2 + 4 = 7</code></li> <li>There are no other valid combinations.</li> </ul> </li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>k = 3, n = 9</code></li> <li>Output: <code>[[1,2,6],[1,3,5],[2,3,4]]</code></li> <li>Explanation:<ul> <li><code>1 + 2 + 6 = 9</code></li> <li><code>1 + 3 + 5 = 9</code></li> <li><code>2 + 3 + 4 = 9</code></li> <li>There are no other valid combinations.</li> </ul> </li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>k = 4, n = 1</code></li> <li>Output: <code>[]</code></li> <li>Explanation: There are no valid combinations.<ul> <li>Using <code>4</code> different numbers in the range <code>[1,9]</code>, the smallest sum we can get is <code>1+2+3+4 = 10</code> and since <code>10 &gt; 1</code>, there are no valid combination.</li> </ul> </li> </ul> <p>Constraints:</p> <ul> <li><code>2 &lt;= k &lt;= 9</code></li> <li><code>1 &lt;= n &lt;= 60</code></li> </ul>"},{"location":"Leetcode/0200-0299/0216-combination-sum-iii/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(int k, int n, int sum, int startIndex) {\n        if (sum &gt; n) return;\n        if (path.size() == k) {\n            if (sum == n) res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) {\n            path.push_back(i);\n            backtracking(k, n, sum + i, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {\n        backtracking(k, n, 0, 1);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/","title":"Count Complete Tree Nodes","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#description","title":"Description","text":"<p>Given the <code>root</code> of a complete binary tree, return the number of the nodes in the tree.</p> <p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2^h</code> nodes inclusive at the last level <code>h</code>.</p> <p>Design an algorithm that runs in less than \\(O(n)\\) time complexity.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,2,3,4,5,6]</code></li> <li>Output: <code>6</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>0</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 5 * 10^4]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 5 * 10^4</code></li> <li>The tree is guaranteed to be complete.</li> </ul>"},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#classical-approach","title":"Classical Approach","text":""},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#recursive-method","title":"Recursive Method","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);\n    }\n};\n</code></pre> <p>Time Complexity: \\(O(N)\\)</p> <p>The time complexity of this algorithm is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because the algorithm makes a single pass over all the nodes in the tree. Every node is visited exactly once.</p> <p>Space Complexity: \\(O(\\log (N))\\)</p> <p>The space complexity depends on the height of the tree, which affects the depth of the recursion stack.</p> <ul> <li>In the worst case (a skewed tree), the height of the tree can be \\(N\\) (number of nodes), leading to a space complexity of \\(O(N)\\) due to the recursion stack;</li> <li>In the best case (a perfectly balanced tree), the height of the tree is \\(\\log (N)\\), leading to a space complexity of \\(O(\\log (N))\\);</li> <li>For a complete binary tree, the tree is almost perfect, so the space complexity will be closer to \\(O(\\log (N))\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#iterative-method-level-order","title":"Iterative Method (Level-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) return 0;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        int res = 0;\n        while (!q.empty()) {\n            int len = q.size();\n            while (len--) {\n                auto node = q.front();\n                q.pop();\n                res++;\n                if (node-&gt;left) q.push(node-&gt;left);\n                if (node-&gt;right) q.push(node-&gt;right);\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Time Complexity:</p> <p>The time complexity of this approach is \\(O(N)\\), where \\(N\\) is the number of nodes in the tree. This is because each node in the tree is visited exactly once.</p> <p>Space Complexity:</p> <ul> <li>The space complexity primarily depends on the maximum number of nodes that can be present in the queue at any time. This occurs when the queue contains all nodes of the level with the maximum width;</li> <li>Worst Case: In the worst case (for a complete binary tree), the last level can have up to \\(\\frac{N}{2}\\) nodes (in a full binary tree scenario). Therefore, the space complexity in the worst case is \\(O(N)\\);</li> <li>Average Case: On average, the space complexity will depend on the width of the tree, but it will not exceed \\(O(N)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0222-count-complete-tree-nodes/#optimized-approach-for-complete-binary-tree","title":"Optimized Approach for Complete Binary Tree","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) return 0;\n        TreeNode* l = root, * r = root;\n        int lDepth = 0, rDepth = 0;\n        while (l) { l = l-&gt;left; lDepth++; }\n        while (r) { r = r-&gt;right; rDepth++; }\n        if (lDepth == rDepth) return (1 &lt;&lt; lDepth) - 1;\n        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);\n    }\n};\n</code></pre> <p>Code Explanation:</p> <ol> <li>Base Case: </li> <li><code>if (!root) return 0;</code></li> <li>If the tree is empty (i.e., <code>root</code> is <code>nullptr</code>), it contains zero nodes. This is the base case for recursion.</li> <li>Initializing Variables:</li> <li><code>TreeNode* l = root, * r = root;</code></li> <li><code>int lDepth = 0, rDepth = 0;</code></li> <li>Two pointers (<code>l</code> and <code>r</code>) are initialized to the root, and two depth counters (<code>lDepth</code> and <code>rDepth</code>) are set to zero.</li> <li>Calculating Left Depth:</li> <li><code>while (l) { l = l-&gt;left; lDepth++; }</code></li> <li>This loop traverses the tree to the leftmost node, incrementing <code>lDepth</code> at each step. It calculates the depth of the left subtree.</li> <li>Calculating Right Depth:</li> <li><code>while (r) { r = r-&gt;right; rDepth++; }</code></li> <li>Similarly, this loop calculates the depth of the right subtree by moving to the rightmost node.</li> <li>Checking for Complete Tree:</li> <li><code>if (lDepth == rDepth) return (1 &lt;&lt; lDepth) - 1;</code></li> <li>If the depths of the left and right subtrees are equal, it indicates that the tree is a perfect binary tree at this level. The total number of nodes in a perfect binary tree of depth <code>d</code> is <code>2^d - 1</code>.</li> <li>Recursive Case:</li> <li><code>return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);</code></li> <li>If the tree is not perfect, the function recursively counts the nodes in the left and right subtrees. The <code>1 +</code> accounts for the current root node.</li> </ol> <p>Recursion Details:</p> <ul> <li>The recursion occurs in the case where the tree is not perfect. The function is called recursively for the left and right children of the current node.</li> <li>Each recursive call breaks down the problem into smaller sub-trees until it reaches a point where the sub-trees are perfect binary trees or empty.</li> </ul> <p>Time Complexity Analysis:</p> <ol> <li>Depth Calculation:</li> <li>Calculating the leftmost and rightmost depths takes \\(O(\\log N)\\) time each, where \\(N\\) is the total number of nodes. This is because the height of a complete binary tree is \\(O(\\log N)\\).</li> <li>Recursion:</li> <li>The recursive calls are not made to both left and right subtrees in all cases. If the left and right depths are equal, the node count for that subtree is determined without further recursion.</li> <li>In the worst-case scenario, the tree is almost complete but missing some nodes in the rightmost part of the last level. In this case, the recursion will go down to the deepest level on the leftmost path but will terminate early on all other paths.</li> <li>Complexity Calculation:</li> <li>Each recursive call involves two depth calculations (one for the leftmost path and one for the rightmost path) and possibly two recursive calls.</li> <li>However, due to the tree's complete nature, these recursive calls don't always process the entire subtree. As we go deeper, the number of nodes that need to be processed decreases roughly by half each time.</li> </ol> <p>Given these considerations, the time complexity of this algorithm is better than \\(O(N)\\) but worse than \\(O(\\log N)^2\\). A more accurate estimation would be \\(O(\\log N \\times \\log N)\\), which arises from the logarithmic number of recursive calls (since the tree height is \\(O(\\log N)\\), and in each call, the depth is computed, which again takes \\(O(\\log N)\\) time.</p> <p>Space Complexity Analysis:</p> <ul> <li>The space complexity is \\(O(\\log N)\\) due to the recursion stack. In the worst case, the height of the tree (which is the maximum depth of the recursion stack) will be \\(\\log N\\) for a balanced tree.</li> </ul>"},{"location":"Leetcode/0200-0299/0225-implement-stack-using-queues/","title":"Implement Stack using Queues","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0225-implement-stack-using-queues/#description","title":"Description","text":"<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p> <p>Implement the MyStack class:</p> <ul> <li><code>void push(int x)</code> Pushes element <code>x</code> to the top of the stack.</li> <li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li> <li><code>int top()</code> Returns the element on the top of the stack.</li> <li>boolean <code>empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li> </ul> <p>Notes:</p> <ul> <li>You must use only standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li> <li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.</li> </ul> <p>Example 1:</p> <ul> <li>Input<ul> <li><code>[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]</code></li> <li><code>[[], [1], [2], [], [], []]</code></li> </ul> </li> <li>Output<ul> <li><code>[null, null, null, 2, 2, false]</code></li> </ul> </li> </ul> <p>Explanation</p> <pre><code>MyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= x &lt;= 9</code></li> <li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li> <li>All the calls to <code>pop</code> and <code>top</code> are valid.</li> </ul>"},{"location":"Leetcode/0200-0299/0225-implement-stack-using-queues/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0225-implement-stack-using-queues/#implementation-using-queues","title":"Implementation Using Queues","text":"<pre><code>class MyStack {\npublic:\n    queue&lt;int&gt; q, sq;\n    MyStack() {\n\n    }\n\n    void push(int x) {\n        q.push(x);\n    }\n\n    int pop() {\n        while (q.size() &gt; 1) {\n            sq.push(q.front());\n            q.pop();\n        }\n        int res = q.front();\n        q.pop();\n        while (!sq.empty()) {\n            q.push(sq.front());\n            sq.pop();\n        }\n        return res;\n    }\n\n    int top() {\n        return q.back();\n    }\n\n    bool empty() {\n        return q.empty();\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0225-implement-stack-using-queues/#implementation-using-array","title":"Implementation Using Array","text":"<pre><code>class MyStack {\npublic:\n    MyStack() {\n        tt = 0;\n    }\n\n    void push(int x) {\n        stk[++tt] = x;\n    }\n\n    int pop() {\n        return stk[tt--];\n    }\n\n    int top() {\n        return stk[tt];\n    }\n\n    bool empty() {\n        return tt &lt;= 0;\n    }\n    int stk[110];\n    int tt;\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/","title":"Invert Binary Tree","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, invert the tree, and return its root.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [4,2,7,1,3,6,9]</code></li> <li>Output: <code>[4,7,2,9,6,3,1]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [2,1,3]</code></li> <li>Output: <code>[2,3,1]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>root = []</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#recursive-solution","title":"Recursive Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (!root) return nullptr;\n        swap(root-&gt;left, root-&gt;right);\n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        return root;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#iterative-solution","title":"Iterative Solution","text":""},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#way-1-pre-order","title":"Way 1 (Pre-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        TreeNode *curr = root;\n\n        while (curr || !stk.empty()) {\n            if (curr) {\n                swap(curr-&gt;left, curr-&gt;right);\n                stk.push(curr);\n                curr = curr-&gt;left;\n            } else {\n                auto t = stk.top();\n                stk.pop();\n                curr = t-&gt;right;\n            }\n        }\n        return root;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0226-invert-binary-tree/#way-2-level-order","title":"Way 2 (Level-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (!root) return nullptr;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n\n        while (!q.empty()) {\n            auto curr = q.front();\n            q.pop();\n\n            swap(curr-&gt;left, curr-&gt;right);\n            if (curr-&gt;left) q.push(curr-&gt;left);\n            if (curr-&gt;right) q.push(curr-&gt;right);\n        }\n        return root;\n    }\n};\n</code></pre> <p>Explanation:</p> <ol> <li>Check for Empty Tree: If the root is null, the tree is empty, and we return <code>nullptr</code>.</li> <li>Queue Initialization: We use a queue to keep track of nodes. Initially, it contains only the root.</li> <li>Tree Traversal: We use a loop to process nodes until the queue is empty. For each node:<ul> <li>Swap its left and right children.</li> <li>Enqueue its non-null children for subsequent processing.</li> </ul> </li> </ol> <p>Complexity Analysis:</p> <ul> <li>Time Complexity: \\(O(n)\\), where \\(n\\) is the number of nodes in the tree. Each node is visited exactly once.</li> <li>Space Complexity: \\(O(m)\\), where m is the maximum number of nodes at any level in the input tree. In the worst case, the space complexity can be \\(O(n)\\) (consider a perfectly balanced tree).</li> </ul>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/","title":"Implement Queue using Stacks","text":"<p>link</p>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#description","title":"Description","text":"<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p> <p>Implement the <code>MyQueue</code> class:</p> <ul> <li><code>void push(int x)</code> Pushes element <code>x</code> to the back of the queue.</li> <li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li> <li><code>int peek()</code> Returns the element at the front of the queue.</li> <li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li> </ul> <p>Notes:</p> <ul> <li>You must use only standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li> <li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.</li> </ul> <p>Example 1:</p> <ul> <li>Input:<ul> <li><code>[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]</code></li> <li><code>[[], [1], [2], [], [], []]</code></li> </ul> </li> <li>Output:<ul> <li><code>[null, null, null, 1, 1, false]</code></li> </ul> </li> </ul> <p>Explanation:</p> <pre><code>MyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= x &lt;= 9</code></li> <li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li> <li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li> </ul>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#implementation-using-two-stacks","title":"Implementation Using Two Stacks","text":"<p>When pushing data, it is sufficient to simply place the data into the input stack. However, popping data is a bit more complex. If the output stack is empty, then all the data from the input stack should be transferred into it (note that it should be a complete transfer), and then data can be popped from the output stack. If the output stack is not empty, data can be directly popped from it.</p> <p>Finally, how do we determine if the queue is empty? If both the input and output stacks are empty, then the simulated queue is considered empty.</p>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#way-1","title":"Way 1","text":"<pre><code>class MyQueue {\npublic:\n    stack&lt;int&gt; stkIn, stkOut;\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        stkIn.push(x);\n    }\n\n    int pop() {\n        // Import data from stIn only if stOut is empty (import all stIn data)\n        if (stkOut.empty()) {\n            while (!stkIn.empty()) {\n                stkOut.push(stkIn.top());\n                stkIn.pop();\n            }\n        }\n        int result = stkOut.top();\n        stkOut.pop();\n        return result;\n    }\n\n    int peek() {\n        int result = this-&gt;pop();\n        // Because the pop function pops the element \"result\",\n        // it need to be added back again\n        stkOut.push(result);\n        return result;\n    }\n\n    bool empty() {\n        return stkIn.empty() &amp;&amp; stkOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre> <ul> <li>Time complexity: <code>push</code> and <code>empty</code> are \\(O(1)\\), <code>pop</code> and <code>peek</code> are \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#way-2","title":"Way 2","text":"<p>We use a stack to store the elements of the queue, and an auxiliary stack to aid in the implementation of the <code>pop()</code> and <code>peek()</code> operations.</p> <p>The four operations are implemented as follows:</p> <ul> <li><code>push(x)</code>: inserts <code>x</code> directly into the top of the stack;</li> <li><code>pop()</code>: if we need to pop the bottom element of the stack, we first insert all elements above the bottom of the stack into the auxiliary stack, then pop the bottom element, and finally re-press the elements of the auxiliary stack into the current stack;</li> <li><code>peek()</code>: returns the top element of the stack. Similarly, we first insert all elements above the bottom of the stack into the auxiliary stack, then eject the bottom element, and finally re-press the elements in the auxiliary stack into the current stack to restore the current stack to its original state;</li> <li><code>empty()</code>: returns whether the current stack is empty.</li> </ul> <pre><code>class MyQueue {\npublic:\n    stack&lt;int&gt; stkMain, stkSupply;\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        stkMain.push(x);\n    }\n\n    int pop() {\n        while (stkMain.size() &gt; 1) {\n            stkSupply.push(stkMain.top());\n            stkMain.pop();\n        }\n        int t = stkMain.top();\n        stkMain.pop();\n        while (stkSupply.size()) {\n            stkMain.push(stkSupply.top());\n            stkSupply.pop();\n        }\n        return t;\n    }\n\n    int peek() {\n        while (stkMain.size() &gt; 1) {\n            stkSupply.push(stkMain.top());\n            stkMain.pop();\n        }\n        int t = stkMain.top();\n        while (stkSupply.size()) {\n            stkMain.push(stkSupply.top());\n            stkSupply.pop();\n        }\n        return t;\n    }\n\n    bool empty() {\n        return stkMain.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0232-implement-queue-using-stacks/#implementation-using-array","title":"Implementation Using Array","text":"<pre><code>class MyQueue {\npublic:\n    MyQueue() {\n        hh = 0;\n        tt = -1;\n    }\n\n    void push(int x) {\n        q[++tt] = x;\n    }\n\n    int pop() {\n        hh++;\n        return q[hh - 1];\n    }\n\n    int peek() {\n        return q[hh];\n    }\n\n    bool empty() {\n        if (hh &lt;= tt) return false;\n        else return true;\n    }\n    int q[110];\n    int hh;\n    int tt;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0239-sliding-window-maximum/","title":"Sliding Window Maximum","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0239-sliding-window-maximum/#description","title":"Description","text":"<p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p> <p>Return the max sliding window.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,3,-1,-3,5,3,6,7], k = 3</code></li> <li>Output: <code>[3,3,5,5,6,7]</code></li> <li>Explanation:</li> </ul> <pre><code>Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1], k = 1</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> <li><code>1 &lt;= k &lt;= nums.length</code></li> </ul>"},{"location":"Leetcode/0200-0299/0239-sliding-window-maximum/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0239-sliding-window-maximum/#implementing-monotonic-queue-data-structure","title":"Implementing Monotonic Queue Data Structure","text":"<pre><code>class Solution {\nprivate:\n    class MyQueue {\n    public:\n        deque&lt;int&gt; que;\n        void pop(int value) {\n            if (!que.empty() &amp;&amp; value == que.front()) que.pop_front();\n        }\n        void push(int value) {\n            while (!que.empty() &amp;&amp; value &gt; que.back()) que.pop_back();\n            que.push_back(value);\n        }\n        int front() const { return que.front(); }\n    };\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        MyQueue que;\n        vector&lt;int&gt; result;\n        for (int i = 0; i &lt; k; i++) que.push(nums[i]);\n        result.push_back(que.front());\n        for (int i = k; i &lt; nums.size(); i++) {\n            que.pop(nums[i - k]);\n            que.push(nums[i]);\n            result.push_back(que.front());\n        }\n        return result;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\nprivate:\n    // The MyQueue class is an internal class used for managing the sliding window.\n    class MyQueue {\n    public:\n        deque&lt;int&gt; que;  // A double-ended queue to store the elements of the window\n\n        // Pop operation for the queue which only pops the front element if it is equal to 'value'\n        void pop(int value) {\n            if (!que.empty() &amp;&amp; value == que.front()) \n                que.pop_front();\n        }\n\n        // Push operation for the queue. It ensures that the queue is always arranged in a way\n        // that the maximum element is at the front.\n        void push(int value) {\n            // Remove all elements smaller than 'value' from the back of the queue\n            while (!que.empty() &amp;&amp; value &gt; que.back()) \n                que.pop_back();\n            // Add the new 'value' to the back of the queue\n            que.push_back(value);\n        }\n\n        // Returns the front element of the queue, which is the maximum element of the current window\n        int front() const { return que.front(); }\n    };\n\npublic:\n    // The main function to find the maximum value in each sliding window of size 'k' in the array 'nums'\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        MyQueue que; // Instance of MyQueue to manage our sliding window\n        vector&lt;int&gt; result; // Result vector to store the maximums of each window\n\n        // Initialize the first window\n        for (int i = 0; i &lt; k; i++) \n            que.push(nums[i]);\n\n        // Store the maximum of the first window\n        result.push_back(que.front());\n\n        // Iterate over the array, sliding the window one element at a time\n        for (int i = k; i &lt; nums.size(); i++) {\n            // Remove the element that is exiting the window\n            que.pop(nums[i - k]);\n            // Add the new element to the window\n            que.push(nums[i]);\n            // Store the maximum of the current window\n            result.push_back(que.front());\n        }\n\n        return result;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(k)\\).</li> </ul> <p>Easier way of writing (recommended):</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        deque&lt;int&gt; dq;\n        vector&lt;int&gt; res;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()])\n                dq.pop_back();\n            dq.push_back(i);\n            if (dq.front() &lt; i - k + 1) dq.pop_front();\n            if (i &gt;= k - 1) res.push_back(nums[dq.front()]);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0239-sliding-window-maximum/#simulate-queue-using-array","title":"Simulate Queue Using Array","text":"<p>A monotonic queue is a type of queue where elements can be enqueued and dequeued from the rear, and dequeued from the front. Its purpose is to maintain the monotonicity of a subsequence. To maintain the maximum value, a descending subsequence within a sliding window is maintained.</p> <p>Key points to note:</p> <ul> <li>Condition for dequeuing from the rear: The queue is not empty and the new element is more optimal, causing older elements to be dequeued from the rear;</li> <li>Each element will be enqueued from the rear once;</li> <li>Condition for dequeuing from the front: Elements in the queue slide out of the window;</li> <li>The queue stores the indices of elements (rather than the elements of the array), which facilitates determining when to dequeue from the front.</li> </ul> <p>Steps inside the <code>for</code> loop of the code:</p> <ol> <li>Address the issue of the queue's front element sliding out of the window;</li> <li>Address the issue of the rear of the queue and the current element <code>a[i]</code> not maintaining monotonicity;</li> <li>Add the current element's index to the rear of the queue;</li> <li>Output the result if the conditions are met.</li> </ol> <p>Details to be aware of in the above steps:</p> <ul> <li>In the four steps mentioned above, step 3 should be done before step 4, as the newly added element might be the one that needs to be output;</li> <li>The queue stores the indices of the original array, so when accessing values, a further layer of indexing is needed, <code>a[q[]]</code>;</li> <li>Before calculating the maximum value, reset <code>hh</code> and <code>tt</code>;</li> <li>If <code>hh</code> starts from <code>0</code>, then the array indices should also start from <code>0</code>.</li> </ul> <p>Regarding initialization:</p> <ul> <li>The initialization of <code>hh</code> and <code>tt</code> is related to the index of the first value of the array: <code>hh</code> should be less than or equal to the first index of the array (e.g., if the array index starts from <code>0</code>, <code>hh &lt;= 0</code>; if it starts from <code>1</code>, <code>hh &lt;= 1</code>, which could be <code>1</code>, <code>0</code>, <code>-1</code>, etc.);</li> <li>Whether the array index starts from <code>0</code> or <code>1</code> also affects the <code>if</code> condition for output, which needs to be modified accordingly:<ul> <li>If the index starts from <code>0</code>, it should be <code>i &gt;= k - 1</code>, as the first window is <code>0 1 2</code>;</li> <li>If the index starts from <code>1</code>, it should be <code>i &gt;= k</code>, as the first window is <code>1 2 3</code>;</li> </ul> </li> <li>During initialization, there should be a gap between <code>hh</code> and <code>tt</code>, i.e., <code>hh == tt + 1</code>.</li> </ul> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        int q[100010];\n        vector&lt;int&gt; res;\n        int hh = 0, tt = -1;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;\n            while (hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) tt--;\n            q[++tt] = i;\n            if (i &gt;= k - 1) res.push_back(nums[q[hh]]);\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        int q[100010];  // q stores the array indices\n        vector&lt;int&gt; res;\n        int hh = 0, tt = -1;  // Initialize the queue empty (hh is the head of the queue, tt is the tail of the queue)\n        for (int i = 0; i &lt; nums.size(); i++) {  // Iterate through the array\n            /*\n            To maintain the size of the sliding window,\n            when the queue is not empty (hh &lt;= tt) \n            and the current sliding window size (i - q[hh] + 1) is greater than the set sliding window size (k),\n            dequeue the front element of the queue to maintain the size of the sliding window.\n            */\n            // hh &lt;= tt means the queue is not empty\n            if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;  // Dequeue from the front (front element slides out of the window)\n\n            /*\n            Constructing a monotonically increasing queue\n            When the queue is not empty (hh &lt;= tt) \n            and the tail element of the queue is less than or equal to the current element (nums[i]),\n            then the tail element is definitely not the maximum value of the current window,\n            so remove the tail element and add the current element (q[++tt] = i)\n            */\n            // Dequeue from the tail (queue not empty and new element is better)\n            while (hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) tt--;  // This is a unique operation of the monotonic queue\n            // Enqueue at the tail (note that the queue stores array indices, \n            // which facilitates determining when to dequeue from the front)\n            q[++tt] = i;\n\n            // Use the maximum value\n            if (i &gt;= k - 1) res.push_back(nums[q[hh]]);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0242-valid-anagram/","title":"Valid Anagram","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0242-valid-anagram/#description","title":"Description","text":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an anagram of <code>s</code>, and <code>false</code> otherwise.</p> <p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"anagram\"</code>, <code>t = \"nagaram\"</code></li> <li>Output: <code>true</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"rat\"</code>, <code>t = \"car\"</code></li> <li>Output: <code>false</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length</code>, <code>t.length &lt;= 5 * 10^4</code></li> <li><code>s</code> and <code>t</code> consist of lowercase English letters.</li> </ul>"},{"location":"Leetcode/0200-0299/0242-valid-anagram/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0242-valid-anagram/#hash-map","title":"Hash Map","text":"<ul> <li>Assuming that the string contains only lowercase letters, use an array of length 26 as a hash table to keep track of the number of times a letter appears.</li> <li>For <code>s</code>, add the number of letters to the hash table.</li> <li>For <code>t</code>, reduce the number of corresponding letters in the hash table.</li> <li>Finally, from <code>a</code> to <code>z</code> statistics whether there is not 0 cases, if so, then return false, otherwise return true.</li> </ul> <pre><code>class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) return false;\n        int record[26] = {0};\n        for (int i = 0; i &lt; s.size(); i++) {\n            record[s[i] - 'a']++;\n            record[t[i] - 'a']--;\n        }\n        //If any element of the record array is not 0, the strings s and t must be either more or less characters.\n        for (int i = 0; i &lt; 26; i++) {\n            if (record[i] != 0) return false;\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0242-valid-anagram/#hash-map-simpler","title":"Hash Map (Simpler)","text":"<pre><code>class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map&lt;char, int&gt; hash_s, hash_t;\n        for (auto c : s) hash_s[c]++;\n        for (auto c : t) hash_t[c]++;\n        // unordered_map supports == operator\n        return hash_s == hash_t;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n)\\)</p>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/","title":"Binary Tree Paths","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return all root-to-leaf paths in any order.</p> <p>A leaf is a node with no children.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [1,2,3,null,5]</code></li> <li>Output: <code>[\"1-&gt;2-&gt;5\",\"1-&gt;3\"]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>[\"1\"]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#solution","title":"Solution","text":""},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#way-1","title":"Way 1","text":"<p>Pre-order:</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    void traversal(TreeNode* curr, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) {\n        path.push_back(curr-&gt;val);\n        /*\n        The base case of the recursion checks if the current node is a leaf node \n        (both left and right children are null).\n        If it's a leaf, the code constructs a string representing the path from the root to this leaf \n        and adds it to result.\n        */\n        if (!curr-&gt;left &amp;&amp; !curr-&gt;right) {\n            string sPath;\n            for (int i = 0; i &lt; path.size() - 1; i++) {\n                sPath += to_string(path[i]);\n                sPath += \"-&gt;\";\n            }\n            sPath += to_string(path[path.size() - 1]);\n            result.push_back(sPath);\n            return;\n        }\n        /*\n        If the current node has a left child, the function is recursively called for the left child. \n        After returning from the left child, path.pop_back() is called \n        to remove the last element, implementing backtracking.\n        */\n        if (curr-&gt;left) {\n            traversal(curr-&gt;left, path, result);\n            path.pop_back();\n        }\n        /*\n        Similarly, if there's a right child, the function is recursively called for it, \n        followed by a pop_back() for backtracking.\n        */\n        if (curr-&gt;right) {\n            traversal(curr-&gt;right, path, result);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        vector&lt;string&gt; res;\n        vector&lt;int&gt; path;\n        if (!root) return res;\n        traversal(root, path, res);\n        return res;\n    }\n};\n</code></pre> <p>Recursion and Backtracking in the Context of Binary Tree Traversal:</p> <p>Recursion is a method of solving problems where a function calls itself as a subroutine. This allows the function to be repeated several times, as it can call itself during its execution. In the code, the <code>traversal</code> function is recursive. Here's how it works:</p> <ol> <li>Initial Call: The <code>traversal</code> function is initially called with the root node of the tree.</li> <li>Recursive Calls: Inside the function, if the current node (<code>curr</code>) has a left or right child, the function calls itself (<code>traversal</code>) for these children.</li> </ol> <p>This process creates a chain of function calls, each dealing with a smaller part of the tree (either the left or right subtree of the current node).</p> <p>Backtracking is a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. In the context of tree traversal, it involves retracting one step back in the tree when you reach a leaf or a dead end, and then exploring other paths.</p> <p>Here's how backtracking is implemented:</p> <ol> <li>Path Construction: As the recursion goes deeper into the tree, the path from the root to the current node is constructed by adding nodes to the <code>path</code> vector.</li> <li>Leaf Node Reached: When a leaf node is reached (no left or right child), a complete root-to-leaf path has been found, and this path is recorded.</li> <li>Backtracking Step: After recording the path or if a node doesn't have a left or right child, the function backtracks by removing the last element from the <code>path</code> vector (<code>path.pop_back()</code>). This step is crucial as it effectively removes the current node from the path, reverting the path to the state it was in before the current node was added.</li> <li>Continuing the Traversal: The function then returns to its caller, which is the previous step in the path. The caller then continues to explore other branches of the tree (e.g., the right child if the left child was explored first).</li> </ol> <p>Example: Suppose we have a binary tree like this:</p> <pre><code>    1\n   / \\\n  2   3\n</code></pre> <ul> <li>Start at root (1). <code>path = [1]</code>.</li> <li>Go to left child (2). <code>path = [1, 2]</code>.</li> <li>2 is a leaf node, so add <code>1-&gt;2</code> to <code>result</code>.</li> <li>Backtrack: Remove 2 from path. <code>path = [1]</code>.</li> <li>Go to right child (3). <code>path = [1, 3]</code>.</li> <li>3 is a leaf node, so add <code>1-&gt;3</code> to <code>result</code>.</li> <li>Backtrack: Remove 3 from path. <code>path = [1]</code>.</li> <li>All paths explored, function ends.</li> </ul>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; ans;\n    vector&lt;int&gt; path;\n\n    void findPath(TreeNode* root) {\n        path.push_back(root-&gt;val);\n        if (!root-&gt;left &amp;&amp; !root-&gt;right) {\n            string sPath;\n            for (int i = 0; i &lt; path.size() - 1; i++)\n                sPath += to_string(path[i]) + \"-&gt;\";\n            sPath += to_string(path[path.size() - 1]);\n            ans.push_back(sPath);\n        } else {\n            if (root-&gt;left) findPath(root-&gt;left);\n            if (root-&gt;right) findPath(root-&gt;right);\n        }\n        path.pop_back();\n    }\n\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        if (root) findPath(root);\n        return ans;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#way-3","title":"Way 3","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    void traversal(TreeNode* curr, string path, vector&lt;string&gt;&amp; res) {\n        path += to_string(curr-&gt;val);\n        if (!curr-&gt;left &amp;&amp; !curr-&gt;right) {\n            res.push_back(path);\n            return;\n        }\n        if (curr-&gt;left) traversal(curr-&gt;left, path + \"-&gt;\", res);\n        if (curr-&gt;right) traversal(curr-&gt;right, path + \"-&gt;\", res);\n    }\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        vector&lt;string&gt; res;\n        string path;\n        if (!root) return res;\n        traversal(root, path, res);\n        return res;\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; res;\n    void findPaths(TreeNode* root, string path) {\n        if (!root) return;\n        path += to_string(root-&gt;val);\n        if (!root-&gt;left &amp;&amp; !root-&gt;right) {\n            res.push_back(path);\n            return;\n        }\n        findPaths(root-&gt;left, path + \"-&gt;\");\n        findPaths(root-&gt;right, path + \"-&gt;\");\n    }\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        findPaths(root, \"\");\n        return res;\n    }\n};\n</code></pre> <p>Time Complexity:</p> <ol> <li>Traversal Complexity: Each node in the tree is visited exactly once. If there are \\(N\\) nodes in the tree, the traversal part of the algorithm is \\(O(N)\\).</li> <li>String Operations: In each recursive call, a new string is created that includes the current path plus the value of the current node. The time complexity for string concatenation in C++ can vary, but in the worst case, it is proportional to the length of the new string being created.</li> <li>Worst-Case Scenario for String Concatenation:<ul> <li>For a balanced tree, the length of the path (and thus the length of the string) at any node is proportional to the height of the tree, which is \\(\\log N\\) for a balanced tree.</li> <li>In an unbalanced tree, in the worst case, the length can be proportional to \\(N\\), such as in a skewed tree (where each node has only one child).</li> </ul> </li> </ol> <p>Combining these factors, the time complexity is \\(O(N \\cdot L)\\), where \\(L\\) represents the average length of the path string in each recursive call. In the worst case, especially for unbalanced trees, \\(L\\) can approach \\(N\\), leading to a time complexity of \\(O(N^2)\\).</p> <p>Space Complexity:</p> <ol> <li>Space for Recursive Calls (Recursion Stack): The maximum depth of the recursion stack is proportional to the height of the tree. In the worst case, for a skewed tree, this can be \\(O(N)\\).</li> <li>Space for Path Strings:<ul> <li>Each recursive call creates a new string representing the path. Although these strings are temporary and each exists only during the execution of a single recursive call, the space occupied by these strings at any moment is proportional to the depth of the recursion and the length of the path string.</li> <li>In the worst case, where the tree is skewed, the length of the path string can be proportional to \\( N \\), leading to a space complexity of \\(O(N^2)\\) due to the concatenation of strings at each level of the tree.</li> <li>In the bast case, the binary tree is balanced, leading to the space complexity of \\(O((\\log n)^2)\\).</li> </ul> </li> </ol>"},{"location":"Leetcode/0200-0299/0257-binary-tree-paths/#way-4-iterative-method","title":"Way 4: Iterative Method","text":"<p>See reference (Chinese).</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        vector&lt;string&gt; paths;\n        if (!root) return paths;\n        queue&lt;pair&lt;TreeNode*, string&gt;&gt; q;\n        q.push(make_pair(root, to_string(root-&gt;val)));\n        while (!q.empty()) {\n            auto t = q.front();\n            q.pop();\n            if (!(t.first)-&gt;left &amp;&amp; !(t.first)-&gt;right) paths.push_back(t.second);\n            else {\n                if ((t.first)-&gt;left) {\n                    q.push(make_pair((t.first)-&gt;left, t.second + \"-&gt;\" + to_string((t.first)-&gt;left-&gt;val)));\n                }\n                if ((t.first)-&gt;right) {\n                    q.push(make_pair((t.first)-&gt;right, t.second + \"-&gt;\" + to_string((t.first)-&gt;right-&gt;val)));\n                }\n            }\n        }\n        return paths;\n    }\n};\n</code></pre> <p>We can also implement this with a breadth-first search. We maintain a queue that stores the node and the path from the root to that node. At first this queue has only the root node in it. At each iteration step, we take out the first node in the queue and if it is a leaf node, add its corresponding path to the answer. If it is not a leaf node, all its child nodes are added to the end of the queue. When the queue is empty the breadth-first search ends and we get the answer.</p> <ul> <li>Worst time complexity: \\(O(N^2)\\);</li> <li>Worst space complexity: \\(O(N^2)\\).</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/","title":"Find Median from Data Stream","text":"<p>Link</p>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#description","title":"Description","text":"<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p> <ul> <li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li> <li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li> </ul> <p>Implement the MedianFinder class:</p> <p><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object. <code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure. <code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10^-5</code> of the actual answer will be accepted.</p> <p>Example 1:</p> <ul> <li>Input:<ul> <li><code>[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]</code></li> <li><code>[[], [1], [2], [], [3], []]</code></li> </ul> </li> <li>Output:<ul> <li><code>[null, null, null, 1.5, null, 2.0]</code></li> </ul> </li> </ul> <p>Explanation:</p> <pre><code>MedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n</code></pre> <p>Constraints:</p> <ul> <li><code>-10^5 &lt;= num &lt;= 10^5</code></li> <li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li> <li>At most <code>5 * 10^4</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#solution","title":"Solution","text":"<pre><code>class MedianFinder {\nprivate:\n    priority_queue&lt;int&gt; small;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large;\npublic:\n    MedianFinder() {\n\n    }\n\n    void addNum(int num) {\n        if (small.size() &gt;= large.size()) {\n            small.push(num);\n            large.push(small.top());\n            small.pop();\n        } else {\n            large.push(num);\n            small.push(large.top());\n            large.pop();\n        }\n    }\n\n    double findMedian() {\n        if (large.size() &lt; small.size()) return small.top();\n        else if (large.size() &gt; small.size()) return large.top();\n\n        return (large.top() + small.top()) / 2.0;\n    }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj-&gt;addNum(num);\n * double param_2 = obj-&gt;findMedian();\n */\n</code></pre>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#class-structure","title":"Class Structure","text":"<ul> <li>Class MedianFinder: Contains two priority queues <code>small</code> and <code>large</code>.</li> <li><code>small</code>: A max heap (standard priority queue in C++) that stores the smaller half of the numbers.</li> <li><code>large</code>: A min heap (priority queue with <code>greater&lt;int&gt;</code> comparison) that stores the larger half of the numbers.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#constructor","title":"Constructor","text":"<ul> <li>MedianFinder(): Initializes the MedianFinder object. It doesn't require any specific initialization for the heaps as their constructors handle that.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#function-addnumint-num","title":"Function addNum(int num)","text":"<ul> <li>The function ensures that the two heaps are either equal in size or have a size difference of one.</li> <li>If <code>small</code> has more or equal elements than <code>large</code>, the new number is added to <code>small</code> and then the maximum element from <code>small</code> is moved to <code>large</code>.</li> <li>Otherwise, the new number is added to <code>large</code> and then the minimum element from <code>large</code> is moved to <code>small</code>.</li> <li>This approach maintains the heaps such that <code>small</code> contains the smaller half of the numbers, and <code>large</code> contains the larger half. The top of <code>small</code> is always less or equal to the top of <code>large</code>.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#function-findmedian","title":"Function findMedian()","text":"<ul> <li>Returns the median of the current data stream.</li> <li>If <code>small</code> has more elements, the median is the top of <code>small</code>.</li> <li>If <code>large</code> has more elements, the median is the top of <code>large</code>.</li> <li>If they are of equal size, the median is the average of the tops of both <code>small</code> and <code>large</code>.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time Complexity:<ul> <li><code>addNum(int num)</code><ul> <li>Insertion into a priority queue: \\(O(\\log n)\\), where \\(n\\) is the number of elements in the heap.</li> <li>Extracting the top and inserting into the other heap: \\(O(\\log n)\\).</li> <li>Total for each insertion: \\(O(\\log n)\\).</li> </ul> </li> <li><code>findMedian()</code><ul> <li>Returning the top of a heap or calculating the average of the tops of two heaps: \\(O(1)\\).</li> </ul> </li> </ul> </li> <li>Space Complexity: The space complexity is \\(O(n)\\), where \\(n\\) is the number of elements in the data stream. This is because the data structure stores all the elements in the two heaps.</li> </ul>"},{"location":"Leetcode/0200-0299/0295-find-median-from-data-stream/#follow-up","title":"Follow-Up","text":"<p>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</p> <pre><code>class MedianFinder {\nprivate:\n    map&lt;int, int&gt; head, tail;\n    int arr[101] = {0};\n    int a = 0, b = 0, c = 0;\n\npublic:\n    void addNum(int num) {\n        if (num &gt;= 0 &amp;&amp; num &lt;= 100) {\n            arr[num]++;\n            b++;\n        } else if (num &lt; 0) {\n            head[num]++;\n            a++;\n        } else { // num &gt; 100\n            tail[num]++;\n            c++;\n        }\n    }\n\n    double findMedian() {\n        int size = a + b + c;\n        if (size % 2 == 0) {\n            return (find(size / 2) + find(size / 2 + 1)) / 2.0;\n        }\n        return find(size / 2 + 1);\n    }\n\n    int find(int n) {\n        if (n &lt;= a) {\n            for (const auto&amp; p : head) {\n                n -= p.second;\n                if (n &lt;= 0) return p.first;\n            }\n        } else if (n &lt;= a + b) {\n            n -= a;\n            for (int i = 0; i &lt;= 100; ++i) {\n                n -= arr[i];\n                if (n &lt;= 0) return i;\n            }\n        } else {\n            n -= a + b;\n            for (const auto&amp; p : tail) {\n                n -= p.second;\n                if (n &lt;= 0) return p.first;\n            }\n        }\n        return -1; // should never reach here\n    }\n};\n</code></pre>"},{"location":"Leetcode/0300-0399/0322-coin-change/","title":"Coin Change","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0322-coin-change/#description","title":"Description","text":"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p> <p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p> <p>You may assume that you have an infinite number of each kind of coin.</p> <p>Example 1:</p> <p>Input: <code>coins = [1,2,5], amount = 11</code> Output: <code>3</code> Explanation: <code>11 = 5 + 5 + 1</code></p> <p>Example 2:</p> <p>Input: <code>coins = [2], amount = 3</code> Output: <code>-1</code></p> <p>Example 3:</p> <p>Input: <code>coins = [1], amount = 0</code> Output: <code>0</code></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= coins.length &lt;= 12</code></li> <li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li> <li><code>0 &lt;= amount &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0300-0399/0322-coin-change/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        vector&lt;int&gt; dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i &lt; coins.size(); i++) {\n            for (int j = coins[i]; j &lt;= amount; j++) {\n                if (dp[j - coins[i]] != INT_MAX) \n                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);\n            }\n        }\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0300-0399/0343-integer-break/","title":"Integer Break","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0343-integer-break/#description","title":"Description","text":"<p>Given an integer <code>n</code>, break it into the sum of <code>k</code> positive integers, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p> <p>Return the maximum product you can get.</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 2</code></li> <li>Output: <code>1</code></li> <li>Explanation: <code>2 = 1 + 1, 1 \u00d7 1 = 1</code>.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 10</code></li> <li>Output: <code>36</code></li> <li>Explanation: <code>10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36</code>.</li> </ul> <p>Constraints:</p> <ul> <li><code>2 &lt;= n &lt;= 58</code></li> </ul>"},{"location":"Leetcode/0300-0399/0343-integer-break/#solution","title":"Solution","text":""},{"location":"Leetcode/0300-0399/0343-integer-break/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int integerBreak(int n) {\n        vector&lt;int&gt; dp(n + 1);\n        dp[2] = 1;\n        for (int i = 3; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= i / 2; j++)\n                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n        }\n        return dp[n];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n^2)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0300-0399/0343-integer-break/#way-2","title":"Way 2","text":"<p>See reference.</p> <pre><code>class Solution {\npublic:\n    int integerBreak(int n) {\n        if (n &lt;= 3) return 1 * (n - 1);\n        int p = 1;\n        while (n &gt;= 5) n -= 3, p *= 3;\n        return p * n;\n    }\n};\n</code></pre> <p>There are only a finite number of ways to split a positive integer into a number of positive integers, so there exists a maximum product. Assume \\(N=n_1+n_2+\\cdots +n_k\\), and \\(n_1\\cdot n_2\\cdot \\cdots \\cdot n_k\\) is the maximum product.</p> <ol> <li>Obviously \\(1\\) won't be in there;</li> <li>If for some \\(i\\) such that \\(n_i \\geqslant 5\\), then we split \\(n_i\\) into \\(3+\\left( n_i-3 \\right)\\). We have \\(3\\cdot \\left( n_i-3 \\right) =3n_i-9&gt;n_i\\);</li> <li>If \\(n_i =4\\), Splitting into a \\(2+2\\) product leaves the product unchanged, so it might as well be assumed that there is no \\(4\\);</li> <li>If there are more than three \\(2\\)'s, then \\(3\\times 3&gt;2\\times 2\\times 2\\), so the substitution into \\(3\\) multiplies the product even more.</li> </ol> <p>To summarize, choose as many \\(3\\)s as possible until \\(2\\) or \\(4\\) are left, then use \\(2\\).</p> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0300-0399/0344-reverse-string/","title":"Reverse String","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0344-reverse-string/#description","title":"Description","text":"<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p> <p>You must do this by modifying the input array in-place with \\(O(1)\\) extra memory.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = [\"h\",\"e\",\"l\",\"l\",\"o\"]</code></li> <li>Output: <code>[\"o\",\"l\",\"l\",\"e\",\"h\"]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]</code></li> <li>Output: <code>[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^5</code></li> <li><code>s[i]</code> is a printable ascii character.</li> </ul>"},{"location":"Leetcode/0300-0399/0344-reverse-string/#solution","title":"Solution","text":""},{"location":"Leetcode/0300-0399/0344-reverse-string/#double-pointer","title":"Double Pointer","text":"<pre><code>class Solution {\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) {\n        for (int i = 0; i &lt; s.size() / 2; i++)\n            swap(s[i], s[s.size() - i - 1]);\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) {\n        for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; i++, j--) {\n            // swap(s[i], s[j]);\n            s[i] ^= s[j];\n            s[j] ^= s[i];\n            s[i] ^= s[j];\n        }\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/","title":"Top K Frequent Elements","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code> most frequent elements. You may return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,1,1,2,2,3], k = 2</code></li> <li>Output: <code>[1,2]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1], k = 1</code></li> <li>Output: <code>[1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> <li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li> <li>It is guaranteed that the answer is unique.</li> </ul>"},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/#solution","title":"Solution","text":""},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/#using-max-heap","title":"Using Max Heap","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        // Create a hash map to store the frequency of each number\n        unordered_map&lt;int, int&gt; mapping;\n        for (auto num : nums) mapping[num]++;\n\n        // Create a max heap to store pairs of (frequency, number)\n        priority_queue&lt;pair&lt;int, int&gt;&gt; q;\n\n        // Resultant vector to store the top k frequent elements\n        vector&lt;int&gt; res;\n\n        // Iterate over the frequency map\n        for (auto it = mapping.begin(); it != mapping.end(); it++) {\n            // Push the pair (frequency, number) into the max heap\n            q.emplace(make_pair(it-&gt;second, it-&gt;first));\n\n            // If the size of the max heap is greater than the number of unique elements minus k\n            if (q.size() &gt; mapping.size() - k) {\n                // Add the top element (number with highest frequency so far) to the result\n                res.emplace_back(q.top().second);\n                // Remove the top element from the max heap\n                q.pop();\n            }\n        }\n\n        // Return the resultant vector containing top k frequent elements\n        return res;\n    }\n};\n</code></pre> <p>Explanation:</p> <ol> <li>Frequency Mapping: First, the algorithm creates a hash map (<code>unordered_map</code>) to count the frequency of each element in the input vector <code>nums</code>.</li> <li>Max Heap Creation: It then uses a max heap (<code>priority_queue</code>) to store pairs of (frequency, element). The max heap is used to efficiently retrieve the element with the highest frequency.</li> <li>Heap Manipulation: For each element in the frequency map, the algorithm pushes a pair of (frequency, element) into the max heap. If the size of the max heap exceeds the number of unique elements minus <code>k</code>, it means we have found one of the top <code>k</code> frequent elements. This element is added to the result vector, and then removed from the max heap.</li> <li>Result Compilation: This process is repeated until all top <code>k</code> frequent elements are found and added to the result vector.</li> </ol> <p>Time Complexity Analysis:</p> <ol> <li>Frequency Mapping: \\(O(N)\\), where \\(N\\) is the number of elements in <code>nums</code>. Each element is visited once to update the frequency map.</li> <li>Heap Operations:</li> <li>Inserting an element into the heap takes \\(O(\\log M)\\) time, where \\(M\\) is the number of unique elements in <code>nums</code>.</li> <li>The for loop iterates \\(M\\) times, and each iteration may involve a heap insertion.</li> <li>Therefore, the total time for heap operations is \\(O(M \\log M)\\).</li> </ol> <p>Overall, the time complexity is \\(O(N + M \\log M)\\). In the worst case, where all elements are unique, \\(M\\) becomes \\(N\\), and the time complexity is \\(O(N \\log N)\\).</p> <p>Space Complexity Analysis:</p> <ol> <li>Frequency Map: \\(O(M)\\), where \\(M\\) is the number of unique elements in <code>nums</code>.</li> <li>Max Heap: \\(O(M)\\), for storing the frequency and element pairs.</li> <li>Result Vector: \\(O(K)\\), for storing the top \\(k\\) frequent elements.</li> </ol> <p>Hence, the total space complexity is \\(O(M + K)\\). In the worst case, this becomes \\(O(N)\\), where \\(N\\) is the number of elements in <code>nums</code> and all elements are unique.</p>"},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/#using-min-heap","title":"Using Min Heap","text":"<p>The min heap now keeps the least frequent elements at the top. When its size exceeds <code>k</code>, the least frequent element is popped out, ensuring that only the <code>k</code> most frequent elements remain.</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        // Using unordered_map for frequency mapping\n        unordered_map&lt;int, int&gt; freqMap;\n        for (int num : nums) {\n            freqMap[num]++;\n        }\n\n        // Custom comparator for min heap\n        auto comp = [&amp;freqMap](int n1, int n2) { return freqMap[n1] &gt; freqMap[n2]; };\n        priority_queue&lt;int, vector&lt;int&gt;, decltype(comp)&gt; minHeap(comp);\n\n        // Keep the size of the heap to k\n        for (auto&amp; [num, freq] : freqMap) {\n            minHeap.push(num);\n            if (minHeap.size() &gt; k) {\n                minHeap.pop();\n            }\n        }\n\n        // Prepare the result vector\n        vector&lt;int&gt; topK;\n        topK.reserve(k); // Reserve space for k elements\n        while (!minHeap.empty()) {\n            topK.push_back(minHeap.top());\n            minHeap.pop();\n        }\n\n        return topK;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N\\log k)\\);</li> <li>Space complexity: \\(O(N + k)\\).</li> </ul>"},{"location":"Leetcode/0300-0399/0347-top-k-frequent-elements/#counting-sort","title":"Counting Sort","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; hashing;\n        for (auto elm : nums) hashing[elm]++;\n        int n = nums.size();\n        vector&lt;int&gt; count(n + 1, 0);\n        for (auto &amp;p : hashing) count[p.second]++;\n        int i = n, t = 0;\n        while (t &lt; k) t += count[i--];\n        vector&lt;int&gt; res;\n        for (auto &amp;p : hashing) {\n            if (p.second &gt; i) res.push_back(p.first);\n        }\n        return res;\n    }\n};\n</code></pre> <p>Code with comments:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        // Create a hash map to store the frequency of each number\n        unordered_map&lt;int, int&gt; cnt;\n        for (auto elm : nums) cnt[elm]++;\n\n        // Get the size of the input vector\n        int n = nums.size();\n\n        // Create a vector to count the frequencies of frequencies\n        vector&lt;int&gt; count(n + 1, 0);\n        for (auto [elm, freq] : cnt) count[freq]++;\n\n        // Find the minimum frequency that allows us to reach k elements\n        int threshold = n, t = 0;\n        while (t &lt; k) t += count[threshold--];\n\n        // Collect elements whose frequency is greater than the threshold\n        vector&lt;int&gt; res;\n        for (auto [elm, freq] : cnt) {\n            if (freq &gt; threshold) res.push_back(elm);\n        }\n\n        return res;\n    }\n};\n</code></pre> <p>Explanation:</p> <ol> <li>Frequency Mapping: The algorithm starts by creating a hash map (<code>unordered_map</code>) to count the frequency of each element in the input vector <code>nums</code>.</li> <li>Frequency of Frequencies: It then creates a vector <code>count</code> where <code>count[i]</code> represents how many elements appear exactly <code>i</code> times in <code>nums</code>. This is a key step that differentiates this solution from others, as it essentially performs a counting sort on the frequencies.</li> <li>Finding the Threshold: The algorithm then determines the minimum frequency (<code>threshold</code>) that is needed to ensure that the sum of the counts of elements with frequency higher than <code>threshold</code> is at least <code>k</code>. This step ensures that we include only the top <code>k</code> frequent elements.</li> <li>Collecting Results: Finally, it iterates over the frequency map again and adds elements to the result vector <code>res</code> if their frequency is greater than the determined <code>threshold</code>.</li> </ol> <p>Time Complexity Analysis:</p> <ol> <li>Frequency Mapping: \\(O(N)\\), where N is the number of elements in <code>nums</code>.</li> <li>Counting Frequencies: \\(O(N)\\), as it iterates over the frequency map which can have at most \\(N\\) unique elements.</li> <li>Finding the Threshold: \\(O(N)\\), in the worst case, it might iterate through the entire <code>count</code> vector.</li> <li>Collecting Results: \\(O(N)\\), as it iterates over the frequency map again.</li> </ol> <p>Overall, the time complexity is \\(O(N)\\), which is quite efficient as it linearly scales with the input size.</p> <p>Space Complexity Analysis:</p> <ol> <li>Frequency Map: \\(O(N)\\), for storing the frequency of each element.</li> <li>Count Vector: \\(O(N)\\), for counting the frequencies of frequencies.</li> <li>Result Vector: \\(O(K)\\), for storing the top \\(k\\) frequent elements.</li> </ol> <p>Thus, the total space complexity is \\(O(N + K)\\), which is mainly dominated by the size of the input and the frequency map.</p>"},{"location":"Leetcode/0300-0399/0349-intersection-of-two-arrays/","title":"Intersection of Two Arrays","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0349-intersection-of-two-arrays/#description","title":"Description","text":"<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums1 = [1,2,2,1]</code>, <code>nums2 = [2,2]</code></li> <li>Output: <code>[2]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums1 = [4,9,5]</code>, <code>nums2 = [9,4,9,8,4]</code></li> <li>Output: <code>[9,4]</code></li> <li>Explanation: <code>[4,9]</code> is also accepted.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li> <li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0300-0399/0349-intersection-of-two-arrays/#solution","title":"Solution","text":""},{"location":"Leetcode/0300-0399/0349-intersection-of-two-arrays/#hash-map-way-1","title":"Hash Map Way 1","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        unordered_set&lt;int&gt; result_set;\n        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());\n\n        for (auto num: nums2) {\n            if (nums_set.find(num) != nums_set.end())\n                result_set.insert(num);\n        }\n        return vector&lt;int&gt;(result_set.begin(), result_set.end());\n    }\n};\n</code></pre>"},{"location":"Leetcode/0300-0399/0349-intersection-of-two-arrays/#hash-map-way-2","title":"Hash Map Way 2","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        unordered_set&lt;int&gt; S;\n        for (auto x : nums1) S.insert(x);\n\n        vector&lt;int&gt; res;\n        for (auto y : nums2) {\n            if (S.count(y)) {\n                res.push_back(y);\n                /*\n                It ensures that each element from nums2 is only added once to the result, even if nums2 contains duplicates. It also reduces the number of unnecessary checks for subsequent elements in nums2. Once an element from nums2 is found in S and added to res, it doesn't need to be checked again.\n                */\n                S.erase(y);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0300-0399/0377-combination-sum-iv/","title":"Combination Sum IV","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0377-combination-sum-iv/#description","title":"Description","text":"<p>Given an array of distinct integers <code>nums</code> and a target integer <code>target</code>, return the number of possible combinations that add up to <code>target</code>.</p> <p>The test cases are generated so that the answer can fit in a 32-bit integer.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,2,3], target = 4</code></li> <li>Output: <code>7</code></li> <li>Explanation:</li> </ul> <pre><code>The possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>nums = [9], target = 3</code></li> <li>Output: <code>0</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 200</code></li> <li><code>1 &lt;= nums[i] &lt;= 1000</code></li> <li>All the elements of <code>nums</code> are unique.</li> <li><code>1 &lt;= target &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0300-0399/0377-combination-sum-iv/#solution","title":"Solution","text":"<p>See reference (Chinese).</p> <pre><code>class Solution {\npublic:\n    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; dp(target + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i &lt;= target; i++) {\n            for (int j = 0; j &lt; nums.size(); j++) {\n                if (i &gt;= nums[j] &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) \n                    dp[i] += dp[i - nums[j]];\n            }\n        }\n        return dp[target];\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; dp(target + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i &lt;= target; i++) {\n            for (int j = 0; j &lt; nums.size(); j++) {\n                if (i &gt;= nums[j]) \n                    dp[i] = (0LL + dp[i] + dp[i - nums[j]]) % INT_MAX;\n            }\n        }\n        return dp[target];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0300-0399/0383-ransom-note/","title":"Ransom Note","text":"<p>Link</p>"},{"location":"Leetcode/0300-0399/0383-ransom-note/#description","title":"Description","text":"<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> if <code>ransomNote</code> can be constructed by using the letters from <code>magazine</code> and <code>false</code> otherwise.</p> <p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>ransomNote = \"a\", magazine = \"b\"</code></li> <li>Output: <code>false</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>ransomNote = \"aa\", magazine = \"ab\"</code></li> <li>Output: <code>false</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>ransomNote = \"aa\", magazine = \"aab\"</code></li> <li>Output: <code>true</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code></li> <li><code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.</li> </ul>"},{"location":"Leetcode/0300-0399/0383-ransom-note/#solution","title":"Solution","text":""},{"location":"Leetcode/0300-0399/0383-ransom-note/#hash-map","title":"Hash Map","text":"<p>We can check if the count of each character in the <code>ransomNote</code> is less than or equal to the count of that character in the <code>magazine</code>. If it's greater, it means there aren't enough characters in the <code>magazine</code> to form the <code>ransomNote</code>.</p> <pre><code>class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map&lt;int, int&gt; mapping;\n        for (auto c : magazine) {\n            //Record the number of occurrences of each character in the \"magazine\" through \"mapping\"\n            mapping[c - 'a']++;\n        }\n        // Traverse \"randomNote\" and do the -- operation on the corresponding number of characters in the \"mapping\"\n        for (auto c : ransomNote) {\n            // If it is less than zero, it means that the characters appearing in \"randomNote\" are not in the \"magazine\"\n            if (--mapping[c - 'a'] &lt; 0)\n                return false;\n        }\n        return true;\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map&lt;char, int&gt; hash;\n        for (auto c : magazine) hash[c]++;\n        for (auto c : ransomNote) {\n            if (!hash[c]) return false;\n            else hash[c]--;\n        }\n        return true;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n)\\)</p>"},{"location":"Leetcode/0400-0499/0404-sum-of-left-leaves/","title":"Sum of Left Leaves","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0404-sum-of-left-leaves/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the sum of all left leaves.</p> <p>A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [3,9,20,null,null,15,7]</code></li> <li>Output: <code>24</code></li> <li>Explanation: There are two left leaves in the binary tree, with values <code>9</code> and <code>15</code> respectively.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1]</code></li> <li>Output: <code>0</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0400-0499/0404-sum-of-left-leaves/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0404-sum-of-left-leaves/#recursive-solution-post-order","title":"Recursive Solution (Post-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        if (!root) return 0;\n        int leftVal = 0;\n        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)\n            leftVal = root-&gt;left-&gt;val;\n        return leftVal + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0404-sum-of-left-leaves/#iterative-solution","title":"Iterative Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stk;\n        auto curr = root;\n        int res = 0;\n        while (curr || !stk.empty()) {\n            if (curr) {\n                if (curr-&gt;left &amp;&amp; !curr-&gt;left-&gt;left &amp;&amp; !curr-&gt;left-&gt;right) res += curr-&gt;left-&gt;val;\n                stk.push(curr);\n                curr = curr-&gt;left;\n            } else {\n                auto t = stk.top();\n                stk.pop();\n                curr = t-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/","title":"Partition Equal Subset Sum","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#description","title":"Description","text":"<p>Given an integer array <code>nums</code>, return <code>true</code> if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or <code>false</code> otherwise.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,5,11,5]</code></li> <li>Output: <code>true</code></li> <li>Explanation: The array can be partitioned as <code>[1, 5, 5]</code> and <code>[11]</code>.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1,2,3,5]</code></li> <li>Output: <code>false</code></li> <li>Explanation: The array cannot be partitioned into equal sum subsets.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 200</code></li> <li><code>1 &lt;= nums[i] &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n        vector&lt;int&gt; dp(10001, 0);\n        for (int i = 0; i &lt; nums.size(); i++) sum += nums[i];\n        if (sum % 2 == 1) return false;\n        int target = sum / 2;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = target; j &gt;= nums[i]; j--) {\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n        if (dp[target] == target) return true;\n        return false;\n    }\n};\n</code></pre> <p>Connection to 0-1 Knapsack Problem:</p> <p>The 0-1 Knapsack problem involves choosing items with given weights to maximize the total value without exceeding a given weight limit. Here, we tweak this idea:</p> <ul> <li>'Weights' of items: The elements in <code>nums</code>.</li> <li>'Weight limit' (knapsack capacity): Half of the total sum of elements in <code>nums</code>. This is because if one subset can reach half the total sum, the other subset automatically has the remaining elements, making their sums equal.</li> <li>'Values' of items: In the traditional knapsack problem, each item has a value. Here, the value is the same as the weight, as we're interested in the sum.</li> </ul> <p>The problem becomes finding a subset of <code>nums</code> whose sum is exactly half of the total sum.</p> <p>Analysis:</p> <ol> <li>Calculate Total Sum and Target:</li> <li>First, calculate the total sum of elements in <code>nums</code>.</li> <li>If the sum is odd, it's impossible to split into two equal parts, hence return <code>false</code>.</li> <li>Otherwise, set <code>target</code> as half of the total sum.</li> <li>Dynamic Programming Array Initialization:</li> <li>A <code>dp</code> array of size 10001 is initialized with zeros. This array will store the best sum achievable using subsets of the elements up to the current element.</li> <li>Populating the DP Array:</li> <li>For each element <code>num</code> in <code>nums</code>, iterate backward from <code>target</code> to <code>num</code>.</li> <li>Update <code>dp[j]</code> with the maximum of <code>dp[j]</code> and <code>dp[j - nums[i]] + nums[i]</code>.<ul> <li><code>dp[j]</code>: Best sum achievable without the current element.</li> <li><code>dp[j - nums[i]] + nums[i]</code>: Best sum achievable by including the current element.</li> </ul> </li> <li>This process essentially tries to find the best sum close to <code>target</code> achievable with the current set of elements.</li> <li>1-Dimensional Array for Space Optimization:</li> <li>Instead of a 2D array (common in knapsack problems), a 1D array is used.</li> <li>Each element <code>dp[j]</code> gets updated based on its previous state and the state <code>j - nums[i]</code> steps before.</li> <li>This is possible because we only need information from the previous iteration (i.e., when considering the previous element in <code>nums</code>), not the entire history.</li> <li>Checking for Solution:</li> <li>If <code>dp[target]</code> equals <code>target</code>, it means there exists a subset of <code>nums</code> whose sum is exactly <code>target</code>. Hence, return <code>true</code>.</li> <li>Otherwise, return <code>false</code>.</li> </ol> <p>Complexity:</p> <ul> <li>Space Complexity: Reduced from \\(O(n\\times \\mathrm{sum})\\) in a 2D approach to \\(O(\\mathrm{sum})\\), where <code>sum</code> is the total sum of elements in <code>nums</code>.</li> <li>Time Complexity: \\(O(n\\times \\mathrm{target})\\).</li> </ul>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(), sum = 0;\n        for (int x : nums) sum += x;\n\n        if (sum % 2) return false;\n        else sum /= 2;\n\n        vector&lt;int&gt; dp(sum + 1, 0);\n        dp[0] = 1;\n        for (int x : nums) {\n            for (int j = sum; j &gt;= x; j--) {\n                dp[j] |= dp[j - x];\n            }\n        }\n        return dp[sum];\n    }\n};\n</code></pre> <p>Explanation:</p> <ol> <li>Calculate Total Sum and Target:</li> <li>The total sum of elements in <code>nums</code> is calculated.</li> <li>If the sum is odd (<code>sum % 2</code>), it's impossible to split into two equal sums, hence return <code>false</code>.</li> <li>Otherwise, the target is set to half of the total sum.</li> <li>Dynamic Programming (DP) Array Initialization:</li> <li>A <code>dp</code> array of size <code>sum + 1</code> is initialized to zero, except <code>dp[0]</code> which is set to 1.</li> <li><code>dp[i]</code> will represent whether it's possible to achieve a sum of <code>i</code> using the elements from <code>nums</code>.</li> <li>Populating the DP Array:</li> <li>Iterate over each element <code>x</code> in <code>nums</code>.</li> <li>For each <code>x</code>, iterate backward from <code>sum</code> to <code>x</code>.</li> <li>Update <code>dp[j]</code> using the bitwise OR operator: <code>dp[j] |= dp[j - x]</code>.</li> </ol> <p>Understanding <code>dp[j] |= dp[j - x]</code>:</p> <ul> <li><code>dp[j]</code>: Represents if it's possible to achieve a sum of <code>j</code> with the current set of elements.</li> <li><code>dp[j - x]</code>: Represents if it's possible to achieve a sum of <code>j - x</code> with the elements considered so far. If this is true, then adding <code>x</code> to this subset would achieve the sum <code>j</code>.</li> </ul> <p>The bitwise OR operation <code>|=</code> is used here for a critical reason:</p> <ul> <li><code>dp[j] |= dp[j - x]</code> effectively sets <code>dp[j]</code> to 1 if either <code>dp[j]</code> was already 1 (meaning a sum of <code>j</code> was already achievable) or if <code>dp[j - x]</code> is 1 (meaning by adding the current element <code>x</code>, we can achieve a sum of <code>j</code>).</li> <li>It's a concise way of saying <code>dp[j] = dp[j] || dp[j - x]</code>, where <code>||</code> is the logical OR operator.</li> </ul> <p>This approach updates the DP array to reflect whether each target sum is achievable with the current subset of numbers.</p>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#way-3","title":"Way 3","text":"<pre><code>class Solution {\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) {\n        bitset&lt;10001&gt; f;\n        f[0] = 1;\n        int sum = 0;\n        for (auto x : nums) {\n            f |= f &lt;&lt; x;\n            sum += x;\n        }\n        if (sum % 2) return false;\n        return f[sum / 2];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0416-partition-equal-subset-sum/#way-4","title":"Way 4","text":"<p>Hash Table Solution:</p> <pre><code>class Solution {\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if (sum % 2) return false;\n        int target = sum / 2;\n        unordered_set&lt;int&gt; memo{0};\n        for (auto n : nums) {\n            unordered_set&lt;int&gt; new_sums{};\n            for (int sum : memo) {\n                if (sum + n == target) return true;\n                if (memo.count(sum + n)) continue;\n                new_sums.emplace(sum + n);\n            }\n            memo.insert(new_sums.begin(), new_sums.end());\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0454-4sum-ii/","title":"4Sum II","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0454-4sum-ii/#description","title":"Description","text":"<p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p> <ul> <li><code>0 &lt;= i, j, k, l &lt; n</code></li> <li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li> </ul> <p>Example 1:</p> <ul> <li>Input: <code>nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</code></li> <li>Output: 2</li> </ul> <p>Explanation:</p> <p>The two tuples are:</p> <ol> <li><code>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</code></li> <li><code>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</code></li> </ol> <p>Example 2:</p> <ul> <li>Input: <code>nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</code></li> <li>Output: 1</li> </ul> <p>Constraints:</p> <ul> <li><code>n == nums1.length</code></li> <li><code>n == nums2.length</code></li> <li><code>n == nums3.length</code></li> <li><code>n == nums4.length</code></li> <li><code>1 &lt;= n &lt;= 200</code></li> <li><code>-2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28</code></li> </ul>"},{"location":"Leetcode/0400-0499/0454-4sum-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0454-4sum-ii/#hash-map","title":"Hash Map","text":"<p>Steps to solve this problem:</p> <ol> <li>First, define an <code>unordered_map</code>, put the key in the sum of the two numbers <code>num1</code> and <code>num2</code>, and the value in the number of times the sum of the two numbers <code>num1</code> and <code>num2</code> occurs.</li> <li>Iterate through the large <code>nums1</code> and <code>nums2</code> arrays, count the sum of the elements of the two arrays and the number of occurrences, and put them into the map.</li> <li>Define the int variable <code>res</code> to count the number of times <code>a + b + c + d == 0</code>.</li> <li>Iterate through the big <code>nums3</code> and big <code>nums4</code> arrays, and find out if <code>0 - (c + d)</code> has appeared in the map, then use res to count the value corresponding to the key in the map, that is, the number of times it has appeared.</li> <li>Finally, return the count value <code>res</code> can be.</li> </ol> <pre><code>class Solution {\npublic:\n    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) {\n        unordered_map&lt;int, int&gt; mapping;\n        for (auto num1 : nums1) {\n            for (auto num2 : nums2) {\n                mapping[num1 + num2]++;\n            }\n        }\n        int res = 0;\n        for (auto num3 : nums3) {\n            for (auto num4 : nums4) {\n                auto temp = -(num3 + num4);\n                if (mapping.count(temp)) res += mapping[temp];\n                //the two lines of code above can be replaced with this one line of code:\n                //res += mapping[-(num3 + num4)];\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Note: Hash Mapping Indexing</p> <p>Time and space complexity: \\(O(n^2)\\)</p>"},{"location":"Leetcode/0400-0499/0459-repeated-substring-pattern/","title":"Repeated Substring Pattern","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0459-repeated-substring-pattern/#description","title":"Description","text":"<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"abab\"</code></li> <li>Output: <code>true</code></li> <li>Explanation: <code>It is the substring \"ab\" twice.</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"aba\"</code></li> <li>Output: <code>false</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>s = \"abcabcabcabc\"</code></li> <li>Output: <code>true</code></li> <li>Explanation: <code>It is the substring \"abc\" four times or the substring \"abcabc\" twice.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^4</code></li> <li><code>s</code> consists of lowercase English letters.</li> </ul>"},{"location":"Leetcode/0400-0499/0459-repeated-substring-pattern/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0459-repeated-substring-pattern/#moving-match","title":"Moving Match","text":"<pre><code>class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string t = s + s;\n        t.erase(t.begin()); t.erase(t.end() - 1);\n        if (t.find(s) != string::npos) return true;\n        return false;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul> <p>Easier way of writing (see reference):</p> <pre><code>class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        return (s + s).find(s, 1) != s.size();\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0459-repeated-substring-pattern/#kmp","title":"KMP","text":"<pre><code>class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        int n = s.size();\n        s = ' ' + s;\n        vector&lt;int&gt; ne(n + 1, 0);\n        for (int i = 2, j = 0; i &lt;= n; i++) {\n            while (j &amp;&amp; s[i] != s[j + 1]) j = ne[j];\n            if (s[i] == s[j + 1]) j++;\n            ne[i] = j;\n        }\n        int t = n - ne[n];\n        return t &lt; n &amp;&amp; n % t == 0;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul> <p>The <code>ne</code> is essentially the LPS (Longest Proper Prefix which is also Suffix) array used in KMP. It stores the length of the longest proper prefix that is also a proper suffix for every substring of <code>s</code>.</p> <ul> <li><code>ne[i]</code>: The length of the longest proper prefix of the substring <code>s[1..i]</code> which is also a proper suffix of <code>s[1..i]</code>.</li> </ul> <p>Code Explanation:</p> <ol> <li>Initialization:</li> <li><code>n</code>: Length of the string <code>s</code>.</li> <li><code>s = ' ' + s</code>: The string <code>s</code> is modified by adding a space at the beginning. This is done to make the string 1-indexed, simplifying the algorithm's logic.</li> <li><code>vector&lt;int&gt; ne(n + 1, 0)</code>: Initializes the <code>ne</code> array of size <code>n+1</code> with all elements as 0.</li> <li>Building the <code>ne</code> Array:</li> <li>The loop <code>for (int i = 2, j = 0; i &lt;= n; i++)</code> iterates over the string.</li> <li><code>while (j &amp;&amp; s[i] != s[j + 1]) j = ne[j]</code>: This line checks if the current character doesn't match the character in the pattern. If they don't match, we fall back to the previous position's <code>ne</code> value.</li> <li><code>if (s[i] == s[j + 1]) j++</code>: If the characters match, we increment <code>j</code>.</li> <li><code>ne[i] = j</code>: Assign the calculated <code>ne</code> value for the position <code>i</code>.</li> <li>Checking for Repeated Substring Pattern:</li> <li><code>int t = n - ne[n]</code>: This calculates the length of the smallest repeating unit.</li> <li><code>return t &lt; n &amp;&amp; n % t == 0</code>: Checks if the length of the repeating unit is less than <code>n</code> and if <code>n</code> is a multiple of <code>t</code>.</li> </ol> <p>Why \"n - ne[n]\" is the Length of the Repeated Substring?:</p> <ul> <li><code>ne[n]</code> gives the length of the longest proper prefix which is also a suffix for the entire string.</li> <li>Subtracting this from the total length (<code>n - ne[n]</code>) gives us the smallest segment of the string that, when repeated, could recreate the original string.</li> <li>If this segment is smaller than the entire string and the total length of the string is a multiple of this segment's length, it implies that the string is composed of repeated occurrences of this segment.</li> </ul> <p>Correctness of the Algorithm:</p> <ul> <li>The preprocessing part correctly computes the <code>ne</code> array which captures the prefix-suffix relationship in the string.</li> <li>The check <code>n % t == 0</code> ensures that the entire string can be constructed by repeating this smallest segment.</li> <li>Since the <code>ne</code> array is constructed to reflect the longest repeating prefix-suffix pattern in the string, using <code>n - ne[n]</code> to find the smallest repeating unit is logically sound.</li> </ul>"},{"location":"Leetcode/0400-0499/0474-ones-and-zeroes/","title":"Ones and Zeroes","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0474-ones-and-zeroes/#description","title":"Description","text":"<p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p> <p>Return the size of the largest subset of <code>strs</code> such that there are at most <code>m</code> <code>0</code>'s and <code>n</code> <code>1</code>'s in the subset.</p> <p>A set <code>x</code> is a subset of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3</code></li> <li>Output: <code>4</code></li> <li>Explanation: The largest subset with at most 5 0's and 3 1's is <code>{\"10\", \"0001\", \"1\", \"0\"}</code>, so the answer is <code>4</code>. Other valid but smaller subsets include <code>{\"0001\", \"1\"}</code> and <code>{\"10\", \"1\", \"0\"}</code>. <code>{\"111001\"}</code> is an invalid subset because it contains 4 1's, greater than the maximum of 3.</li> </ul> <p>Example 2:</p> <ul> <li>Input: `strs = [\"10\",\"0\",\"1\"], m = 1, n = 1</li> <li>Output: <code>2</code></li> <li>Explanation: The largest subset is <code>{\"0\", \"1\"}</code>, so the answer is <code>2</code>.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= strs.length &lt;= 600</code></li> <li><code>1 &lt;= strs[i].length &lt;= 100</code></li> <li><code>strs[i]</code> consists only of digits <code>'0'</code> and <code>'1'</code>.</li> <li><code>1 &lt;= m, n &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0400-0499/0474-ones-and-zeroes/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0474-ones-and-zeroes/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    int count(const string &amp;str, const char c) const {\n        int cnt = 0;\n        for (char ch : str) {\n            if (ch == c) cnt++;\n        }\n        return cnt;\n    }\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {\n        vector&lt;int&gt; zeros(strs.size() + 1), ones(strs.size() + 1);\n        for (int i = 1; i &lt;= strs.size(); i++) {\n            zeros[i] = count(strs[i - 1], '0');\n            ones[i] = count(strs[i - 1], '1');\n        }\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n        dp[0][0] = 0;\n\n        for (int i = 1; i &lt;= strs.size(); i++) {\n            for (int j = m; j &gt;= zeros[i]; j--) {\n                for (int k = n; k &gt;= ones[i]; k--) {\n                    dp[j][k] = max(dp[j][k], dp[j - zeros[i]][k - ones[i]] + 1);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n\n        for (string str : strs) {\n            int one = 0, zero = 0;\n            for (char c : str) {\n                (c == '0') ? zero++ : one++;\n            }\n            for (int i = m; i &gt;= zero; i--) {\n                for (int j = n; j &gt;= one; j--) {\n                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(knm)\\), where \\(k\\) is the number of elements of <code>strs</code>;</li> <li>Space complexity: \\(O(mn)\\).</li> </ul>"},{"location":"Leetcode/0400-0499/0491-non-decreasing-subsequences/","title":"Non-decreasing Subsequences","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0491-non-decreasing-subsequences/#description","title":"Description","text":"<p>Given an integer array <code>nums</code>, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [4,6,7,7]</code></li> <li>Output: <code>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [4,4,3,2,1]</code></li> <li>Output: <code>[[4,4]]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 15</code></li> <li><code>-100 &lt;= nums[i] &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0400-0499/0491-non-decreasing-subsequences/#solution","title":"Solution","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        if (path.size() &gt; 1) res.push_back(path);\n\n        unordered_set&lt;int&gt; used;\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (used.find(nums[i]) != used.end()) continue;\n            if (!path.empty() &amp;&amp; nums[i] &lt; path.back()) continue;\n\n            used.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) {\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\times 2^n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul> <p>Optimized solution:</p> <pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        if (path.size() &gt; 1) res.push_back(path);\n\n        bool used[210] = {false};\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (used[nums[i] + 100]) continue;\n            if (!path.empty() &amp;&amp; nums[i] &lt; path.back()) continue;\n\n            used[nums[i] + 100] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) {\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0494-target-sum/","title":"Target Sum","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0494-target-sum/#description","title":"Description","text":"<p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p> <p>You want to build an expression out of nums by adding one of the symbols <code>'+'</code> and <code>'-'</code> before each integer in <code>nums</code> and then concatenate all the integers.</p> <p>For example, if <code>nums = [2, 1]</code>, you can add a <code>'+'</code> before <code>2</code> and a <code>'-'</code> before <code>1</code> and concatenate them to build the expression <code>\"+2-1\"</code>. Return the number of different expressions that you can build, which evaluates to <code>target</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,1,1,1,1], target = 3</code></li> <li>Output: <code>5</code></li> <li>Explanation: There are <code>5</code> ways to assign symbols to make the sum of nums be target <code>3</code>.</li> </ul> <pre><code>-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1], target = 1</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 20</code></li> <li><code>0 &lt;= nums[i] &lt;= 1000</code></li> <li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li> <li><code>-1000 &lt;= target &lt;= 1000</code></li> </ul>"},{"location":"Leetcode/0400-0499/0494-target-sum/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0494-target-sum/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\n        int n = nums.size(), offset = 1000;\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2001, 0));\n        dp[0][offset] = 1;\n        for (int i = 1; i &lt;= nums.size(); i++) {\n            for (int j = -1000; j &lt;= 1000; j++) {\n                if (j - nums[i - 1] &gt;= -1000)\n                    dp[i][j + offset] += dp[i - 1][j - nums[i - 1] + offset];\n                if (j + nums[i - 1] &lt;= 1000)\n                    dp[i][j + offset] += dp[i - 1][j + nums[i - 1] + offset];\n            }\n        }\n        return dp[n][target + offset];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0400-0499/0494-target-sum/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if (abs(target) &gt; sum || (sum + target) % 2) return 0;\n        int m = (sum + target) / 2;\n        vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1, vector&lt;int&gt;(m + 1, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i &lt;= nums.size(); i++) {\n            for (int j = 0; j &lt;= m; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j &gt;= nums[i - 1])\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]];\n            }\n        }\n        return dp[nums.size()][m];\n    }\n};\n</code></pre> <p>Mapping to Subset Sum Problem:</p> <ol> <li>Sum of all Elements: Let's denote the sum of all elements in <code>nums</code> as <code>sum</code>.</li> <li>Partitioning into Two Subsets: Imagine splitting the <code>nums</code> array into two subsets, <code>S1</code> and <code>S2</code>, where <code>S1</code> contains elements with a '+' sign, and <code>S2</code> contains elements with a '-' sign. Then, the problem boils down to finding subsets <code>S1</code> and <code>S2</code> such that <code>sum(S1) - sum(S2) = target</code>.</li> <li>Rearranging the Equation: Rearranging the equation, we get <code>sum(S1) = (target + sum(S2)) = (target + sum - sum(S1))</code>. Simplifying, <code>2 * sum(S1) = target + sum</code>.</li> <li> <p>Finding sum(S1): The problem now is to find a subset <code>S1</code> such that <code>sum(S1) = (target + sum) / 2</code>. This is a standard subset sum problem.</p> </li> <li> <p>Time Complexity: \\(O(nm)\\) where \\(n\\) is the number of elements in nums and \\(m\\) is <code>(sum + target) / 2</code>.</p> </li> <li>Space Complexity: \\(O(nm)\\) due to the 2D array.</li> </ol>"},{"location":"Leetcode/0400-0499/0494-target-sum/#way-3","title":"Way 3","text":"<pre><code>class Solution {\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\n        int sum = 0;\n        for (auto x : nums) sum += x;\n        if (abs(target) &gt; sum) return 0;\n        if ((sum + target) % 2) return 0;\n        int m = (sum + target) / 2;\n        vector&lt;int&gt; dp(m + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = m; j &gt;= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[m];\n    }\n};\n</code></pre> <ul> <li>Time Complexity: Same as the 2D approach, \\(O(nm)\\).</li> <li>Space Complexity: \\(O(m)\\), a significant improvement over the 2D approach, as we are only using a single array of size \\(m + 1\\).</li> </ul>"},{"location":"Leetcode/0400-0499/0496-next-greater-element-i/","title":"Next Greater Element I","text":"<p>Link</p>"},{"location":"Leetcode/0400-0499/0496-next-greater-element-i/#description","title":"Description","text":"<p>The next greater element of some element <code>x</code> in an array is the first greater element that is to the right of <code>x</code> in the same array.</p> <p>You are given two distinct 0-indexed integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p> <p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the next greater element of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.</p> <p>Return an array <code>ans</code> of length <code>nums1.length</code> such that <code>ans[i]</code> is the next greater element as described above.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums1 = [4,1,2], nums2 = [1,3,4,2]</code></li> <li>Output: <code>[-1,3,-1]</code></li> <li>Explanation: The next greater element for each value of <code>nums1</code> is as follows:<ul> <li>4 is underlined in <code>nums2 = [1,3,4,2]</code>. There is no next greater element, so the answer is -1.</li> <li>1 is underlined in <code>nums2 = [1,3,4,2]</code>. The next greater element is 3.</li> <li>2 is underlined in <code>nums2 = [1,3,4,2]</code>. There is no next greater element, so the answer is -1.</li> </ul> </li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums1 = [2,4], nums2 = [1,2,3,4]</code></li> <li>Output: <code>[3,-1]</code></li> <li>Explanation: The next greater element for each value of <code>nums1</code> is as follows:<ul> <li>2 is underlined in <code>nums2 = [1,2,3,4]</code>. The next greater element is 3.</li> <li>4 is underlined in <code>nums2 = [1,2,3,4]</code>. There is no next greater element, so the answer is -1.</li> </ul> </li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li> <li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10^4</code></li> <li>All integers in <code>nums1</code> and <code>nums2</code> are unique.</li> <li>All the integers of <code>nums1</code> also appear in <code>nums2</code>.</li> </ul>"},{"location":"Leetcode/0400-0499/0496-next-greater-element-i/#solution","title":"Solution","text":""},{"location":"Leetcode/0400-0499/0496-next-greater-element-i/#solution-1","title":"Solution 1","text":"<ul> <li>Use a decreasing monotonic stack to find the next greater element for each element in <code>nums2</code>.</li> <li>Store these mappings (element to its next greater element) in a hash map.</li> <li>Iterate through <code>nums1</code> and use the hash map to find the next greater element for each number. If it doesn't exist in the hash map, it means there is no next greater element, so we use -1.</li> </ul> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        stack&lt;int&gt; stk;\n        unordered_map&lt;int, int&gt; nextGreater;\n\n        // Building the map for next greater elements in nums2\n        for (int num : nums2) {\n            while (!stk.empty() &amp;&amp; stk.top() &lt; num) {\n                nextGreater[stk.top()] = num;\n                stk.pop();\n            }\n            stk.push(num);\n        }\n\n        // Filling the results for nums1 based on the map\n        vector&lt;int&gt; res;\n        for (int num : nums1) {\n            if (nextGreater.find(num) != nextGreater.end())\n                res.push_back(nextGreater[num]);\n            else\n                res.push_back(-1);\n        }\n\n        return res;\n    }\n};\n</code></pre> <ul> <li>The stack <code>s</code> keeps track of elements in <code>nums2</code> for which we are yet to find the next greater element.</li> <li>When iterating through <code>nums2</code>, if we find an element greater than the element on the top of the stack, it means we've found the next greater element for the stack's top element. We record this in the <code>nextGreater</code> map.</li> <li>Finally, for each element in <code>nums1</code>, we look up the <code>nextGreater</code> map. If an entry exists, we add it to the result; otherwise, we add -1.</li> </ul> <p>Complexity:</p> <ul> <li>Time complexity: \\(O(N+M)\\), where \\(N\\) and \\(M\\) are the lengths of <code>nums1</code> and <code>nums2</code>, respectively;</li> <li>Space complexity: \\(O(N)\\).</li> </ul>"},{"location":"Leetcode/0400-0499/0496-next-greater-element-i/#solution-2","title":"Solution 2","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; res(nums1.size(), -1);  // Initialize the result array with -1 for each element in nums1\n\n        // Create a mapping from elements of nums1 to their indices\n        unordered_map&lt;int, int&gt; mapping;\n        for (int i = 0; i &lt; nums1.size(); i++) mapping[nums1[i]] = i;\n\n        // Push the first index of nums2 onto the stack\n        stk.push(0);\n\n        // Iterate through nums2 to find next greater elements\n        for (int i = 1; i &lt; nums2.size(); i++) {\n            // Check if the current element is greater than the element at the index on top of the stack\n            while (!stk.empty() &amp;&amp; nums2[i] &gt; nums2[stk.top()]) {\n                // If the element at the top of the stack is in nums1 (using mapping)\n                if (mapping.count(nums2[stk.top()])) {\n                    int index = mapping[nums2[stk.top()]];  // Get the corresponding index in nums1\n                    res[index] = nums2[i];  // Update the result array for that element in nums1\n                }\n                stk.pop();  // Pop the element from the stack as we've found its next greater element\n            }\n            stk.push(i);  // Push the current index onto the stack\n        }\n\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N+M)\\), where \\(N\\) and \\(M\\) are the lengths of <code>nums1</code> and <code>nums2</code>, respectively;</li> <li>Space complexity: \\(O(N+M)\\).</li> </ul>"},{"location":"Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/","title":"Minimum Absolute Difference in BST","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#description","title":"Description","text":"<p>Given the <code>root</code> of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [4,2,6,1,3]</code></li> <li>Output: <code>1</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,0,48,null,null,12,49]</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[2, 10^4]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 10^5</code></li> </ul>"},{"location":"Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#way-1","title":"Way 1","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    vector&lt;int&gt; inorder;\n    void traversal(TreeNode* root) {\n        if (!root) return;\n        traversal(root-&gt;left);\n        inorder.push_back(root-&gt;val);\n        traversal(root-&gt;right);\n    }\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        traversal(root);\n        int minVal = INT_MAX;\n        for (int i = 1; i &lt; inorder.size(); i++) {\n            minVal = min(minVal, inorder[i] - inorder[i - 1]);\n        }\n        return minVal;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#way-2","title":"Way 2","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* pre;\n    int res = INT_MAX;\n    void traversal(TreeNode* root) {\n        if (!root) return;\n        traversal(root-&gt;left);\n        if (pre) res = min(res, root-&gt;val - pre-&gt;val);\n        pre = root;\n        traversal(root-&gt;right);\n    }\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        traversal(root);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity (worst): \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0500-0599/0503-next-greater-element-ii/","title":"Next Greater Element II","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0503-next-greater-element-ii/#description","title":"Description","text":"<p>Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return the next greater number for every element in <code>nums</code>.</p> <p>The next greater number of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return <code>-1</code> for this number.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [1,2,1]</code></li> <li>Output: <code>[2,-1,2]</code></li> <li>Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number. The second 1's next greater number needs to search circularly, which is also 2.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [1,2,3,4,3]</code></li> <li>Output: <code>[2,3,4,-1,4]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> </ul>"},{"location":"Leetcode/0500-0599/0503-next-greater-element-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0503-next-greater-element-ii/#original-solution","title":"Original Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {\n        // Duplicate the input array 'nums' and append it to itself.\n        // This is done to simulate the circular nature of the problem.\n        vector&lt;int&gt; nums1(nums.begin(), nums.end());\n        nums.insert(nums.end(), nums1.begin(), nums1.end());\n\n        // Initialize a result vector 'res' of the same size as the modified 'nums'.\n        // Fill it with -1, which will be the default value if no greater element is found.\n        vector&lt;int&gt; res(nums.size(), -1);\n\n        // Use a stack 'stk' to store indices of elements.\n        // Elements in the stack will be in decreasing order from top to bottom.\n        stack&lt;int&gt; stk;\n\n        // Iterate through the doubled array.\n        for (int i = 0; i &lt; nums.size(); i++) {\n            // If the current element is greater than the element corresponding to the\n            // index at the top of the stack, then we have found the next greater element\n            // for the element at the top of the stack.\n            while (!stk.empty() &amp;&amp; nums[i] &gt; nums[stk.top()]) {\n                int prevIndex = stk.top(); // Get the index of the smaller element.\n                res[prevIndex] = nums[i];  // Assign the next greater element for this index.\n                stk.pop();                 // Remove the index from the stack.\n            }\n\n            // Push the current index onto the stack.\n            stk.push(i);\n        }\n\n        // Since we have iterated through a doubled array, but we only need the results\n        // for the original array, we cut off the extra results.\n        vector&lt;int&gt; cutoffRes(res.begin(), res.begin() + nums1.size());\n\n        return cutoffRes;\n    }\n};\n</code></pre> <p>Explanation of the Algorithm:</p> <ol> <li>Circular Array Simulation: The algorithm first creates a duplicate of the input array and appends it to itself. This effectively simulates the circular nature of the array, allowing the algorithm to find the next greater element for each element in a single pass.</li> <li>Stack for Indices: A stack is used to keep track of indices of elements. The stack maintains elements in decreasing order (from the top of the stack to the bottom). This way, when a greater element is found, it will be greater than all elements currently in the stack.</li> <li>Finding Next Greater Elements: As the algorithm iterates through the doubled array, it uses the stack to track and assign the next greater elements. When a greater element is found, it updates the result array (<code>res</code>) for indices in the stack.</li> <li>Result Adjustment: Because the array was doubled for the algorithm, the final result is adjusted to reflect only the results for the original array length.</li> </ol>"},{"location":"Leetcode/0500-0599/0503-next-greater-element-ii/#optimized-solution","title":"Optimized Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {\n        // Initialize a result vector 'res' of the same size as 'nums'.\n        // Fill it with -1, which will be the default value if no greater element is found.\n        vector&lt;int&gt; res(nums.size(), -1);\n\n        // Use a stack 'stk' to store indices of elements.\n        // Elements in the stack will be in decreasing order from top to bottom.\n        stack&lt;int&gt; stk;\n\n        // Iterate through the array twice to simulate the circular nature.\n        // 'i % nums.size()' is used to loop back to the start of the array.\n        for (int i = 0; i &lt; nums.size() * 2; i++) {\n            // If the current element is greater than the element corresponding to the\n            // index at the top of the stack, then we have found the next greater element\n            // for the element at the top of the stack.\n            while (!stk.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[stk.top()]) {\n                res[stk.top()] = nums[i % nums.size()]; // Assign the next greater element.\n                stk.pop(); // Remove the index from the stack.\n            }\n\n            // Push the current index (mod nums.size()) onto the stack.\n            stk.push(i % nums.size());\n        }\n\n        return res;\n    }\n};\n</code></pre> <p>Explanation of the Algorithm:</p> <ol> <li>Circular Array Simulation: Instead of duplicating the array, this solution cleverly simulates the circular nature by iterating through the array twice (<code>nums.size() * 2</code>) and using modulo operator (<code>i % nums.size()</code>) to loop back to the start of the array.</li> <li>Stack for Indices: Similar to the previous solution, a stack is used to keep track of indices, and the next greater element is found in a similar manner.</li> <li>Efficiency: Since the array is not duplicated, this approach saves on the space complexity. However, the time complexity remains the same.</li> </ol> <p>Time and Space Complexity:</p> <ul> <li>Time Complexity: Both versions of the solution have a time complexity of \\(O(n)\\), where \\(n\\) is the number of elements in the input array. Each element is pushed and popped from the stack at most once.</li> <li>Space Complexity:<ul> <li>The original solution has a space complexity of \\(O(2n) = O(n)\\) because it duplicates the array and creates a stack of size \\(n\\).</li> <li>The optimized solution improves on space complexity as it does not duplicate the array, resulting in a space complexity of \\(O(n)\\) only for the stack.</li> </ul> </li> </ul>"},{"location":"Leetcode/0500-0599/0509-fibonacci-number/","title":"Fibonacci Number","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0509-fibonacci-number/#description","title":"Description","text":"<p>The Fibonacci numbers, commonly denoted <code>F(n)</code> form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p> <ul> <li><code>F(0) = 0, F(1) = 1</code></li> <li><code>F(n) = F(n - 1) + F(n - 2)</code>, for <code>n &gt; 1</code>.</li> </ul> <p>Given n, calculate F(n).</p> <p>Example 1:</p> <ul> <li>Input: <code>n = 2</code></li> <li>Output: <code>1</code></li> <li>Explanation: <code>F(2) = F(1) + F(0) = 1 + 0 = 1</code>.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>n = 3</code></li> <li>Output: <code>2</code></li> <li>Explanation: <code>F(3) = F(2) + F(1) = 1 + 1 = 2</code>.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>n = 4</code></li> <li>Output: <code>3</code></li> <li>Explanation: <code>F(4) = F(3) + F(2) = 2 + 1 = 3</code>.</li> </ul> <p>Constraints:</p> <ul> <li><code>0 &lt;= n &lt;= 30</code></li> </ul>"},{"location":"Leetcode/0500-0599/0509-fibonacci-number/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0509-fibonacci-number/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int fib(int n) {\n        if (n &lt;= 1) return n;\n        vector&lt;int&gt; dp(n + 1);\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++)\n            dp[i] = dp[i - 1] + dp[i - 2];\n        return dp[n];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0500-0599/0509-fibonacci-number/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int fib(int n) {\n        if (n &lt;= 1) return n;\n        int dp[2];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            int sum = dp[0] + dp[1];\n            dp[0] = dp[1];\n            dp[1] = sum;\n        }\n        return dp[1];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0500-0599/0513-find-bottom-left-tree-value/","title":"Find Bottom Left Tree Value","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0513-find-bottom-left-tree-value/#description","title":"Description","text":"<p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [2,1,3]</code></li> <li>Output: <code>1</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [1,2,3,4,null,5,6,null,null,7]</code></li> <li>Output: <code>7</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 10^4]</code>.</li> <li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li> </ul>"},{"location":"Leetcode/0500-0599/0513-find-bottom-left-tree-value/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0513-find-bottom-left-tree-value/#recursive-solution","title":"Recursive Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int res = 0;\n    int maxDepth = 0;\n    void traversal(TreeNode* root, int depth) {\n        if (!root) return;\n        if (depth &gt; maxDepth) {\n            maxDepth = depth;\n            res = root-&gt;val;\n        }\n        traversal(root-&gt;left, depth + 1);\n        traversal(root-&gt;right, depth + 1);\n    }\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        traversal(root, 1);\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0513-find-bottom-left-tree-value/#iterative-solution-level-order","title":"Iterative Solution (Level-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int res;\n        queue&lt;TreeNode*&gt; q;\n        if (root) q.push(root);\n\n        while (!q.empty()) {\n            int len = q.size();\n            for (int i = 0; i &lt; len; i++) {\n                auto t = q.front();\n                q.pop();\n                if (i == 0) res = t-&gt;val;\n                if (t-&gt;left) q.push(t-&gt;left);\n                if (t-&gt;right) q.push(t-&gt;right);\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0518-coin-change-ii/","title":"Coin Change II","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0518-coin-change-ii/#description","title":"Description","text":"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p> <p>Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p> <p>You may assume that you have an infinite number of each kind of coin.</p> <p>The answer is guaranteed to fit into a signed 32-bit integer.</p> <p>Example 1:</p> <ul> <li>Input: <code>amount = 5, coins = [1,2,5]</code></li> <li>Output: <code>4</code></li> <li>Explanation: there are four ways to make up the amount:</li> </ul> <pre><code>5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>amount = 3, coins = [2]</code></li> <li>Output: <code>0</code></li> <li>Explanation: the amount of 3 cannot be made up just with coins of 2.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>amount = 10, coins = [10]</code></li> <li>Output: <code>1</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= coins.length &lt;= 300</code></li> <li><code>1 &lt;= coins[i] &lt;= 5000</code></li> <li>All the values of <code>coins</code> are unique.</li> <li><code>0 &lt;= amount &lt;= 5000</code></li> </ul>"},{"location":"Leetcode/0500-0599/0518-coin-change-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0518-coin-change-ii/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) {\n        int n = coins.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amount + 1, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 0; j &lt;= amount; j++) {\n                if (j &lt; coins[i - 1]) dp[i][j] = dp[i - 1][j];\n                else dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];\n            }\n        }\n        return dp[n][amount];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0518-coin-change-ii/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) {\n        int n = coins.size();\n        vector&lt;int&gt; dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = coins[i - 1]; j &lt;= amount; j++) {\n                dp[j] = dp[j] + dp[j - coins[i - 1]];\n            }\n        }\n        return dp[amount];\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0541-reverse-string-ii/","title":"Reverse String II","text":"<p>Link</p>"},{"location":"Leetcode/0500-0599/0541-reverse-string-ii/#description","title":"Description","text":"<p>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p> <p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code> characters and leave the other as original.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"abcdefg\", k = 2</code></li> <li>Output: <code>\"bacdfeg\"</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"abcd\", k = 2</code></li> <li>Output: <code>\"bacd\"</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^4</code></li> <li><code>s</code> consists of only lowercase English letters.</li> <li><code>1 &lt;= k &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0500-0599/0541-reverse-string-ii/#solution","title":"Solution","text":""},{"location":"Leetcode/0500-0599/0541-reverse-string-ii/#original-solution","title":"Original Solution","text":"<pre><code>class Solution {\npublic:\n    string reverse(string s) {\n        for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; i++, j--) {\n            swap(s[i], s[j]);\n        }\n        return s;\n    }\n    string reverseStr(string s, int k) {\n        for (int i = 0; ; ) {\n            int t = i + 2 * k;\n            if (t &lt; s.size()) {\n                s.replace(i, k, reverse(s.substr(i, k)));\n                i += 2 * k;\n            } else if (i + k &gt;= s.size()) {\n                s.replace(i, s.size() - i, reverse(s.substr(i, s.size() - i)));\n                break;\n            } else {\n                s.replace(i, k, reverse(s.substr(i, k)));\n                break;\n            }\n        }\n        return s;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0500-0599/0541-reverse-string-ii/#optimized-solution","title":"Optimized Solution","text":"<pre><code>class Solution {\npublic:\n    string reverseStr(string s, int k) {\n        for (int i = 0; i &lt; s.size(); i += 2 * k) {\n            // 1. the first k characters of every 2k characters are reversed\n            // 2. if the remaining characters are less than 2k \n            // but greater than or equal to k, invert the first k characters\n            if (i + k &lt;= s.size()) {\n                reverse(s.begin() + i, s.begin() + i + k);\n            } else {\n                // 3. If there are less than k characters left,\n                // then reverse all remaining characters\n                reverse(s.begin() + i, s.end());\n            }\n        }\n        return s;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    // Left-closed right-closed interval\n    void myReverse(string &amp;s, int start, int end) {\n        for (int i = start, j = end; i &lt; j; i++, j--) {\n            swap(s[i], s[j]);\n        }\n    }\n\n    string reverseStr(string s, int k) {\n        for (int i = 0; i &lt; s.size(); i += 2 * k) {\n            if (i + k &lt;= s.size()) {\n                myReverse(s, i, i + k - 1);\n            } else {\n                myReverse(s, i, s.size() - 1);\n            }\n        }\n        return s;\n    }\n};\n</code></pre> <p>Easiest way of writing:</p> <pre><code>class Solution {\npublic:\n    string reverseStr(string s, int k) {\n        for (int i = 0; i &lt; s.size(); i += 2 * k) {\n            int l = i, r = min(i + k, (int)s.size());\n            reverse(s.begin() + l, s.begin() + r);\n        }\n        return s;\n    }\n};\n</code></pre> <p>Note: <code>s.size()</code> returns an unsigned number, which needs to be converted to a signed number when <code>min()</code> is called to make the comparison.</p>"},{"location":"Leetcode/0600-0699/0617-merge-two-binary-trees/","title":"Merge Two Binary Trees","text":"<p>Link</p>"},{"location":"Leetcode/0600-0699/0617-merge-two-binary-trees/#description","title":"Description","text":"<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p> <p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p> <p>Return the merged tree.</p> <p>Note: The merging process must start from the root nodes of both trees.</p> <p>Example 1:</p> <ul> <li>Input: <code>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</code></li> <li>Output: <code>[3,4,5,5,4,null,7]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root1 = [1], root2 = [1,2]</code></li> <li>Output: <code>[2,2]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li> <li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li> </ul>"},{"location":"Leetcode/0600-0699/0617-merge-two-binary-trees/#solution","title":"Solution","text":""},{"location":"Leetcode/0600-0699/0617-merge-two-binary-trees/#recursive-solution-pre-order","title":"Recursive Solution (Pre-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1) return root2;\n        if (!root2) return root1;\n        root1-&gt;val += root2-&gt;val;\n        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);\n        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);\n        return root1;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N)\\);</li> <li>Space complexity: \\(O(h)\\), where \\(h\\) is the height of the tree.</li> </ul> <p>Another way of writing (without modifying the original tree's structure):</p> <pre><code>class Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1) return root2;\n        if (!root2) return root1;\n        TreeNode* node = new TreeNode(0);\n        node-&gt;val = root1-&gt;val + root2-&gt;val;\n        node-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);\n        node-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);\n        return node;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0600-0699/0617-merge-two-binary-trees/#iterative-solution-level-order","title":"Iterative Solution (Level-order)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1) return root2;\n        if (!root2) return root1;\n\n        queue&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; q;\n        q.push({root1, root2});\n\n        while (!q.empty()) {\n            auto t = q.front(); q.pop();\n            t.first-&gt;val += t.second-&gt;val;\n\n            if (t.first-&gt;left &amp;&amp; t.second-&gt;left) \n                q.push({t.first-&gt;left, t.second-&gt;left});\n            if (t.first-&gt;right &amp;&amp; t.second-&gt;right) \n                q.push({t.first-&gt;right, t.second-&gt;right});\n\n            if (!t.first-&gt;left &amp;&amp; t.second-&gt;left) \n                t.first-&gt;left = t.second-&gt;left;\n            if (!t.first-&gt;right &amp;&amp; t.second-&gt;right) \n                t.first-&gt;right = t.second-&gt;right;\n        }\n        return root1;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0600-0699/0654-maximum-binary-tree/","title":"Maximum Binary Tree","text":"<p>Link</p>"},{"location":"Leetcode/0600-0699/0654-maximum-binary-tree/#description","title":"Description","text":"<p>You are given an integer array <code>nums</code> with no duplicates. A maximum binary tree can be built recursively from <code>nums</code> using the following algorithm:</p> <p>Create a root node whose value is the maximum value in <code>nums</code>.</p> <ul> <li>Recursively build the left subtree on the subarray prefix to the left of the maximum value.</li> <li>Recursively build the right subtree on the subarray suffix to the right of the maximum value.</li> </ul> <p>Return the maximum binary tree built from <code>nums</code>.</p> <p>Example 1:</p> <p></p> <ul> <li>Input: <code>nums = [3,2,1,6,0,5]</code></li> <li>Output: <code>[6,3,5,null,2,0,null,null,1]</code></li> <li>Explanation: The recursive calls are as follow:</li> </ul> <pre><code>- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>nums = [3,2,1]</code></li> <li>Output: <code>[3,null,2,null,1]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 1000</code></li> <li><code>0 &lt;= nums[i] &lt;= 1000</code></li> <li>All integers in nums are unique.</li> </ul>"},{"location":"Leetcode/0600-0699/0654-maximum-binary-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0600-0699/0654-maximum-binary-tree/#recursive-solution","title":"Recursive Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* traversal(vector&lt;int&gt; &amp;nums, int left, int right) {\n        if (left &gt;= right) return nullptr;\n\n        // int maxIndex = left;\n        // for (int i = left + 1; i &lt; right; i++) {\n        //     if (nums[i] &gt; nums[maxIndex]) maxIndex = i;\n        // }\n        int maxIndex = distance(nums.begin(), max_element(nums.begin() + left, nums.begin() + right));\n\n        TreeNode *root = new TreeNode(nums[maxIndex]);\n\n        root-&gt;left = traversal(nums, left, maxIndex);\n        root-&gt;right = traversal(nums, maxIndex + 1, right);\n\n        return root;\n    }\npublic:\n    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {\n        return traversal(nums, 0, nums.size());\n    }\n};\n</code></pre> <p>Time Complexity Analysis:</p> <ol> <li>Finding the Maximum Element: The use of <code>max_element</code> in each recursive call requires iterating over each element of the subarray. This operation has a linear time complexity relative to the size of the subarray.</li> <li>Recursive Tree Construction: The function <code>traversal</code> is called recursively for different parts of the array. However, each element of the array is part of exactly one subarray for which the maximum is found. Therefore, each element contributes to \\(O(N)\\) operations overall.</li> <li>Overall Complexity: Considering the recursive nature of the algorithm and the way each element is visited, the overall time complexity is \\(O(N^2)\\), where \\(N\\) is the number of elements in the array. This quadratic complexity arises because for each element (in the worst case), we might have to scan all the remaining elements to find the maximum.</li> </ol> <p>Space Complexity Analysis:</p> <ol> <li>Recursive Call Stack: The depth of the recursive call stack will be \\(O(N)\\) in the worst case (e.g., when the array is sorted in ascending or descending order). This is because the tree becomes a skewed tree (like a linked list), and the height of the tree, which determines the depth of the recursive stack, is equal to \\(N\\).</li> <li>TreeNode Allocation: For every element in the array, a new TreeNode is created. Thus, the space used for TreeNode allocation is \\(O(N)\\).</li> <li>Overall Complexity: Considering the recursive stack and the tree node allocation, the overall space complexity is \\(O(N)\\).</li> </ol>"},{"location":"Leetcode/0600-0699/0654-maximum-binary-tree/#optimized-solution","title":"Optimized Solution","text":"<p>This is a Cartesian tree problem, and we can use monolithic stack to optimize the time complexity. See reference 1 (in Chinese) and reference 2.</p> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {\n        stack&lt;TreeNode*&gt; stk;\n        for (int x : nums) {\n            auto node = new TreeNode(x);\n            while (!stk.empty() &amp;&amp; stk.top()-&gt;val &lt; x) {\n                node-&gt;left = stk.top();\n                stk.pop();\n            }\n            if (!stk.empty()) stk.top()-&gt;right = node;\n            stk.push(node);\n        }\n        while (stk.size() &gt; 1) stk.pop();\n        return stk.top();\n    }\n};\n</code></pre> <p>Analysis:</p> <ol> <li>Stack Initialization: A stack of <code>TreeNode*</code> is created. This stack will be used to maintain a monotonically decreasing sequence of nodes.</li> <li>Iterating Over <code>nums</code>: The function iterates over each element <code>x</code> in the input vector <code>nums</code>.</li> <li>Creating a New Node: For each element <code>x</code>, a new tree node is created.</li> <li>Updating the Stack and Constructing the Tree:</li> <li>As long as the stack is not empty and the value of the top node in the stack is less than <code>x</code>, the following steps are repeated:<ul> <li>The current top of the stack is set as the left child of the new node. This is based on the property of the maximum binary tree, where the nodes in the left subtree are less than the root.</li> <li>The top node is then popped from the stack.</li> </ul> </li> <li>If the stack is not empty after this process, the new node is set as the right child of the current top of the stack. This is because in the monotonically decreasing stack, the top element will be the first element that is greater than <code>x</code> on its right.</li> <li>Pushing the New Node to the Stack: The new node is pushed onto the stack. This ensures that the stack maintains its monotonically decreasing property.</li> <li>Finalizing the Root of the Tree:</li> <li>After processing all elements in <code>nums</code>, the stack may contain more than one node. The nodes in the stack are in decreasing order, and each node is the root of a subtree where all elements to its right (in the original array) are smaller.</li> <li>The loop <code>while (stk.size() &gt; 1) stk.pop();</code> pops all nodes except the one at the bottom of the stack, which is the root of the maximum binary tree.</li> <li>Returning the Root: The function returns the remaining node on the stack, which is the root of the constructed maximum binary tree.</li> </ol> <p>Complexity Analysis:</p> <ul> <li>Time Complexity: \\(O(N)\\). Each element in <code>nums</code> is processed exactly once. The while loop inside the for loop might seem like it could lead to a higher time complexity, but each node is added to and removed from the stack exactly once. Therefore, the total number of operations is proportional to the number of elements in <code>nums</code>.</li> <li>Space Complexity: \\(O(N)\\). The space complexity is primarily due to the storage of the nodes in the stack and the tree itself. In the worst case (when the array is sorted in ascending order), all elements will be in the stack before they start getting popped, which would require O(N) space.</li> </ul>"},{"location":"Leetcode/0700-0799/0700-search-in-a-binary-search-tree/","title":"Search in a Binary Search Tree","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#description","title":"Description","text":"<p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p> <p>Find the node in the BST that the node's value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>root = [4,2,7,1,3], val = 2</code></li> <li>Output: <code>[2,1,3]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>root = [4,2,7,1,3], val = 5</code></li> <li>Output: <code>[]</code></li> </ul> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li> <li><code>1 &lt;= Node.val &lt;= 10^7</code></li> <li><code>root</code> is a binary search tree.</li> <li><code>1 &lt;= val &lt;= 10^7</code></li> </ul>"},{"location":"Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#recursive-solution","title":"Recursive Solution","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root || root-&gt;val == val) return root;\n        if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);\n        if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val);\n        return nullptr;\n    }\n};\n</code></pre> <p>Another way of writing:</p> <pre><code>class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root || root-&gt;val == val) return root;\n        TreeNode *res = nullptr;\n        if (root-&gt;val &gt; val) res = searchBST(root-&gt;left, val);\n        if (root-&gt;val &lt; val) res = searchBST(root-&gt;right, val);\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity (worst): \\(O(n)\\);</li> <li>Space complexity (worst): \\(O(n)\\) for recursion stack.</li> </ul>"},{"location":"Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#iterative-solution","title":"Iterative Solution","text":"<pre><code>class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        TreeNode* curr = root;\n        while (curr &amp;&amp; curr-&gt;val != val) {\n            if (curr-&gt;val &gt; val) curr = curr-&gt;left;\n            else curr = curr-&gt;right;\n        }\n        return curr;\n    }\n};\n</code></pre> <ul> <li>Time complexity (worst): \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/","title":"Kth Largest Element in a Stream","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#description","title":"Description","text":"<p>Design a class to find the <code>k</code>-th largest element in a stream. Note that it is the <code>k</code>-th largest element in the sorted order, not the <code>k</code>-th distinct element.</p> <p>Implement <code>KthLargest</code> class:</p> <ul> <li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li> <li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k</code>-th largest element in the stream.</li> </ul> <p>Example 1:</p> <ul> <li>Input:</li> </ul> <pre><code>[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n</code></pre> <ul> <li>Output:</li> </ul> <pre><code>[null, 4, 5, 5, 8, 8]\n</code></pre> <ul> <li>Explanation:</li> </ul> <pre><code>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= k &lt;= 10^4</code></li> <li><code>0 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> <li><code>-10^4 &lt;= val &lt;= 10^4</code></li> <li>At most <code>10^4</code> calls will be made to add.</li> <li>It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k</code>-th element.</li> </ul>"},{"location":"Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#using-set","title":"Using Set","text":"<pre><code>class KthLargest {\nprivate:\n    int _k;\n    multiset&lt;int&gt; s;\npublic:\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) {\n        for (int num : nums) {\n            s.insert(num);\n            if (s.size() &gt; k) s.erase(s.begin());\n        }\n        _k = k;\n    }\n\n    int add(int val) {\n        s.insert(val);\n        if (s.size() &gt; _k) s.erase(s.begin());\n        return *s.begin();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-&gt;add(val);\n */\n</code></pre>"},{"location":"Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#using-heap","title":"Using Heap","text":"<pre><code>class KthLargest {\nprivate:\n    int _k;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\npublic:\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) {\n        for (int num : nums) {\n            q.push(num);\n            if (q.size() &gt; k) q.pop();\n        }\n        this-&gt;_k = k;\n    }\n\n    int add(int val) {\n       q.push(val);\n       if (q.size() &gt; _k) q.pop();\n       return q.top(); \n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-&gt;add(val);\n */\n</code></pre> <ul> <li>Time complexity: \\(O(n\\log k)\\) for initializing elements in the heap, and \\(O(\\log k)\\) for each insertion operation;</li> <li>Space complexity: \\(O(k)\\).</li> </ul>"},{"location":"Leetcode/0700-0799/0704-binary-search/","title":"Binary Search","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0704-binary-search/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search target in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return -1.</p> <p>You must write an algorithm with \\(O(\\log n)\\) runtime complexity.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [-1,0,3,5,9,12], target = 9</code></li> <li>Output: 4</li> </ul> <p>Explanation: 9 exists in <code>nums</code> and its index is 4</p> <p>Example 2:</p> <ul> <li>Input: <code>nums = [-1,0,3,5,9,12], target = 2</code></li> <li>Output: -1</li> </ul> <p>Explanation: 2 does not exist in <code>nums</code> so return -1</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^4 &lt; nums[i], target &lt; 10^4</code></li> <li>All the integers in <code>nums</code> are unique.</li> <li><code>nums</code> is sorted in ascending order.</li> </ul>"},{"location":"Leetcode/0700-0799/0704-binary-search/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0704-binary-search/#binary-search-solution","title":"Binary Search Solution","text":"<pre><code>class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l &lt; r) {\n            int mid = l + r &gt;&gt; 1;\n            if (nums[mid] &gt;= target) r = mid;\n            else l = mid + 1;\n        }\n        return nums[l] == target ? l : -1;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0700-0799/0707-design-linked-list/","title":"Design Linked list","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0707-design-linked-list/#description","title":"Description","text":"<p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p> <p>A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p> <p>Implement the <code>MyLinkedList</code> class:</p> <ul> <li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li> <li><code>int get(int index)</code> Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return -1.</li> <li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li> <li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li> <li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node will not be inserted.</li> <li><code>void deleteAtIndex(int index)</code> Delete the <code>index</code>-th node in the linked list, if the index is valid.</li> </ul> <p>Example 1:</p> <ul> <li>Input:</li> <li><code>[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]</code></li> <li><code>[[], [1], [3], [1, 2], [1], [1], [1]]</code></li> <li>Output:</li> <li><code>[null, null, null, null, 2, null, 3]</code></li> </ul> <p>Explanation:</p> <pre><code>MyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\nmyLinkedList.get(1);              // return 3\n</code></pre> <p>Constraints:</p> <ul> <li><code>0 &lt;= index, val &lt;= 1000</code></li> <li>Please do not use the built-in LinkedList library.</li> <li>At most 2000 calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li> </ul>"},{"location":"Leetcode/0700-0799/0707-design-linked-list/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0707-design-linked-list/#with-dummy-head","title":"With Dummy Head","text":"<pre><code>class MyLinkedList {\npublic:\n    struct LinkedNode {\n        int val;\n        LinkedNode *next;\n        LinkedNode(int val) : val(val), next(nullptr) {}\n    };\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);\n        _size = 0;\n    }\n\n    int get(int index) {\n        if (index &gt;= _size || index &lt; 0) return -1;\n        LinkedNode *curr = _dummyHead-&gt;next;\n        while (index-- &amp;&amp; curr) curr = curr-&gt;next;\n        if (curr) return curr-&gt;val;\n        return -1;\n    }\n\n    void addAtHead(int val) {\n        LinkedNode *newNode = new LinkedNode(val);\n        newNode-&gt;next = _dummyHead-&gt;next;\n        _dummyHead-&gt;next = newNode;\n        _size++;\n    }\n\n    void addAtTail(int val) {\n        LinkedNode *newNode = new LinkedNode(val);\n        LinkedNode *curr = _dummyHead;\n        while (curr-&gt;next != nullptr) curr = curr-&gt;next;\n        curr-&gt;next = newNode;\n        _size++;\n    }\n\n    void addAtIndex(int index, int val) {\n        if (index &gt; _size) return;\n        if (index &lt; 0) index = 0;\n        LinkedNode *newNode = new LinkedNode(val);\n        LinkedNode *curr = _dummyHead;\n        while (index-- &amp;&amp; curr-&gt;next) curr = curr-&gt;next;\n        newNode-&gt;next = curr-&gt;next;\n        curr-&gt;next = newNode;\n        _size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index &gt;= _size || index &lt; 0) return;\n        LinkedNode *curr = _dummyHead;\n        while (index-- &amp;&amp; curr-&gt;next) curr = curr-&gt;next;\n        LinkedNode *temp = curr-&gt;next;\n        curr-&gt;next = curr-&gt;next-&gt;next;\n        delete temp;\n        temp = nullptr;\n        _size--;\n    }\nprivate:\n    int _size;\n    LinkedNode *_dummyHead;\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj-&gt;get(index);\n * obj-&gt;addAtHead(val);\n * obj-&gt;addAtTail(val);\n * obj-&gt;addAtIndex(index,val);\n * obj-&gt;deleteAtIndex(index);\n */\n</code></pre> <ul> <li>Time complexity: \\(O(index)\\) for operations involving <code>index</code>, \\(O(1)\\) for the rest;</li> <li>Space complexity: \\(O(n)\\).</li> </ul> <p>Note: When we insert with <code>index &lt; 0</code>, test case will just treat as insert at <code>index = 0</code>.</p> <p>Code with comments:</p> <pre><code>class MyLinkedList {\npublic:\n    // Node structure representing each element in the list\n    struct LinkedNode {\n        int val;           // Value of the node\n        LinkedNode *next;  // Pointer to the next node in the list\n        LinkedNode(int val) : val(val), next(nullptr) {}\n    };\n\n    // Constructor\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);  // Create a dummy head to simplify operations\n        _size = 0;                       // Initialize the size of the list as 0\n    }\n\n    // Get the value of the index-th node in the linked list\n    int get(int index) {\n        if (index &gt;= _size || index &lt; 0) return -1; // Return -1 for invalid index\n        LinkedNode *curr = _dummyHead-&gt;next;        // Start from the first real node\n        while (index--) curr = curr-&gt;next;          // Move to the correct node\n        return curr-&gt;val;                           // Return the value of the node\n    }\n\n    // Add a node of value val before the first element of the linked list\n    void addAtHead(int val) {\n        LinkedNode *newNode = new LinkedNode(val);  // Create a new node\n        newNode-&gt;next = _dummyHead-&gt;next;           // Point the new node to the first real node\n        _dummyHead-&gt;next = newNode;                 // Insert the new node after dummy head\n        _size++;                                    // Increase the size of the list\n    }\n\n    // Append a node of value val to the last element of the linked list\n    void addAtTail(int val) {\n        LinkedNode *newNode = new LinkedNode(val);  // Create a new node\n        LinkedNode *curr = _dummyHead;              // Start from the dummy head\n        while (curr-&gt;next != nullptr)               // Traverse to the end of the list\n            curr = curr-&gt;next;\n        curr-&gt;next = newNode;                       // Append the new node\n        _size++;                                    // Increase the size of the list\n    }\n\n    // Add a node of value val before the index-th node in the linked list\n    void addAtIndex(int index, int val) {\n        if (index &gt; _size) return;                  // Do nothing if index is greater than the size\n        if (index &lt; 0) index = 0;                   // Treat negative index as 0\n        LinkedNode *newNode = new LinkedNode(val);  // Create a new node\n        LinkedNode *curr = _dummyHead;              // Start from the dummy head\n        while (index--) curr = curr-&gt;next;          // Move to the correct position\n        newNode-&gt;next = curr-&gt;next;                 // Insert the new node\n        curr-&gt;next = newNode;\n        _size++;                                    // Increase the size of the list\n    }\n\n    // Delete the index-th node in the linked list, if the index is valid\n    void deleteAtIndex(int index) {\n        if (index &gt;= _size || index &lt; 0) return;    // Do nothing if the index is invalid\n        LinkedNode *curr = _dummyHead;              // Start from the dummy head\n        while (index--) curr = curr-&gt;next;          // Move to the node before the one to be deleted\n        LinkedNode *temp = curr-&gt;next;              // Temporarily store the node to be deleted\n        curr-&gt;next = curr-&gt;next-&gt;next;              // Remove the node from the list\n        delete temp;                                // Delete the node\n        temp = nullptr;\n        _size--;                                    // Decrease the size of the list\n    }\n\nprivate:\n    int _size;                  // Size of the linked list\n    LinkedNode *_dummyHead;     // Dummy head node to simplify operations\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj-&gt;get(index);\n * obj-&gt;addAtHead(val);\n * obj-&gt;addAtTail(val);\n * obj-&gt;addAtIndex(index,val);\n * obj-&gt;deleteAtIndex(index);\n */\n</code></pre>"},{"location":"Leetcode/0700-0799/0707-design-linked-list/#without-dummy-head","title":"Without Dummy Head","text":"<pre><code>class MyLinkedList {\npublic:\n    // Node structure for the linked list\n    struct Node {\n        int val;   // Value of the node\n        Node *next; // Pointer to the next node\n        Node(int _val) : val(_val), next(nullptr) {} // Constructor to initialize node\n    } *head; // Head pointer of the list\n\n    // Constructor initializes the linked list\n    MyLinkedList() {\n        head = nullptr; // Initially, the list is empty, so head is null\n    }\n\n    // Function to get the value of the node at a given index\n    int get(int index) {\n        if (index &lt; 0) return -1; // Return -1 for invalid index\n        auto p = head; // Start from the head of the list\n        for (int i = 0; i &lt; index &amp;&amp; p; i++) p = p-&gt;next; // Traverse the list to reach the desired index\n        if (!p) return -1; // If p is null, index is out of bounds\n        return p-&gt;val; // Return the value of the node at the index\n    }\n\n    // Function to add a node at the beginning of the list\n    void addAtHead(int val) {\n        auto curr = new Node(val); // Create a new node\n        curr-&gt;next = head; // Link new node to the current head\n        head = curr; // Update head to the new node\n    }\n\n    // Function to add a node at the end of the list\n    void addAtTail(int val) {\n        if (!head) { // If the list is empty\n            head = new Node(val); // Create a new node and set it as head\n        }\n        else {\n            auto p = head; // Start from the head\n            while (p-&gt;next) p = p-&gt;next; // Traverse to the last node\n            p-&gt;next = new Node(val); // Add new node at the end\n        }\n    }\n\n    // Function to add a node at a specific index\n    void addAtIndex(int index, int val) {\n        if (index &lt;= 0) { // If index is 0 or negative, add at head\n            addAtHead(val);\n        }\n        else {\n            int len = 0;\n            for (auto p = head; p; p = p-&gt;next) len++; // Calculate the length of the list\n            if (index == len) { // If index equals the length of the list, add at tail\n                addAtTail(val);\n            }\n            else if (index &lt; len) { // If index is within bounds\n                auto p = head;\n                for (int i = 0; i &lt; index - 1; i++) p = p-&gt;next; // Find the node before the desired index\n                auto curr = new Node(val); // Create a new node\n                curr-&gt;next = p-&gt;next; // Insert the new node after p\n                p-&gt;next = curr;\n            }\n        }\n    }\n\n    // Function to delete a node at a specific index\n    void deleteAtIndex(int index) {\n        int len = 0;\n        for (auto p = head; p; p = p-&gt;next) len++; // Calculate the length of the list\n        if (index &gt;= 0 &amp;&amp; index &lt; len) { // If index is within bounds\n            if (!index) { // If index is 0, delete the head\n                head = head-&gt;next;\n            }\n            else {\n                auto p = head;\n                for (int i = 0; i &lt; index - 1; i++) p = p-&gt;next; // Find the node before the one to delete\n                p-&gt;next = p-&gt;next-&gt;next; // Delete the node at the index\n            }\n        }\n    }\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj-&gt;get(index);\n * obj-&gt;addAtHead(val);\n * obj-&gt;addAtTail(val);\n * obj-&gt;addAtIndex(index,val);\n * obj-&gt;deleteAtIndex(index);\n */\n</code></pre>"},{"location":"Leetcode/0700-0799/0720-longest-word-in-dictionary/","title":"Longest Word in Dictionary","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0720-longest-word-in-dictionary/#description","title":"Description","text":"<p>Given an array of strings <code>words</code> representing an English Dictionary, return the longest word in <code>words</code> that can be built one character at a time by other words in <code>words</code>.</p> <p>If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.</p> <p>Note that the word should be built from left to right with each additional character being added to the end of a previous word.</p> <p>Example 1:</p> <ul> <li>Input: <code>words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]</code></li> <li>Output: <code>\"world\"</code></li> <li>Explanation: <code>The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]</code></li> <li>Output: <code>\"apple\"</code></li> <li>Explanation: <code>Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= words.length &lt;= 1000</code></li> <li><code>1 &lt;= words[i].length &lt;= 30</code></li> <li><code>words[i]</code> consists of lowercase English letters.</li> </ul>"},{"location":"Leetcode/0700-0799/0720-longest-word-in-dictionary/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0720-longest-word-in-dictionary/#way-1","title":"Way 1","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; son;\n    vector&lt;int&gt; cnt;\n    int idx;\n    void insert(string&amp; word) {\n        int p = 0;\n        for (char s : word) {\n            int u = s - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n        }\n        cnt[p]++;\n    }\n    int query(string&amp; word) {\n        int p = 0;\n        for (char s : word) {\n            int u = s - 'a';\n            p = son[p][u];\n            if (!p || cnt[p] == 0) return 0;\n        }\n        return cnt[p];\n    }\npublic:\n    string longestWord(vector&lt;string&gt;&amp; words) {\n        son = vector&lt;vector&lt;int&gt;&gt;(30010, vector&lt;int&gt;(26, 0));\n        cnt = vector&lt;int&gt;(30010, 0);\n        idx = 0;\n        set&lt;string&gt; ans;\n        for (string word : words) insert(word);\n        for (string word : words) {\n            if (query(word) &gt; 0) ans.insert(word);\n        }\n\n        string longest = \"\";\n        for (string word : ans) {\n            if (word.length() &gt; longest.length() || ((word.length() == longest.length() &amp;&amp; word &lt; longest)))\n            longest = word;\n        }\n\n        return longest;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0700-0799/0720-longest-word-in-dictionary/#way-2","title":"Way 2","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; son;\n    vector&lt;int&gt; cnt;\n    string res = \"\";\n    int idx = 0;\n    int m = 0;\n\n    void insert(const string&amp; word) {\n        int p = 0;\n        for (auto ch : word) {\n            int u = ch - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n        }\n        cnt[p]++;\n    }\n\n    void search(int u, int l, string&amp; curr) {\n        if (l &gt; m) {\n            res = curr;\n            m = l;\n        }\n\n        for (int i = 0; i &lt; 26; i++) {\n            int sub = son[u][i];\n            if (sub &amp;&amp; cnt[sub] &gt; 0) {\n                curr += ('a' + i);\n                search(sub, l + 1, curr);\n                curr.pop_back();\n            }\n        }\n    }\n\npublic:\n    string longestWord(vector&lt;string&gt;&amp; words) {\n        son = vector&lt;vector&lt;int&gt;&gt;(30010, vector&lt;int&gt;(26, 0));\n        cnt = vector&lt;int&gt;(30010, 0);\n\n        for (auto word : words) insert(word);\n\n        string curr = \"\";\n        search(0, 0, curr);\n\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0700-0799/0739-daily-temperatures/","title":"Daily Temperatures","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0739-daily-temperatures/#description","title":"Description","text":"<p>Given an array of integers <code>temperatures</code> represents the daily temperatures, return an array <code>answer</code> such that <code>answer[i]</code> is the number of days you have to wait after the <code>i-th</code> day to get a warmer temperature. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p> <p>Example 1:</p> <ul> <li>Input: <code>temperatures = [73,74,75,71,69,72,76,73]</code></li> <li>Output: <code>[1,1,4,2,1,1,0,0]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>temperatures = [30,40,50,60]</code></li> <li>Output: <code>[1,1,1,0]</code></li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>temperatures = [30,60,90]</code></li> <li>Output: <code>[1,1,0]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= temperatures.length &lt;= 10^5</code></li> <li><code>30 &lt;= temperatures[i] &lt;= 100</code></li> </ul>"},{"location":"Leetcode/0700-0799/0739-daily-temperatures/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; res(temperatures.size(), 0);\n\n        for (int i = 0; i &lt; temperatures.size(); i++) {\n            while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()]) {\n                res[stk.top()] = i - stk.top();\n                stk.pop();\n            }\n            stk.push(i);\n        }\n\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(N)\\);</li> <li>Space complexity: \\(O(N)\\).</li> </ul> <p>Solution using array representing stack:</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {\n        int stk[100010], tt = 0;\n        vector&lt;int&gt; res(temperatures.size(), 0);\n        for (int i = 0; i &lt; temperatures.size(); i++) {\n            while (tt &gt; 0 &amp;&amp; temperatures[i] &gt; temperatures[stk[tt]]) {\n                res[stk[tt]] = i - stk[tt];\n                tt--;\n            }\n            stk[++tt] = i;\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0700-0799/0739-daily-temperatures/#analysis-of-solution","title":"Analysis of Solution","text":"<p>Understanding Monotonic Stack: A monotonic stack is a stack where the elements are always in sorted order. In this problem, we'll use a decreasing monotonic stack. The stack will store the indices of the <code>temperatures</code> array, and at each step, we'll use it to find the next warmer temperature.</p> <p>Algorithm:</p> <ul> <li>Initialize an empty stack and a result vector of the same size as <code>temperatures</code>, with all values set to 0.</li> <li>Iterate over the <code>temperatures</code> array.</li> <li>For each temperature, while the stack is not empty and the current temperature is greater than the temperature at the index on the top of the stack:<ul> <li>Pop the index from the stack.</li> <li>Calculate the number of days between the current day and the popped day, and update the corresponding position in the result vector.</li> </ul> </li> <li>Push the current index onto the stack.</li> </ul> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {\n        int n = temperatures.size();\n        vector&lt;int&gt; answer(n, 0);\n        stack&lt;int&gt; indices;\n\n        for (int i = 0; i &lt; n; i++) {\n            while (!indices.empty() &amp;&amp; temperatures[i] &gt; temperatures[indices.top()]) {\n                int prevIndex = indices.top();\n                indices.pop();\n                answer[prevIndex] = i - prevIndex;\n            }\n            indices.push(i);\n        }\n\n        return answer;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>The stack <code>indices</code> stores indices of days with temperatures for which we haven't found a warmer day yet.</li> <li>If the current day's temperature is warmer than the temperature at the top index of the stack, we calculate the difference in days and store it in <code>answer</code>.</li> <li>We continue this process until we find a day in the stack which has a temperature equal to or warmer than the current day or the stack becomes empty.</li> <li>The <code>answer</code> array stores the number of days to wait for a warmer temperature for each day. If no warmer temperature is found in the future, it remains 0 (as initialized).</li> </ul>"},{"location":"Leetcode/0700-0799/0739-daily-temperatures/#about-monotonic-stack","title":"About Monotonic Stack","text":"<p>The monotonic stack is a specialized stack used for solving problems related to sequences, where we need to find the next or previous greater or smaller elements in an array. It's useful in this problem because it efficiently maintains a collection of elements in sorted order (either increasing or decreasing), allowing us to quickly access the next or previous element that satisfies a certain condition.</p> <p>In the \"Daily Temperatures\" problem, the monotonic stack is used to keep track of temperatures that haven't yet found a warmer day in the future. As we iterate through the temperatures:</p> <ul> <li>If the current temperature is higher than the temperature at the index on the top of the stack, it means we have found a warmer day for that index. We pop it from the stack and update our answer.</li> <li>If the current temperature is not higher, it gets pushed onto the stack to wait for its warmer day.</li> </ul> <p>This approach is efficient because each element is pushed and popped at most once, leading to an \\(O(N)\\) time complexity.</p> <p>Case 1: First Greater Element to the Right (Decreasing Monotonic Stack)</p> <ul> <li>Property: Use a decreasing monotonic stack.</li> <li>Why: To find the next greater element, we want the stack to pop smaller elements when a greater element is encountered.</li> </ul> <pre><code>vector&lt;int&gt; nextGreaterElementRight(const vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    vector&lt;int&gt; result(n, -1); // initialize with -1\n    stack&lt;int&gt; s;\n\n    for (int i = 0; i &lt; n; i++) {\n        while (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i]) {\n            result[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n</code></pre> <p>Case 2: First Smaller Element to the Right (Increasing Monotonic Stack)</p> <ul> <li>Property: Use an increasing monotonic stack.</li> <li>Why: To find the next smaller element, the stack should pop larger elements when a smaller element is encountered.</li> </ul> <pre><code>vector&lt;int&gt; nextSmallerElementRight(const vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    vector&lt;int&gt; result(n, -1);\n    stack&lt;int&gt; s;\n\n    for (int i = 0; i &lt; n; i++) {\n        while (!s.empty() &amp;&amp; nums[s.top()] &gt; nums[i]) {\n            result[s.top()] = nums[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n</code></pre> <p>Case 3: First Greater Element to the Left (Decreasing Monotonic Stack)</p> <ul> <li>Property: Use a decreasing monotonic stack.</li> <li>Why: Similar to the first case but iterating from right to left.</li> </ul> <pre><code>vector&lt;int&gt; previousGreaterElementLeft(const vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    vector&lt;int&gt; result(n, -1);\n    stack&lt;int&gt; s;\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        while (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i]) {\n            result[i] = nums[s.top()];\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n</code></pre> <p>Case 4: First Smaller Element to the Left (Increasing Monotonic Stack)</p> <ul> <li>Property: Use an increasing monotonic stack.</li> <li>Why: Similar to the second case but iterating in reverse.</li> </ul> <pre><code>vector&lt;int&gt; previousSmallerElementLeft(const vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    vector&lt;int&gt; result(n, -1);\n    stack&lt;int&gt; s;\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        while (!s.empty() &amp;&amp; nums[s.top()] &gt; nums[i]) {\n            result[i] = nums[s.top()];\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"Leetcode/0700-0799/0746-min-cost-climbing-stairs/","title":"Min Cost Climbing Stairs","text":"<p>Link</p>"},{"location":"Leetcode/0700-0799/0746-min-cost-climbing-stairs/#description","title":"Description","text":"<p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>i-th</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p> <p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p> <p>Return the minimum cost to reach the top of the floor.</p> <p>Example 1:</p> <ul> <li>Input: <code>cost = [10,15,20]</code></li> <li>Output: <code>15</code></li> <li>Explanation: You will start at index 1.<ul> <li>Pay 15 and climb two steps to reach the top.</li> </ul> </li> </ul> <p>The total cost is 15.</p> <p>Example 2:</p> <ul> <li>Input: <code>cost = [1,100,1,1,1,100,1,1,100,1]</code></li> <li>Output: <code>6</code></li> <li>Explanation: You will start at index 0.<ul> <li>Pay 1 and climb two steps to reach index 2.</li> <li>Pay 1 and climb two steps to reach index 4.</li> <li>Pay 1 and climb two steps to reach index 6.</li> <li>Pay 1 and climb one step to reach index 7.</li> <li>Pay 1 and climb two steps to reach index 9.</li> <li>Pay 1 and climb one step to reach the top.</li> </ul> </li> </ul> <p>The total cost is 6.</p> <p>Constraints:</p> <ul> <li>2 &lt;= cost.length &lt;= 1000</li> <li>0 &lt;= cost[i] &lt;= 999</li> </ul>"},{"location":"Leetcode/0700-0799/0746-min-cost-climbing-stairs/#solution","title":"Solution","text":""},{"location":"Leetcode/0700-0799/0746-min-cost-climbing-stairs/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int dp[1010];\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        int n = cost.size();\n        dp[n] = dp[n + 1] = 0;\n        for (int i = n - 1; i &gt;= 0; i--) {\n            dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n        }\n        return min(dp[0], dp[1]);\n    }\n};\n</code></pre>"},{"location":"Leetcode/0700-0799/0746-min-cost-climbing-stairs/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int dp[1010];\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i &lt;= cost.size(); i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[cost.size()];\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/","title":"Sort an Array","text":"<p>Link</p>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code>, sort the array in ascending order and return it.</p> <p>You must solve the problem without using any built-in functions in \\(O(n\\log n)\\) time complexity and with the smallest space complexity possible.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [5,2,3,1]</code></li> <li>Output: <code>[1,2,3,5]</code></li> <li>Explanation: <code>After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>nums = [5,1,1,2,0,0]</code></li> <li>Output: <code>[0,0,1,1,2,5]</code></li> <li>Explanation: <code>Note that the values of nums are not necessairly unique.</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li> <li><code>-5 * 10^4 &lt;= nums[i] &lt;= 5 * 10^4</code></li> </ul>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/#solution","title":"Solution","text":""},{"location":"Leetcode/0900-0999/0912-sort-an-array/#merge-sort","title":"Merge Sort","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;int&gt; tmp;\n    void merge_sort(vector&lt;int&gt;&amp; nums, int l, int r) {\n        if (l &gt;= r) return;\n        int mid = (l + r) &gt;&gt; 1;\n        merge_sort(nums, l, mid); merge_sort(nums, mid + 1, r);\n        int k = 0, i = l, j = mid + 1;\n        while (i &lt;= mid &amp;&amp; j &lt;= r) {\n            if (nums[i] &lt;= nums[j]) tmp[k++] = nums[i++];\n            else tmp[k++] = nums[j++];\n        }\n        while (i &lt;= mid) tmp[k++] = nums[i++];\n        while (j &lt;= r) tmp[k++] = nums[j++];\n        for (i = l, j = 0; i &lt;= r; i++, j++) nums[i] = tmp[j];\n    }\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        tmp = vector&lt;int&gt;(nums.size(), 0);\n        merge_sort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n\\log n)\\);</li> <li>Space complexity: \\(O(\\log n)\\) for recursive approach, and \\(O(1)\\) for iterative approach.</li> </ul>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/#quick-sort","title":"Quick Sort","text":"<pre><code>class Solution {\nprivate:\n    void quick_sort(vector&lt;int&gt;&amp; nums, int l, int r) {\n        if (l == r) return;\n        int i = l - 1, j = r + 1, x = nums[(l + r) &gt;&gt; 1];\n        while (i &lt; j) {\n            do i++; while (nums[i] &lt; x);\n            do j--; while (nums[j] &gt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        }\n        quick_sort(nums, l, j);\n        quick_sort(nums, j + 1, r);\n    }\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        quick_sort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n</code></pre> <ul> <li>Time complexity: average case \\(O(n\\log n)\\), worst case \\(O(n^2)\\) (but we rarely reach the worst case);</li> <li>Space complexity: \\(O(\\log n)\\).</li> </ul>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/#heap-sort","title":"Heap Sort","text":""},{"location":"Leetcode/0900-0999/0912-sort-an-array/#stl-version","title":"STL Version","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n        vector&lt;int&gt; res;\n        res.reserve(nums.size());\n        for (int i : nums) q.push(i);\n        while (!q.empty()) {\n            res.emplace_back(q.top());\n            q.pop();\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0900-0999/0912-sort-an-array/#array-version","title":"Array Version","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;int&gt; h;\n    int cnt;\n\n    void up(int u) {\n        if (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) {\n            swap(h[u], h[u / 2]);\n            up(u / 2);\n        }\n    }\n\n    void down(int u) {\n        int v = u;\n        if (2 * u &lt;= cnt &amp;&amp; h[2 * u] &lt; h[v]) v = 2 * u;\n        if (2 * u + 1 &lt;= cnt &amp;&amp; h[2 * u + 1] &lt; h[v]) v = 2 * u + 1;\n        if (u != v) {\n            swap(h[u], h[v]);\n            down(v);\n        }\n    }\n\n    void push(int x) {\n        h[++cnt] = x;\n        up(cnt);\n    }\n\n    void pop() {\n        h[1] = h[cnt--];\n        down(1);\n    }\n\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        h = vector&lt;int&gt;(n + 1, 0);\n        cnt = nums.size();\n        for (int i = 1; i &lt;= n; i++) h[i] = nums[i - 1];\n        for (int i = n / 2; i; i--) down(i);\n\n        vector&lt;int&gt; res;\n        res.reserve(n);\n        while (n--) {\n            res.emplace_back(h[1]);\n            pop();\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/0900-0999/0977-squares-of-a-sorted-array/","title":"Squares of a Sorted Array","text":"<p>Link</p>"},{"location":"Leetcode/0900-0999/0977-squares-of-a-sorted-array/#description","title":"Description","text":"<p>Given an integer array <code>nums</code> sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [-4,-1,0,3,10]</code></li> <li>Output: <code>[0,1,9,16,100]</code></li> </ul> <p>Explanation: After squaring, the array becomes <code>[16,1,0,9,100]</code>. After sorting, it becomes <code>[0,1,9,16,100]</code>.</p> <p>Example 2:</p> <ul> <li>Input: <code>nums = [-7,-3,2,3,11]</code></li> <li>Output: <code>[4,9,9,49,121]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> <li><code>nums</code> is sorted in non-decreasing order.</li> </ul>"},{"location":"Leetcode/0900-0999/0977-squares-of-a-sorted-array/#solution","title":"Solution","text":""},{"location":"Leetcode/0900-0999/0977-squares-of-a-sorted-array/#trivial-solution","title":"Trivial Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {\n        for (int i = 0; i &lt; nums.size(); i++) nums[i] = nums[i] * nums[i];\n        sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n</code></pre> <p>Time complexity: \\(O\\left( n+n\\log n \\right) \\approx O\\left( n\\log n \\right)\\)</p>"},{"location":"Leetcode/0900-0999/0977-squares-of-a-sorted-array/#double-pointer-solution","title":"Double Pointer Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; res(nums.size(), 0);\n        int k = nums.size() - 1;\n        for (int i = 0, j = nums.size() - 1; i &lt;= j; ) {  // NOTE!!!  write i &lt;= j because we need to handle the last 2 elements\n            if (nums[i] * nums[i] &lt; nums[j] * nums[j]) {\n                res[k--] = nums[j] * nums[j];\n                j--;\n            } else {\n                res[k--] = nums[i] * nums[i];\n                i++;\n            }\n        }\n        return res;\n    }\n};\n</code></pre> <p>Time complexity: \\(O(n)\\)</p>"},{"location":"Leetcode/1000-1099/1002-find-common-characters/","title":"Find Common Characters","text":"<p>Link</p>"},{"location":"Leetcode/1000-1099/1002-find-common-characters/#description","title":"Description","text":"<p>Given a string array <code>words</code>, return an array of all characters that show up in all strings within the <code>words</code> (including duplicates). You may return the answer in any order.</p> <p>Example 1:</p> <ul> <li>Input: <code>words = [\"bella\",\"label\",\"roller\"]</code></li> <li>Output: <code>[\"e\",\"l\",\"l\"]</code></li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>words = [\"cool\",\"lock\",\"cook\"]</code></li> <li>Output: <code>[\"c\",\"o\"]</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= words.length &lt;= 100</code></li> <li><code>1 &lt;= words[i].length &lt;= 100</code></li> <li><code>words[i]</code> consists of lowercase English letters.</li> </ul>"},{"location":"Leetcode/1000-1099/1002-find-common-characters/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; words) {\n        vector&lt;int&gt; cnt(26, 1e8);\n        for (auto word : words) {\n            unordered_map&lt;int, int&gt; hash;\n            for (auto c : words) hash[c - 'a'] ++;\n            for (int i = 0; i &lt; 26; i++) {\n                cnt[i] = min(cnt[i], hash[i]);\n            }\n        }\n\n        vector&lt;string&gt; res;\n        for (int i = 0; i &lt; 26; i++) {\n            for (int j = 0; j &lt; cnt[i]; j++) {\n                res.push_back(string(1, i + 'a'));\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/","title":"Remove All Adjacent Duplicates In String","text":"<p>Link</p>"},{"location":"Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#description","title":"Description","text":"<p>You are given a string <code>s</code> consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.</p> <p>We repeatedly make duplicate removals on <code>s</code> until we no longer can.</p> <p>Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</p> <p>Example 1:</p> <ul> <li>Input: <code>s = \"abbaca\"</code></li> <li>Output: <code>\"ca\"</code></li> <li>Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>s = \"azxxzy\"</code></li> <li>Output: <code>\"ay\"</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 10^5</code></li> <li><code>s</code> consists of lowercase English letters.</li> </ul>"},{"location":"Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#solution","title":"Solution","text":""},{"location":"Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    string removeDuplicates(string s) {\n        stack&lt;char&gt; stk;\n        for (auto &amp;ch : s) {\n            if (!stk.empty() &amp;&amp; stk.top() == ch) stk.pop();\n            else stk.push(ch);  // if (stk.empty() || stk.top() != ch)\n        }\n        string res;\n        while (!stk.empty()) {\n            res += stk.top();\n            stk.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(n)\\).</li> </ul>"},{"location":"Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#way-2","title":"Way 2","text":"<p>We can take a string and use it directly as a stack, which eliminates the need for the stack to be converted to a string.</p> <pre><code>class Solution {\npublic:\n    string removeDuplicates(string s) {\n        string res;\n        for (auto &amp;ch : s) {\n            if (res.empty() || res.back() != ch) res.push_back(ch);\n            else res.pop_back();\n        }\n        return res;\n    }\n};\n</code></pre> <ul> <li>Time complexity: \\(O(n)\\);</li> <li>Space complexity: \\(O(1)\\).</li> </ul>"},{"location":"Leetcode/1000-1099/1049-last-stone-weight-ii/","title":"Last Stone Weight II","text":"<p>Link</p>"},{"location":"Leetcode/1000-1099/1049-last-stone-weight-ii/#description","title":"Description","text":"<p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i</code>-th stone.</p> <p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p> <ul> <li>If <code>x == y</code>, both stones are destroyed, and</li> <li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li> </ul> <p>At the end of the game, there is at most one stone left.</p> <p>Return the smallest possible weight of the left stone. If there are no stones left, return <code>0</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>stones = [2,7,4,1,8,1]</code></li> <li>Output: <code>1</code></li> <li>Explanation:<ul> <li>We can combine 2 and 4 to get 2, so the array converts to <code>[2,7,1,8,1]</code> then,</li> <li>we can combine 7 and 8 to get 1, so the array converts to <code>[2,1,1,1]</code> then,</li> <li>we can combine 2 and 1 to get 1, so the array converts to <code>[1,1,1]</code> then,</li> <li>we can combine 1 and 1 to get 0, so the array converts to <code>[1]</code>, then that's the optimal value.</li> </ul> </li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>stones = [31,26,33,21,40]</code></li> <li>Output: <code>5</code></li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= stones.length &lt;= 30</code></li> <li><code>1 &lt;= stones[i] &lt;= 100</code></li> </ul>"},{"location":"Leetcode/1000-1099/1049-last-stone-weight-ii/#solution","title":"Solution","text":"<pre><code>class Solution {\npublic:\n    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) {\n        int sum = 0;\n        for (int x : stones) sum += x;\n        vector&lt;int&gt; dp(sum + 1, 0);\n        for (int i = 0; i &lt; stones.size(); i++) {\n            for (int j = sum / 2; j &gt;= stones[i]; j--)\n                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n        }\n        return sum - 2 * dp[sum / 2];\n    }\n};\n</code></pre>"},{"location":"Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/","title":"Minimum Number of Operations to Make Array XOR Equal to K","text":"<p>Link</p>"},{"location":"Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#description","title":"Description","text":"<p>You are given a 0-indexed integer array <code>nums</code> and a positive integer <code>k</code>.</p> <p>You can apply the following operation on the array any number of times:</p> <p>Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a <code>0</code> to <code>1</code> or vice versa. Return the minimum number of operations required to make the bitwise <code>XOR</code> of all elements of the final array equal to <code>k</code>.</p> <p>Note that you can flip leading zero bits in the binary representation of elements. For example, for the number <code>(101)_2</code> you can flip the fourth bit and obtain <code>(1101)_2</code>.</p> <p>Example 1:</p> <ul> <li>Input: <code>nums = [2,1,3,4], k = 1</code></li> <li>Output: <code>2</code></li> <li>Explanation:</li> </ul> <pre><code>We can do the following operations:\n- Choose element 2 which is 3 == (011)_2, we flip the first bit and we obtain (010)_2 == 2. nums becomes [2,1,2,4].\n- Choose element 0 which is 2 == (010)_2, we flip the third bit and we obtain (110)_2 = 6. nums becomes [6,1,2,4].\nThe XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.\nIt can be shown that we cannot make the XOR equal to k in less than 2 operations.\n</code></pre> <p>Example 2:</p> <ul> <li>Input: <code>nums = [2,0,2,0], k = 0</code></li> <li>Output: <code>0</code></li> </ul> <p>Explanation: <code>The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.</code></p>"},{"location":"Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#solution","title":"Solution","text":""},{"location":"Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#way-1","title":"Way 1","text":"<pre><code>class Solution {\npublic:\n    int minOperations(vector&lt;int&gt;&amp; nums, int k) {\n        vector&lt;int&gt; oneCnt(32, 0);\n        for (int num : nums) {\n            for (int i = 0; i &lt; 32; i++) {\n                if (num &amp; (1 &lt;&lt; i)) oneCnt[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i &lt; 32; i++) {\n            if (k &amp; (1 &lt;&lt; i)) {  //if ith bit in k = 1\n                if (!(oneCnt[i] % 2)) ans++;\n            } else {\n                if (oneCnt[i] % 2) ans++;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"location":"Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#way-2","title":"Way 2","text":"<pre><code>class Solution {\npublic:\n    int minOperations(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0, cnt = 0;\n        for (int num : nums) cnt ^= num;\n\n        for (int i = 0; i &lt; 32; i++) {\n            if ((k &amp; (1 &lt;&lt; i)) != (cnt &amp; (1 &lt;&lt; i)))\n                res++;\n        }\n\n        return res;\n    }\n};\n</code></pre>"},{"location":"Math/","title":"Math","text":""},{"location":"Miscellaneous/","title":"Miscellaneous Topics","text":""},{"location":"Miscellaneous/Algorithm_Analysis/","title":"Algorithm Analysis Basics","text":""},{"location":"Miscellaneous/Algorithm_Analysis/#how-to-write-an-algorithm","title":"How to write an algorithm","text":"<pre><code>Algorithm swap(a, b)\nBegin\n    temp = a;\n    a = b;\n    b = temp;\nEnd\n</code></pre>"},{"location":"Miscellaneous/Algorithm_Analysis/#how-to-analysis-an-algorithm","title":"How to analysis an algorithm","text":"<ol> <li>Time</li> <li>Space</li> <li>Network/Internet consumption</li> <li>Power</li> <li>CPU registers</li> </ol> <p>Time measuring:</p> <pre><code>Algorithm swap(a, b)\nBegin\n    temp = a;---------1\n    a = b;------------1\n    b = temp;---------1\nEnd\n\nf(n) = 3: O(1)\n</code></pre> <p>Space measuring:</p> <pre><code>Algorithm swap(a, b)\nBegin\n    temp = a;\n    a = b;\n    b = temp;\nEnd\n\na-----1\nb-----1\ntemp--1\n\ns(n) = 3 words: O(1)\n</code></pre>"},{"location":"Miscellaneous/Algorithm_Analysis/#frequency-count-method","title":"Frequency Count Method","text":"<p>Example 1:</p> <pre><code>Algorithm sum(A, n)\n{\n    s = 0;------------------------ 1\n    for (i = 0; i &lt; n; i++)------- n + 1\n    {\n        s = s + A[i];------------- n\n    }\n    return s;--------------------- 1\n}\n\nf(n) = 2*n + 3: O(n)\n\nA-----n\nn-----1\ns-----1\ni-----1\ns(n) = n + 3: O(n)\n</code></pre> <p>Example 2:</p> <pre><code>Algorithm Add(A, B, n)\n{\n    for (i = 0; i &lt; n; i++)------------------ n + 1\n    {\n        for (j = 0; j &lt;n; j++)--------------- n * (n + 1)\n        {\n            C[i, j] = A[i, j] + B[i, j];----- n * n\n        }\n    }\n}\n\nf(n) = 2*n^2 + 2*n + 1: O(n^2)\n\nA-----n^2\nB-----n^2\nC-----n^2\nn-----1\ni-----1\nj-----1\ns(n) = 3*n^2 + 3: O(n^2)\n</code></pre>"},{"location":"Miscellaneous/Algorithm_Analysis/#asymptotic-notations","title":"Asymptotic Notations","text":"<ol> <li>Big-oh Notation for upper bound: \\(O\\)</li> <li>Big-omega Notation for lower bound: \\(\\varOmega\\)</li> <li>Big-theta Notation for average bound: \\(\\varTheta\\)</li> </ol> <p>Big-oh: The function \\(f(n)=O(g(n))\\) if \\(\\exists\\) positive constants \\(c\\) and \\(n_0\\) such that \\(f\\left( n \\right) \\leqslant c\\cdot g\\left( n \\right)\\) for \\(\\forall n\\geqslant n_0\\).</p> <p>Example: \\(f(n)=2n+3\\): \\(2n+3\\leqslant 10n\\) for \\(n\\geqslant 1\\), \\(2n+3\\leqslant 5n^2\\) for \\(n\\geqslant 1\\)</p> \\[ \\underset{\\mathrm{lower} \\mathrm{bound}}{\\underbrace{1&lt;\\log n&lt;\\sqrt{n}}}&lt;\\underset{\\mathrm{average} \\mathrm{bound}}{\\underbrace{n}}&lt;\\underset{\\mathrm{upper} \\mathrm{bound}}{\\underbrace{n\\log n&lt;n^2&lt;n^3&lt;\\cdots &lt;2^n&lt;3^n&lt;\\cdots n^n}} \\] <p>Big-omega: The function \\(f(n)=\\varOmega (g(n))\\) if \\(\\exists\\) positive constants \\(c\\) and \\(n_0\\) such that \\(f\\left( n \\right) \\geqslant c\\cdot g\\left( n \\right)\\) for \\(\\forall n\\geqslant n_0\\).</p> <p>Example: \\(f(n)=2n+3\\): \\(f(n)=\\varOmega (n)\\), \\(f(n)=\\varOmega(\\log n)\\)</p> <p>Big-theta(recommend): The function \\(f\\left( n \\right) =\\varTheta \\left( g\\left( n \\right) \\right)\\) if \\(\\exists\\) positive constant \\(c_1\\), \\(c_2\\) and \\(n_0\\) such that \\(c_1g\\left( n \\right) \\leqslant f\\left( n \\right) \\leqslant c_2g\\left( n \\right)\\).</p> <p>Example: \\(f(n)=2n+3\\): \\(f(n)=\\varTheta (n)\\)</p>"},{"location":"Miscellaneous/Divide_and_Conquer/","title":"Divide and Conquer","text":"<p>General idea:</p> <pre><code>DAC(P) {\n    if (small(P)) {\n        Solve(P);\n    } else {\n        Divide P into P1, P2, P3, ..., Pk;\n        Apply DAC(P1), DAC(P2), ...\n        Combine(DAC(P1), DAC(P2), ...);\n    }\n}\n</code></pre> <p>Sample problems:</p> <ol> <li>Binary search</li> <li>Finding maximum and minimum</li> <li>Merge sort</li> <li>Quick sort</li> <li>Strassen's matrix multiplication</li> </ol>"},{"location":"Miscellaneous/Divide_and_Conquer/#recurrence-relations","title":"Recurrence Relations","text":"<ol> <li>\\(T(n) = T(n-1) + 1\\)</li> </ol> <pre><code>void Test(int n) {         //T(n)\n    if (n &gt; 0) {\n        printf(\"%d \", n);  //1\n        Test(n - 1);       //T(n - 1)\n    }\n}\n</code></pre> <p><code>Test(n)</code> will make \\(n+1\\) calls, and <code>prinf()</code> will execute \\(n\\) times. Time complexity \\(T(n)=n+1\\propto O(n)\\)</p> <p>Recurrence relation is:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=0\\\\     T\\left( n-1 \\right) +1, n&gt;0\\\\ \\end{cases} \\] <p>We can get: \\(T\\left( n \\right) =T\\left( n-k \\right) +k\\). Assume \\(n-k=0\\), then \\(T(n)=1+n\\)</p> <ol> <li>\\(T(n)=T(n-1)+n\\)</li> </ol> <pre><code>void Test(int n) {\n    if (n &gt; 0) {                    //1\n        for (int i = 0; i &lt; n; i++) //n + 1 \n            printf(\"%d \", i);       //n\n        Test(n - 1);                //T(n - 1)\n    }\n}\n</code></pre> <p>We get \\(T(n)=T(n-1)+2n+2\\). For simplicity, let \\(T(n)=T(n-1)+n\\). Recurrence relation is:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=0\\\\     T\\left( n-1 \\right) +n, n&gt;0\\\\ \\end{cases} \\] <p>We get \\(T(n)=T(n-k)+(n-(k-1))+(n-(k-2))+\\cdots +(n-1)+n\\).The total time: \\(T\\left( n \\right) =\\frac{n\\left( n+1 \\right)}{2}\\propto O\\left( n^2 \\right)\\)</p> <ol> <li>\\(T(n)=T(n-1)+\\log n\\)</li> </ol> <pre><code>void Test(int n) {                        //T(n)\n    if (n &gt; 0) {\n        for (int i = 1; i &lt; n; i = i * 2)\n            printf(\"%d \", i);            //log(n)\n        Test(n - 1);                     //T(n - 1)\n    }\n}\n</code></pre> <p>The recurrence relation:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=0\\\\     T\\left( n-1 \\right) +\\log n, n&gt;0\\\\ \\end{cases} \\] <p>Because \\(T\\left( n \\right) =T\\left( n-k \\right) +\\log 1+\\log 2+\\cdots \\log \\left( n-1 \\right) +\\log n\\), we get: \\(T\\left( n \\right) =\\log n!\\propto O\\left( n\\log n \\right)\\)</p> <p>Based on the examples above, we can summarize:</p> \\[ T\\left( n \\right) =T\\left( n-1 \\right) +1\\propto O\\left( n \\right) ; \\\\ T\\left( n \\right) =T\\left( n-1 \\right) +n\\propto O\\left( n^2 \\right) ; \\\\ T\\left( n \\right) =T\\left( n-1 \\right) +\\log n\\propto O\\left( n\\log n \\right) ; \\\\ T\\left( n \\right) =T\\left( n-1 \\right) +n^2\\propto O\\left( n^3 \\right) ; \\\\ T\\left( n \\right) =T\\left( n-2 \\right) +1\\propto O\\left( n \\right) ; \\\\ T\\left( n \\right) =T\\left( n-100 \\right) +1\\propto O\\left( n^2 \\right)  \\] <ol> <li>\\(T(n)=2T(n-1)+1\\)</li> </ol> <pre><code>void Test(int n) {         //T(n)\n    if (n &gt; 0) {\n        printf(\"%d \", n);  //1\n        Test(n - 1);       //T(n - 1)\n        Test(n - 1);       //T(n - 1)\n    }\n}\n</code></pre> <p>Recurrence relation:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=0\\\\     2T\\left( n-1 \\right) +1, n&gt;0\\\\ \\end{cases} \\] <p>\\(T\\left( n \\right) =2^k\\cdot T\\left( n-k \\right) +2^{k-1}+2^{k-2}+\\cdots +2^2+2+1\\). Total time: \\(1+2+2^2+\\cdots +2^n=2^{n+1}-1\\propto O(2^n)\\)</p> <p>Similarly:</p> \\[ T\\left( n \\right) =3T\\left( n-1 \\right) +1\\propto O\\left( 3^n \\right) ; \\\\ T\\left( n \\right) =2T\\left( n-1 \\right) +n\\propto O\\left( n\\cdot 2^n \\right)  \\] <ol> <li>Dividing Function \\(T\\left( n \\right) =T\\left( \\frac{n}{2} \\right) +1\\)</li> </ol> <pre><code>void Test(int n) {        //T(n)\n    if (n &gt; 1) {\n        printf(\"%d \", n); //1\n        Test(n / 2);      //T(n / 2)\n    }\n}\n</code></pre> <p>Recurrence relation:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=1\\\\     T\\left( \\frac{n}{2} \\right) +1, n&gt;1\\\\ \\end{cases} \\] <p>Because \\(T\\left( n \\right) =T\\left( \\frac{n}{2^k} \\right) +k\\), we get \\(T\\left( n \\right) \\propto O\\left( \\log n \\right)\\)</p> <p>Similarly, if \\(T\\left( n \\right) =T\\left( \\frac{n}{2} \\right) +n\\), then \\(T\\left( n \\right) \\propto O\\left( n \\right)\\);</p> <p>If \\(T\\left( n \\right) =2T\\left( \\frac{n}{2} \\right) +n\\), then \\(T\\left( n \\right) \\propto O\\left( n\\log n \\right)\\) because \\(T\\left( n \\right) =2^k\\cdot T\\left( \\frac{n}{2^k} \\right) +k\\cdot n\\)</p> <ol> <li>Root function</li> </ol> <pre><code>void Test(double n) {\n    if (n &gt; 2) {\n        printf(\"%d \", n);\n        Test(sqrt(n));\n    }\n}\n</code></pre> <p>Recurrence relation:</p> \\[ T\\left( n \\right) =\\begin{cases}     1, n=2\\\\     T\\left( \\sqrt{n} \\right) +1, n&gt;2\\\\ \\end{cases} \\] <p>We get \\(T\\left( n \\right) =T\\left( n^{\\frac{1}{2^k}} \\right) +k\\). Assume \\(n=2^m\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( \\log\\log _2n \\right)\\).</p>"},{"location":"Miscellaneous/Divide_and_Conquer/#masters-theorem","title":"Masters Theorem","text":""},{"location":"Miscellaneous/Divide_and_Conquer/#masters-theorem-for-decreasing-functions","title":"Masters Theorem for Decreasing Functions","text":"<p>If \\(T\\left( n \\right) =aT\\left( n-b \\right) +f\\left( n \\right)\\), where \\(a&gt;0, b&gt;0, f\\left( n \\right) =O\\left( n^k \\right)\\) for \\(k\\geqslant 0\\):</p> <p>If \\(a=1\\), we get \\(T\\left( n \\right) \\propto O\\left( n\\cdot f\\left( n \\right) \\right)\\);</p> <p>If \\(a&gt;1\\), we get \\(T\\left( n \\right) \\propto O\\left( a^{\\frac{n}{b}}\\cdot f\\left( n \\right) \\right)\\);</p> <p>If \\(a&lt;1\\), we get \\(T\\left( n \\right) \\propto O\\left( f\\left( n \\right) \\right)\\)</p>"},{"location":"Miscellaneous/Divide_and_Conquer/#masters-theorem-for-dividing-functions","title":"Masters Theorem for Dividing Functions","text":"<p>If \\(T\\left( n \\right) =aT\\left( \\frac{n}{b} \\right) +f\\left( n \\right)\\), where \\(a\\geqslant 1, b&gt;1, f\\left( n \\right) =\\varTheta \\left( n^k\\left( \\log n \\right) ^p \\right)\\):</p> <p>Case 1: If \\(\\log _ba&gt;k\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^{\\log _ba} \\right)\\)</p> <p>Case 2: If \\(\\log _ba=k\\):</p> <ul> <li>If \\(p&gt;-1\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^k\\left( \\log n \\right) ^{p+1} \\right)\\);</li> <li>If \\(p=-1\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^k\\log\\log n \\right)\\);</li> <li>If \\(p&lt;-1\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^k \\right)\\)</li> </ul> <p>Case 3: If \\(\\log _ba&lt;k\\): </p> <ul> <li>If \\(p\\geqslant 0\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^k\\left( \\log n \\right) ^p \\right)\\);</li> <li>If \\(p&lt;0\\), then \\(T\\left( n \\right) \\propto \\varTheta \\left( n^k \\right)\\)</li> </ul>"},{"location":"Miscellaneous/NP/","title":"NP-Complete and NP-Hard Problems","text":"Polynomial Time Algorithms Time Complexity Exponential Time Algorithms Time Complexity Binary Search \\(O(\\log n)\\) Tower of Hanoi \\(O(2^n)\\) Merge Sort \\(O(n \\log n)\\) Travelling Salesman Problem (Brute Force) \\(O(n!)\\) Heap Sort \\(O(n \\log n)\\) Boolean Formula Satisfiability (SAT) \\(O(2^n)\\) Quick Sort \\(O(n \\log n)\\) Generating Power Set \\(O(2^n)\\) Dijkstra's Algorithm \\(O(V^2)\\) Recursive Fibonacci \\(O(2^n)\\) Floyd-Warshall Algorithm \\(O(V^3)\\) Exponential Graph Search \\(O(b^d)\\) Bellman-Ford Algorithm \\(O(VE)\\) Hamiltonian Path in a Graph \\(O(n!)\\) Insertion Sort \\(O(n^2)\\) Enumerating Permutations \\(O(n!)\\) Bubble Sort \\(O(n^2)\\) Knapsack Problem (Brute Force) \\(O(2^n)\\) Selection Sort \\(O(n^2)\\) Depth-first Search (in Implicit Graphs) \\(O(b^m)\\) Breadth-first Search \\(O(V + E)\\) Dynamic Programming (e.g., Fibonacci with Memoization) \\(O(n)\\) A* Search Algorithm \\(O(b^d)\\) Kruskal's Algorithm \\(O(E \\log V)\\) Prim's Algorithm \\(O(V^2)\\) or \\(O(E + \\log V)\\) with Min-Heap <p>Note:</p> <ul> <li>\\(n\\): size of the input</li> <li>\\(V\\): number of vertices in a graph</li> <li>\\(E\\): number of edges in a graph</li> <li>\\(b\\): branching factor in a graph</li> <li>\\(d\\): depth of the graph</li> <li>\\(m\\): maximum depth of the search tree</li> </ul>"},{"location":"zh/","title":"\u6211\u7684\u7b97\u6cd5\u7b14\u8bb0","text":"<p>\ud83d\udca1\ud83d\udca1\ud83d\udca1 \u6301\u7eed\u66f4\u65b0\u4e2d......</p> <p>\u672c\u4ed3\u5e93\u8bb0\u5f55\u4e00\u4e9b\u5e38\u89c1\u7684\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\u601d\u8def\u3001\u6a21\u677f\u53ca\u793a\u4f8b\u4ee3\u7801\uff0c\u5185\u5bb9\u6e90\u4e8e\u4e2a\u4eba\u5b66\u4e60\u7684\u603b\u7ed3\u4e0e\u5b9e\u8df5\u3002</p> <ul> <li>\u57fa\u7840\u7b97\u6cd5</li> <li>\u6392\u5e8f</li> <li>\u4e8c\u5206\u67e5\u627e</li> <li>\u9ad8\u7cbe\u5ea6\u8ba1\u7b97</li> <li>\u524d\u7f00\u548c</li> <li>\u53cc\u6307\u9488</li> <li>\u4f4d\u8fd0\u7b97</li> <li>\u79bb\u6563\u5316</li> <li>\u533a\u95f4\u5408\u5e76</li> <li>\u6570\u636e\u7ed3\u6784</li> <li>\u94fe\u8868</li> <li>\u6808\u4e0e\u961f\u5217</li> <li>KMP</li> <li>\u5b57\u5178\u6811</li> <li>\u5e76\u67e5\u96c6</li> <li>\u5806</li> <li>\u54c8\u5e0c\u8868</li> <li>C++ STL</li> <li>\u56fe\u4e0e\u641c\u7d22</li> <li>\u5e7f\u5ea6\u4f18\u5148\u4e0e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22</li> <li>\u56fe\u8bba\u521d\u6b65</li> <li>\u6700\u77ed\u8def\u5f84</li> <li>\u6700\u5c0f\u751f\u6210\u6811</li> <li>\u4e8c\u5206\u56fe</li> <li>\u7f51\u7edc\u6d41</li> <li>\u52a8\u6001\u89c4\u5212</li> <li>\u80cc\u5305\u95ee\u9898</li> <li>\u7ebf\u6027DP</li> <li>\u533a\u95f4DP</li> <li>\u6570\u4f4d\u7edf\u8ba1DP</li> <li>\u8d2a\u5fc3\u7b97\u6cd5</li> <li>\u533a\u95f4\u95ee\u9898</li> <li>Huffman\u6811</li> <li>\u6570\u5b66\u77e5\u8bc6</li> <li>\u8d28\u6570</li> <li>\u56e0\u6570</li> <li>\u6b27\u62c9\u51fd\u6570</li> <li>\u5feb\u901f\u5e42</li> <li>\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5</li> <li>\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406</li> <li>\u9ad8\u65af\u6d88\u5143\u6cd5</li> <li>\u7ec4\u5408\u6570</li> <li>Leetcode\u9898\u89e3</li> </ul> <p>\u672c\u4ed3\u5e93\u91c7\u7528CC BY-NC-SA-4.0\u534f\u8bae\u3002</p> <p></p>"},{"location":"zh/Algorithm_Basics/","title":"\u57fa\u7840\u7b97\u6cd5","text":""},{"location":"zh/Algorithm_Basics/01_Sorting/","title":"\u6392\u5e8f\u7b97\u6cd5","text":""},{"location":"zh/Algorithm_Basics/01_Sorting/#_2","title":"\u5feb\u901f\u6392\u5e8f","text":"<p>\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n\\textrm{log}_2n)\\) \uff0c\u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^2)\\)</p> <p>\u4e3b\u8981\u601d\u60f3\uff1a\u5206\u6cbb</p>"},{"location":"zh/Algorithm_Basics/01_Sorting/#_3","title":"\u5feb\u6392\u6b65\u9aa4","text":"<ol> <li>\u786e\u5b9a\u5206\u754c\u70b9 \\(x\\) (\u5b83\u662f\u6570\u7ec4\u4e2d\u7684\u67d0\u4e2a\u6570\u503c)\uff1a \\(q[l]\\) \u6216 \\(q[\\frac{(l+r)}{2}]\\) \u6216 \\(q[r]\\) \u6216\u968f\u673a\u3002</li> <li>\u8c03\u6574\u533a\u95f4\uff1a\u901a\u8fc7\u201c\u8c03\u6574\u201d(\u91cd\u70b9)\uff0c\u8ba9\u7b2c\u4e00\u4e2a\u533a\u95f4\u91cc\u7684\u6240\u6709\u6570\u90fd\u5c0f\u4e8e\u7b49\u4e8e \\(x\\) \uff0c\u7b2c\u4e8c\u4e2a\u533a\u95f4\u91cc\u7684\u6240\u6709\u6570\u90fd\u5927\u4e8e\u7b49\u4e8e \\(x\\)  (\u6ce8\uff1a\u5206\u754c\u70b9\u4e0a\u7684\u6570\u4e0d\u4e00\u5b9a\u4e3a \\(x\\) )\u3002</li> <li>\u9012\u5f52\u5904\u7406\u5de6\u53f3\u4e24\u6bb5\u3002</li> </ol> <p>\u5982\u4e0a\u201c\u8c03\u6574\u201d\u7684\u666e\u901a\u6837\u4f8b\u6b65\u9aa4(\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) )\uff1a</p> <ul> <li>Initialize \\(a[...]\\), \\(b[...]\\);</li> <li>For \\(q[l\\sim r]\\):</li> <li>if \\(q[i]\\leq x\\): \\(a[.]\\leftarrow x\\);</li> <li>if \\(p[i]&gt; x\\): \\(b[.]\\leftarrow x\\);</li> <li>\\(q[...]\\leftarrow a[...]\\); \\(q[...]\\leftarrow b[...]\\).</li> </ul> <p>\u201c\u8c03\u6574\u201d\u7684\u9ad8\u6548\u6b65\u9aa4(\u53cc\u6307\u9488)\uff1a</p> <ul> <li>\u4f7f\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u6570\u7ec4\u7684\u5f00\u5934\uff0c\u53e6\u4e00\u4e2a\u6307\u5411\u6570\u7ec4\u7684\u672b\u5c3e\u3002</li> <li>\u4ece\u5de6\u6307\u9488\u5f00\u59cb\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u5143\u7d20\u3002</li> <li>\u4ece\u53f3\u6307\u9488\u5f00\u59cb\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u5143\u7d20\u3002</li> <li>\u5982\u679c\u5de6\u6307\u9488\u5c0f\u4e8e\u7b49\u4e8e\u53f3\u6307\u9488\uff0c\u4ea4\u6362\u5b83\u4eec\u6307\u5411\u7684\u5143\u7d20\uff0c\u7136\u540e\u5c06\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\uff0c\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\u3002</li> <li>\u91cd\u590d\u5982\u4e0a\u7684\u4e09\u4e2a\u6b65\u9aa4\uff0c\u76f4\u5230\u5de6\u6307\u9488\u5927\u4e8e\u53f3\u6307\u9488\u3002</li> <li>\u73b0\u5728\uff0c\u6240\u6709\u5c0f\u4e8e\u7b49\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u5143\u7d20\u90fd\u4f4d\u4e8e\u5de6\u8fb9\uff0c\u6240\u6709\u5927\u4e8e\u7b49\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u5143\u7d20\u90fd\u4f4d\u4e8e\u53f3\u8fb9\u3002</li> </ul> <p>\u4ee5\u4e0a\u7684\u6b65\u9aa4\u6d89\u53ca\u5f88\u591a\u8fb9\u754c\u95ee\u9898\u6bd4\u8f83\u9ebb\u70e6\uff0c\u5efa\u8bae\u76f4\u63a5\u8bb0\u5fc6\u6a21\u677f\u3002\u6b64\u6a21\u677f\u4e00\u822c\u4f1a\u5728\u9762\u8bd5\u65f6\u7528\u5230\uff0c\u4f46\u673a\u8bd5\u6216\u7ade\u8d5b\u96be\u4ee5\u7528\u5230\u3002</p> <pre><code>void quick_sort(int q[], int l, int r) {\n  if (l &gt;= r) return;\n\n  int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];  //\u4e5f\u53ef\u4ee5\u5199x = q[l]\uff0c\u4f46\u4e0d\u80fd\u5199x = q[r]\uff0c\u5bf9\u5e94\u6700\u540e\u9012\u5f52\u7684\u8bed\u53e5quick_sort(q, l, j), quick_sort(q, j + 1, r);\n  while (i &lt; j) {\n    do i++; while (q[i] &lt; x);\n    do j--; while (q[j] &gt; x);\n    if (i &lt; j) swap(q[i], q[j]);\n  }\n  quick_sort(q, l, j), quick_sort(q, j + 1, r);  //\u6b64\u5904\u4e5f\u53ef\u628aj\u6539\u4e3ai\uff0c\u4f46\u5f00\u59cb\u7684x\u521d\u59cb\u5316\u5e94\u5199\u4e3ax = q[r]\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/01_Sorting/#_4","title":"\u5feb\u901f\u9009\u62e9\u7b97\u6cd5","text":"<p>\u6709\u65f6\u53ea\u662f\u8981\u627e\u51fa\u6570\u7ec4\u7b2c \\(k\\) \u5c0f\u7684\u6570\uff0c\u9012\u5f52\u65f6\u53ef\u4ee5\u53ea\u7528\u9012\u5f52\u4e00\u8fb9\u3002\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)</p> <p>\u8bbe\u5728\u67d0\u4e00\u6b65\u9012\u5f52\u8fc7\u7a0b\u4e2d\u5212\u5206\u7684\u533a\u95f4\u5de6\u8fb9\u6709 \\(S_L\\) \u4e2a\u6570\uff0c\u53f3\u8fb9\u6709 \\(S_R\\) \u4e2a\u6570\uff1a\u5982\u679c \\(k \\le S_L\\)\uff0c\u9012\u5f52\u5de6\u8fb9( \\(k\\) )\uff1b\u5982\u679c \\(k &gt; S_L\\)\uff0c\u9012\u5f52\u53f3\u8fb9( \\(k-S_L\\) )</p>"},{"location":"zh/Algorithm_Basics/01_Sorting/#_5","title":"\u5f52\u5e76\u6392\u5e8f","text":"<p>\u5e73\u5747\u548c\u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a \\(O(n\\textrm{log}_2n)\\)</p> <p>\u4e3b\u8981\u601d\u60f3\uff1a\u5206\u6cbb</p>"},{"location":"zh/Algorithm_Basics/01_Sorting/#_6","title":"\u5f52\u5e76\u6392\u5e8f\u6b65\u9aa4","text":"<p>\u4ee5\u6574\u4e2a\u6570\u7ec4\u7684\u4e2d\u95f4\u70b9\u4e3a\u5206\u754c\uff0c\u5206\u4e3a\u5de6\u8fb9\u548c\u53f3\u8fb9\u3002</p> <ol> <li>\u786e\u5b9a\u5206\u754c\u70b9(\u5b83\u662f\u6570\u7ec4\u4e0b\u6807\u7684\u4e2d\u95f4\u503c): \\(mid=\\frac{(l+r)}{2}\\)\uff1b\u5212\u5206 <code>[L,R]\u2192[L,mid],[mid+1,R]</code> \u3002</li> <li>\u9012\u5f52\u6392\u5e8f\u5de6\u8fb9<code>[L,mid]</code>\u4e0e\u53f3\u8fb9<code>[mid+1,R]</code>\u3002</li> <li>\u5f52\u5e76(\u91cd\u70b9)\uff1a\u628a\u4e24\u4e2a\u6709\u5e8f\u7684\u6570\u7ec4\u5408\u5e76\u4e3a\u4e00\u4e2a\u6709\u5e8f\u7684\u5e8f\u5217(\u201c\u5408\u4e8c\u4e3a\u4e00\u201d\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) )\u3002</li> </ol> <p>\u5173\u4e8e\u201c\u5f52\u5e76\u201d\u6b65\u9aa4\uff1a</p> <ul> <li>\u8f93\u5165\uff1a\u4e24\u4e2a\u6709\u5e8f\u7684\u5b50\u6570\u7ec4\u3002</li> <li>\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684\u7ed3\u679c\u6570\u7ec4\uff0c\u7528\u4e8e\u5b58\u50a8\u5408\u5e76\u540e\u7684\u6709\u5e8f\u6570\u7ec4\u3002</li> <li>\u521d\u59cb\u5316\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u7d22\u5f15\uff0c\u4e00\u4e2a\u7528\u4e8e\u8ffd\u8e2a\u5de6\u5b50\u6570\u7ec4\uff0c\u53e6\u4e00\u4e2a\u7528\u4e8e\u8ffd\u8e2a\u53f3\u5b50\u6570\u7ec4\u3002</li> <li>\u5faa\u73af\u6bd4\u8f83\u5de6\u53f3\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u5143\u7d20\uff0c\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\u4e2d\uff1a</li> <li>\u5982\u679c\u5de6\u5b50\u6570\u7ec4\u7684\u5f53\u524d\u5143\u7d20\u5c0f\u4e8e\u53f3\u5b50\u6570\u7ec4\u7684\u5f53\u524d\u5143\u7d20\uff0c\u5219\u5c06\u5de6\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\uff0c\u5e76\u9012\u589e\u5de6\u5b50\u6570\u7ec4\u7684\u7d22\u5f15\u3002</li> <li>\u5982\u679c\u53f3\u5b50\u6570\u7ec4\u7684\u5f53\u524d\u5143\u7d20\u5c0f\u4e8e\u5de6\u5b50\u6570\u7ec4\u7684\u5f53\u524d\u5143\u7d20\uff0c\u5219\u5c06\u53f3\u5b50\u6570\u7ec4\u7684\u5143\u7d20\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\uff0c\u5e76\u9012\u589e\u53f3\u5b50\u6570\u7ec4\u7684\u7d22\u5f15\u3002</li> <li>\u5982\u679c\u4e24\u4e2a\u5b50\u6570\u7ec4\u7684\u5f53\u524d\u5143\u7d20\u76f8\u7b49\uff0c\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e00\u4e2a\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\u3002(\u4e00\u822c\u5c06\u7b2c\u4e00\u4e2a\u5b50\u6570\u7ec4\u6dfb\u52a0\uff0c\u4f7f\u5f97\u5f52\u5e76\u6392\u5e8f\u201c\u7a33\u5b9a\u201d\uff0c\u800c\u539f\u59cb\u7684\u5feb\u901f\u6392\u5e8f\u662f\u4e0d\u7a33\u5b9a\u7684)</li> <li>\u91cd\u590d\u4e0a\u8ff0\u6bd4\u8f83\u548c\u6dfb\u52a0\u6b65\u9aa4\uff0c\u76f4\u5230\u5176\u4e2d\u4e00\u4e2a\u5b50\u6570\u7ec4\u7684\u6240\u6709\u5143\u7d20\u90fd\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\u4e3a\u6b62\u3002</li> <li>\u5904\u7406\u5269\u4f59\u7684\u5143\u7d20\uff1a</li> <li>\u5982\u679c\u5de6\u5b50\u6570\u7ec4\u8fd8\u6709\u5269\u4f59\u5143\u7d20\uff0c\u5c06\u5b83\u4eec\u5168\u90e8\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\u4e2d\u3002</li> <li>\u5982\u679c\u53f3\u5b50\u6570\u7ec4\u8fd8\u6709\u5269\u4f59\u5143\u7d20\uff0c\u5c06\u5b83\u4eec\u5168\u90e8\u6dfb\u52a0\u5230\u7ed3\u679c\u6570\u7ec4\u4e2d\u3002</li> </ul> <pre><code>void merge_sort(int q[], int l, int r) {\n  if (l &gt;= r) return;\n\n  int mid = l + r &gt;&gt; 1;\n  merge_sort(q, l, mid);\n  merge_sort(q, mid + 1, r);\n\n  int k = 0, i = 1, j = mid + 1;\n  while (i &lt;= mid &amp;&amp; j &lt;= r) {\n    if (q[i] &lt;= q[j]) tmp[k++] = q[i++];\n    else tmp[k++] = q[j++];\n  }\n\n  while (i &lt;= mid) tmp[k++] = q[i++];\n  while (j &lt;= r) tmp[k++] = q[j++];\n\n  for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/01_Sorting/#_7","title":"\u6c42\u9006\u5e8f\u5bf9","text":"<p>\u6839\u636e\u5f52\u5e76\u6392\u5e8f\u7684\u6b65\u9aa4\uff0c\u5f53\u533a\u95f4\u5212\u5206\u540e\uff0c\u6ee1\u8db3\u9006\u5e8f\u5bf9\u7684\u4e24\u4e2a\u6570\u5e94\u8be5\u6ee1\u8db3\u5982\u4e0b\u4e09\u79cd\u60c5\u51b5\u4e4b\u4e00\uff1a</p> <ul> <li>\u4e24\u4e2a\u6570\u540c\u65f6\u51fa\u73b0\u5728\u5de6\u534a\u8fb9\u5185\u90e8\uff1a<code>merge_sort(L, mid)</code></li> <li>\u4e24\u4e2a\u6570\u540c\u65f6\u51fa\u73b0\u5728\u53f3\u534a\u8fb9\u5185\u90e8\uff1a<code>merge_sort(mid + 1, R)</code></li> <li>\u4e24\u4e2a\u6570\u4e00\u4e2a\u5728\u5de6\u534a\u8fb9\u4e00\u4e2a\u5728\u53f3\u534a\u8fb9\uff1a\u5bf9\u53f3\u534a\u8fb9\u533a\u95f4\u5185\u7684\u6bcf\u4e00\u4e2a\u6570 \\(q_j\\)\uff0c\u68c0\u67e5\u5de6\u534a\u8fb9\u533a\u95f4 \\(q_i\\) \u6709\u591a\u5c11\u4e2a\u6570(\u8bb0\u4e3a \\(m_j\\) )\u5927\u4e8e\u5b83\uff0c\u52a0\u8d77\u6765\u5c31\u6709\u591a\u5c11\u4e2a\u9006\u5e8f\u5bf9\uff1b\u6ce8\u610f\u5728\u201c\u5f52\u5e76\u201d\u6b65\u9aa4\u4e2d\u5f53\u6211\u4eec\u53d1\u73b0 \\(q_i (right) &gt; q_j (left)\\) \u65f6\uff0c\u5fc5\u6709\u4ece \\(i\\) \u5230 \\(mid\\) \u7684\u6240\u6709\u6570\u5927\u4e8e \\(q_j\\)\uff0c\u4ece \\(L\\) \u5230 \\(i-1\\) \u7684\u6240\u6709\u6570\u5c0f\u4e8e\u7b49\u4e8e \\(q_j\\)\uff0c\u5219 \\(m_j=mid-i+1\\)</li> </ul>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/","title":"\u4e8c\u5206\u6cd5","text":"<ul> <li>\u4e8c\u5206\u6cd5</li> <li>\u6574\u6570\u4e8c\u5206(\u6613\u9519)<ul> <li>\u60c5\u51b5\u4e00\uff1a(\u5982\u679cmid\u5c5e\u4e8e\u5de6\u8fb9)</li> <li>\u60c5\u51b5\u4e8c\uff1a(\u5982\u679cmid\u5c5e\u4e8e\u53f3\u8fb9)</li> <li>\u8865\u5145\uff1a\u6574\u6570\u4e8c\u5206\u7684\u5176\u4ed6\u53ef\u7528\u6a21\u677f</li> <li>\u6a21\u677f\u4e00</li> <li>\u6a21\u677f\u4e8c(\u63a8\u8350)</li> </ul> </li> <li>\u6d6e\u70b9\u6570\u4e8c\u5206</li> </ul>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#_2","title":"\u6574\u6570\u4e8c\u5206(\u6613\u9519)","text":"<p>\u6ee1\u8db3\u5355\u8c03\u6027\u7684\u6570\u7ec4\u4e00\u5b9a\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u4f46\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u7684\u6570\u7ec4\u4e0d\u4e00\u5b9a\u9700\u8981\u6ee1\u8db3\u5355\u8c03\u6027 (\u6709\u5355\u8c03\u6027\uff0c\u4e00\u5b9a\u80fd\u4e8c\u5206\uff1b\u6ca1\u5355\u8c03\u6027\uff0c\u4e5f\u6709\u53ef\u80fd\u80fd\u4e8c\u5206)\u3002</p> <p>\u4e8c\u5206\u7684\u672c\u8d28\u662f\u8fb9\u754c\uff1a\u53ea\u8981\u627e\u5230\u67d0\u79cd\u6027\u8d28(\u5982\uff1a\u53f3\u534a\u8fb9\u6ee1\u8db3\uff0c\u5de6\u534a\u8fb9\u4e0d\u6ee1\u8db3)\uff0c\u4f7f\u5f97\u6574\u4e2a\u533a\u95f4\u4e00\u5206\u4e3a\u4e8c\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4e8c\u5206\u628a\u5206\u754c\u70b9\u627e\u5230\u3002</p> <p>\u5728\u4e0a\u56fe\u4e2d\uff0c\u6761\u4ef6 \\(C_1\\) \u548c\u6761\u4ef6 \\(C_2\\) \u80fd\u591f\u5c06\u6570\u7ec4\u4e00\u5206\u4e3a\u4e8c\u3002\u800c\u56fe\u4e2d\u7eff\u8272\u533a\u57df\u7684\u5de6\u8fb9\u754c(\u7d22\u5f154)\u548c\u7ea2\u8272\u533a\u57df\u7684\u53f3\u8fb9\u754c(\u7d22\u5f153)\u90fd\u53ef\u4ee5\u4f5c\u4e3a \\(C_1\\) \u548c \\(C_2\\) \u7684\u5206\u754c\u70b9\uff0c\u56e0\u6b64\u6211\u4eec\u7684\u6574\u6570\u4e8c\u5206\u67e5\u627e\u6a21\u677f\u4e5f\u6709\u4e24\u4e2a\uff0c\u4e00\u4e2a\u7528\u6765\u67e5\u627e\u5de6\u8fb9\u754c(\u5373\u53f3\u4fa7\u7684\u5206\u754c\u70b9\uff0c\u7d22\u5f154)\uff0c\u4e00\u4e2a\u7528\u6765\u67e5\u627e\u53f3\u8fb9\u754c(\u5373\u5de6\u4fa7\u7684\u5206\u754c\u70b9\uff0c\u7d22\u5f153)\u3002</p> <p>\u4e3a\u5b9e\u73b0\u4e8c\u5206\u67e5\u627e\uff0c\u6211\u4eec\u9700\u8981\u786e\u4fdd\u6bcf\u6b21\u7f29\u5c0f\u533a\u95f4\u65f6\u7b54\u6848\u90fd\u843d\u5728\u533a\u95f4\u5185\u3002</p> <p>\u8fd9\u7bc7\u535a\u6587 \u4ee5\u53ca \u8fd9\u7bc7 \u8bb2\u89e3\u5f97\u8f83\u597d\u3002</p> <p>\u4f8b\u9898\uff1a\u6570\u7684\u8303\u56f4</p> <p>\u8be5\u4f8b\u9898\u7684\u56fe\u89e3\uff1a</p> <p></p> <p>\u4e8c\u5206\u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#mid","title":"\u60c5\u51b5\u4e00\uff1a(\u5982\u679cmid\u5c5e\u4e8e\u5de6\u8fb9)","text":"<p>\u5728\u53f3\u534a\u6bb5\u5bfb\u627e\u5de6\u8fb9\u754c(\u5373\u5bfb\u627e\u7b26\u5408\u6027\u8d28\u7684\u7b2c\u4e00\u4e2a\u70b9)\uff1a\u56e0\u4e3a\u67e5\u627e\u7684\u662f\u7eff\u8272\u533a\u57df\u7684\u5de6\u8fb9\u754c\uff0c\u6240\u4ee5\u5148\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570<code>check(i)</code>\uff0c\u5176\u4e2d\u53c2\u6570 \\(i\\) \u662f\u7d22\u5f15\uff1a</p> <ul> <li>\u5f53 \\(i\\) \u4f4d\u4e8e\u7eff\u8272\u533a\u57df\uff0c\u5373 \\(4\\leqslant i \\leqslant 7\\) \u65f6\uff0c<code>check(i)</code> \u4e3a\u771f\uff1b</li> <li>\u5f53 \\(i\\) \u4f4d\u4e8e\u7ea2\u8272\u533a\u57df\uff0c\u5373 \\(0\\leqslant i \\leqslant 3\\) \u65f6\uff0c<code>check(i)</code>\u4e3a\u5047\u3002</li> </ul> <p>\u6bcf\u6b21\u5c06\u533a\u95f4\u5212\u5206\u4e3a \\([l, mid]\\) \u548c \\([mid + 1, r]\\) ( \\([l, mid]\\) \u662f\u56e0\u4e3a \\(mid\\) \u70b9\u53ef\u80fd\u5c31\u662f\u5de6\u8fb9\u754c\uff0c\u6240\u4ee5\u8fd9\u91cc\u4e0d\u7528 \\([l, mid - 1]\\) )\uff1a</p> <ul> <li>\\(mid=\\frac{l+r}{2}\\);</li> <li>If (<code>check(mid)</code>\u662f\u5426\u6ee1\u8db3\u7eff\u8272\u6027\u8d28):</li> <li><code>True</code>\uff1a\u8bf4\u660e<code>mid</code>\u4f4d\u4e8e\u7eff\u8272\u533a\u57df\uff0c\u4e14<code>mid</code>\u6709\u53ef\u80fd\u5c31\u662f\u5de6\u8fb9\u754c\uff1b<ul> <li>\u60f3\u8981\u627e\u5230\u7684\u70b9\u5fc5\u7136\u5728 \\([l, mid]\\): \\(r\\Leftarrow mid\\)</li> </ul> </li> <li><code>False</code>\uff1a\u8bf4\u660e<code>mid</code>\u4f4d\u4e8e\u7ea2\u8272\u533a\u57df\uff0c\u4e14<code>mid</code>\u5fc5\u4e0d\u53ef\u80fd\u662f\u7eff\u8272\u533a\u57df\u7684\u5de6\u8fb9\u754c(\u56e0\u4e3a<code>mid</code>\u6700\u591a\u662f\u7d22\u5f153)\uff1b<ul> <li>\u60f3\u8981\u627e\u5230\u7684\u70b9\u5fc5\u7136\u5728 \\([mid+1, r]\\): \\(l\\Leftarrow mid+1\\)</li> </ul> </li> </ul> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>bool check(int x) {/*\u68c0\u67e5x\u662f\u5426\u6ee1\u8db3\u67d0\u79cd\u6027\u8d28*/}\n\n// \u533a\u95f4[l, r]\u88ab\u5212\u5206\u6210[l, mid]\u548c[mid + 1, r]\u65f6\u4f7f\u7528\n//\u67e5\u627e\u5de6\u8fb9\u754c SearchLeft\nint bsearch_1(int l, int r) {\n    while (l &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if (check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#mid_1","title":"\u60c5\u51b5\u4e8c\uff1a(\u5982\u679cmid\u5c5e\u4e8e\u53f3\u8fb9)","text":"<p>\u5728\u5de6\u534a\u6bb5\u5bfb\u627e\u53f3\u8fb9\u754c(\u5373\u5bfb\u627e\u7b26\u5408\u6027\u8d28\u7684\u6700\u540e\u4e00\u4e2a\u70b9)\uff1a\u56e0\u4e3a\u67e5\u627e\u7684\u662f\u7ea2\u8272\u533a\u57df\u7684\u53f3\u8fb9\u754c\uff0c\u6240\u4ee5\u5148\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570<code>check(i)</code>\uff0c\u8bbe\u53c2\u6570 \\(i\\) \u4e3a\u7d22\u5f15\uff1a</p> <ul> <li>\u5f53 \\(i\\) \u4f4d\u4e8e\u7ea2\u8272\u533a\u57df\uff0c\u5373 \\(0\\leqslant i \\leqslant 3\\) \u65f6\uff0c<code>check(i)</code>\u4e3a\u771f\uff1b</li> <li>\u5f53 \\(i\\) \u4f4d\u4e8e\u7eff\u8272\u533a\u57df\uff0c\u5373 \\(4\\leqslant i \\leqslant 7\\) \u65f6\uff0c<code>check(i)</code>\u4e3a\u5047\u3002</li> </ul> <p>\u6bcf\u6b21\u5c06\u533a\u95f4\u5212\u5206\u4e3a \\([l, mid - 1]\\) \u548c \\([mid, r]\\)  (\u8fd9\u662f\u56e0\u4e3a\u5982\u679c \\(mid\\) \u70b9\u7b26\u5408\u6027\u8d28\uff0c\u90a3\u4e48\u4e0b\u6b21\u5212\u5206\u53f3\u8fb9\u754c\u80af\u5b9a\u4ece \\(mid-1\\) \u5f00\u59cb)\uff1a</p> <ul> <li>\\(mid=\\frac{l+r+1}{2}\\);</li> <li>If (<code>check(mid)</code>\u662f\u5426\u6ee1\u8db3\u7ea2\u8272\u6027\u8d28):</li> <li><code>True</code>\uff1a\u8bf4\u660e<code>mid</code>\u4f4d\u4e8e\u7ea2\u8272\u533a\u57df\uff0c\u4e14<code>mid</code>\u6709\u53ef\u80fd\u5c31\u662f\u53f3\u8fb9\u754c\uff1b<ul> <li>\u60f3\u8981\u627e\u5230\u7684\u70b9\u5fc5\u7136\u5728 \\([mid, r]\\): \\(l\\Leftarrow mid\\)</li> </ul> </li> <li><code>False</code>\uff1a\u8bf4\u660e<code>mid</code>\u4f4d\u4e8e\u7eff\u8272\u533a\u57df\uff0c\u4e14<code>mid</code>\u5fc5\u4e0d\u53ef\u80fd\u662f\u7ea2\u8272\u533a\u57df\u7684\u53f3\u8fb9\u754c(\u56e0\u4e3a<code>mid</code>\u6700\u5c11\u662f\u7d22\u5f154)\uff1b<ul> <li>\u60f3\u8981\u627e\u5230\u7684\u70b9\u5fc5\u7136\u5728 \\([l, mid-1]\\): \\(r\\Leftarrow mid-1\\)</li> </ul> </li> </ul> <p>\\(mid=\\frac{l+r+1}{2}\\) \u7684 \\(+1\\) \u662f\u8003\u8651\u5230\u9664\u6cd5\u4e0b\u53d6\u6574\u3002\u5047\u8bbe \\(r=l+1\\)\uff0c\u5982\u679c\u8fd8\u662f\u53d6 \\(mid=\\frac{l+r}{2}\\) \u7684\u8bdd\uff0c\u5219\u6709 \\(mid=\\frac{2l+1}{2}=l\\)\uff0c\u8fd9\u65f6\u66f4\u65b0<code>l = mid</code>\u65f6\u4f1a\u51fa\u73b0<code>l = mid = l</code>\u7684\u6b7b\u5faa\u73af(\u66f4\u65b0\u540e\u7684\u533a\u95f4\u4ecd\u4e3a \\([l,r]\\))\u3002 \\(+1\\) \u5219\u76f8\u5f53\u4e8e\u4e0a\u53d6\u6574\uff0c\u89e3\u51b3\u4e86\u8fd9\u4e2a\u9690\u60a3\uff1a\u53d6 \\(mid=\\frac{l+r+1}{2}\\)\uff0c\u82e5<code>check(mid)</code>\u4e3a\u771f\uff0c\u5219 \\(mid=r\\)\uff0c\u66f4\u65b0\u540e\u7684\u533a\u95f4\u4e3a \\([r,r]\\)\uff0c\u5faa\u73af\u7ed3\u675f\uff1b\u82e5<code>check(mid)</code>\u4e3a\u5047\uff0c\u5219\u66f4\u65b0\u540e\u7684\u533a\u95f4\u4e3a \\([l,l]\\)\uff0c\u5faa\u73af\u7ed3\u675f\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>bool check(int x) {/*\u68c0\u67e5x\u662f\u5426\u6ee1\u8db3\u67d0\u79cd\u6027\u8d28*/}\n\n// \u533a\u95f4[l, r]\u88ab\u5212\u5206\u6210[l, mid - 1]\u548c[mid, r]\u65f6\u4f7f\u7528\n//\u67e5\u627e\u53f3\u8fb9\u754c SearchRight\nint bsearch_2(int l, int r) {\n    while (l &lt; r) {\n        int mid = l + r + 1 &gt;&gt; 1; //\u9700\u8981+1 \u9632\u6b62\u6b7b\u5faa\u73af\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n</code></pre> <p>\u811a\u6ce8\uff1a\u4e8c\u5206\u6cd5\u6c42<code>mid = (l + r) / 2</code>\u7684\u5199\u6cd5\u5176\u5b9e\u662f\u4e0d\u5b8c\u5584\u7684\uff0c\u56e0\u4e3a\u5f53<code>l</code>\u548c<code>r</code>\u90fd\u7279\u522b\u5927(\u63a5\u8fd1<code>MAX int</code>)\u7684\u65f6\u5019 \\(mid\\) \u53ef\u80fd\u4f1a\u6ea2\u51fa\u3002\u6240\u4ee5\uff0c \\(mid\\) \u5e94\u8be5\u5199\u6210<code>mid = l + (r - l) / 2</code>\uff0c\u4e0a\u53d6\u6574\u4e3a<code>mid = l + (r - l + 1) / 2</code>\u3002</p> <p>\u8bb0\u5fc6\uff1a\u7b2c\u4e00\u6b65\u5148\u4e0d\u7ba1\uff0c\u5148\u5199\u4e0a<code>mid = (l + r) / 2</code>\uff0c\u7b2c\u4e8c\u6b65\u518d\u770b\u662f<code>l = mid</code>\u8fd8\u662f<code>r = mid</code>\uff0c\u5982\u679c\u662f<code>l = mid</code>\u90a3\u5c31\u662f\u4e0a\u53d6\u6574\u5373\u8981\u518d\u52a01\uff0c\u5982\u679c\u662f<code>r = mid</code>\u5219\u4e0b\u53d6\u6574 (\u52a0\u4e0d\u52a01\u5b8c\u5168\u53d6\u51b3\u4e8e\u5199\u7684\u662f<code>l = mid</code>\uff0c\u8fd8\u662f<code>r = mid</code>)\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#_3","title":"\u8865\u5145\uff1a\u6574\u6570\u4e8c\u5206\u7684\u5176\u4ed6\u53ef\u7528\u6a21\u677f","text":"<p>\u6574\u6570\u4e8c\u5206\u5171\u6709\u5982\u4e0b\u4e09\u7c7b\u6a21\u677f\uff1a</p> <p></p> <p>\u5176\u4e2d\u53f3\u8fb9\u4e00\u5217\u7684\u6a21\u677f\u4e0d\u63a8\u8350\u4f7f\u7528\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#_4","title":"\u6a21\u677f\u4e00","text":"<p>\u6765\u6e90\u4e8e\u6b64\u9875\u9762\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>const int N = 1e5+10;\nint q[N];\n\nint BS_left_border(int x) {\n    int l = -1, r = n;\n    while (l + 1 != r) {\n        int mid = l + r &gt;&gt; 1;\n        if (x &gt; q[mid]) l = mid;\n        else r = mid;\n    }\n    if (r == n || a[r] != x) return -1;\n\n    return r;\n}\n\nint BS_right_border(int x) {\n    int l = -1, r = n;\n    while (l + 1 != r) {\n        int mid = l + r &gt;&gt; 1;\n        if (x &lt; q[mid]) r = mid;\n        else l = mid;\n    }\n    if (l == -1 || a[l] != x) return -1;\n\n    return l;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#_5","title":"\u6a21\u677f\u4e8c(\u63a8\u8350)","text":"<p>\u6765\u6e90\u4e8e\u6b64\u89c6\u9891\u3002</p> <p>\u4ee5\u4e0b\u6a21\u677f\u9002\u7528\u4e8e\u6570\u7ec4\u4e0b\u6807\u4ece0\u5f00\u59cb\u7684\u60c5\u5f62\uff1a</p> <pre><code>int find_1(int q) {\n    int l = -1, r = n;\n    while (l + 1 &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if (array[mid] &lt;= q) l = mid;\n        else r = mid;\n    }\n    return l;\n}\n\nint find_2(int q) {\n    int l = -1, r = n;\n    while (l + 1 &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if (array[mid] &gt;= q) r = mid;\n        else l = mid;\n    }\n    return r;\n}\n</code></pre> <p>\u6ce8\u610f\u4e0a\u8ff0\u6a21\u677f\u53ef\u80fd\u9700\u8981\u5224\u65ad\u6570\u7ec4\u4e0b\u6807\u662f\u5426\u8d8a\u754c\u3002</p> <p>\u4e0b\u56fe\u6240\u793a\u6a21\u677f\u9002\u7528\u4e8e\u6570\u7ec4\u4e0b\u6807\u4ece1\u5f00\u59cb\u7684\u60c5\u5f62\uff1a</p> <p></p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/#_6","title":"\u6d6e\u70b9\u6570\u4e8c\u5206","text":"<p>\u6d6e\u70b9\u6570\u4e8c\u5206\u8f83\u4e3a\u5bb9\u6613\uff0c\u5b83\u901a\u5e38\u7528\u6765\u6c42\u67d0\u4e2a\u6570 \\(x\\) \u7684\u8fd1\u4f3c\u503c\uff08 \\(x\\) \u4e0d\u6613\u76f4\u63a5\u6c42\u5f97\uff0c\u4f8b\u5982 \\(x=\\sqrt{2}\\) \u7b49\uff09\u3002\u7531\u4e8e\u6b64\u65f6\u5de6\u53f3\u4e24\u4e2a\u6307\u9488\u4e5f\u5747\u4e3a\u6d6e\u70b9\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u5224\u65ad<code>l == r</code>\uff0c\u800c\u662f\u5224\u65ad<code>r - l</code>\u662f\u5426\u5c0f\u4e8e\u9884\u5148\u8bbe\u5b9a\u7684\u7cbe\u5ea6\u3002</p> <p>\u82e5\u8981\u6c42\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e\u7b2c \\(k\\) \u4f4d\uff0c\u5219<code>eps</code>\u4e00\u822c\u53ef\u53d6 \\(10^{-(k+2)}\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u6570\u7684\u4e09\u6b21\u65b9\u6839</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>bool check(double x) {/*\u68c0\u67e5x\u662f\u5426\u6ee1\u8db3\u67d0\u79cd\u6027\u8d28*/}\n\ndouble bsearch_3(double l, double r) {\n    const double eps = 1e-6; // eps\u8868\u793a\u7cbe\u5ea6\uff0c\u53d6\u51b3\u4e8e\u9898\u76ee\u5bf9\u7cbe\u5ea6\u7684\u8981\u6c42\n    while (r - l &gt; eps) {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/","title":"\u4f8b\u9898\uff1a\u6d6e\u70b9\u6570\u4e8c\u5206","text":"<p>\u4ee3\u7801</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/#_2","title":"\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u6d6e\u70b9\u6570 \\(n\\)\uff0c\u6c42\u5b83\u7684\u4e09\u6b21\u65b9\u6839\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/#_3","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u5171\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u6d6e\u70b9\u6570 \\(n\\)\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/#_4","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5171\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u6d6e\u70b9\u6570\uff0c\u8868\u793a\u95ee\u9898\u7684\u89e3\u3002</p> <p>\u6ce8\u610f\uff0c\u7ed3\u679c\u4fdd\u7559 \\(6\\) \u4f4d\u5c0f\u6570\u3002</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/#_5","title":"\u6570\u636e\u8303\u56f4","text":"<p>\\(\u221210000 \\leqslant n \\leqslant 10000\\)</p>"},{"location":"zh/Algorithm_Basics/02_Binary_Search/binary_search_float/#_6","title":"\u89e3\u7b54","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble x;\n\nint main() {\n    cin &gt;&gt; x;\n    double l = -1000, r = 1000;\n\n    //\u4e5f\u53ef\u4ee5\u76f4\u63a5for\u5faa\u73af100\u6b21\n    while (r - l &gt;= 1e-8) {\n        double mid = (l + r) / 2;\n        if (mid * mid * mid &lt;= x) l = mid;\n        else r = mid;\n    }\n    printf(\"%.6lf\", l);\n    return 0;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/03_High_Precision/","title":"\u9ad8\u7cbe\u5ea6\u8ba1\u7b97(Java\u3001Python\u4e0d\u9002\u7528)","text":"<p>\u4e00\u822c\u5e94\u7528\u4e8e \\(A+B\\) \uff0c \\(A-B\\) \uff0c \\(A\\cdot\\alpha\\) \u4ee5\u53ca \\(\\frac{A}{\\alpha}\\) \u7b49\u64cd\u4f5c\uff0c\u5176\u4e2d \\(A\\) \u7684\u4f4d\u6570\u4e00\u822c\u4e3a \\(10^6\\) \u8fd9\u4e00\u91cf\u7ea7\uff0c \\(\\alpha&lt;10000\\) \u3002</p> <p>C++\u4e2d\u5c06\u5927\u6574\u6570\u5b58\u50a8\u5728\u6570\u7ec4\u91cc\uff0c\u6570\u7ec4\u7b2c\u96f6\u4f4d\u5b58\u6570\u5b57\u7684\u4e2a\u4f4d\uff0c\u65b9\u4fbf\u8fdb\u4f4d\uff0c\u901a\u8fc7\u4ee3\u7801\u6a21\u62df\u4eba\u5de5\u52a0\u51cf\u6cd5\u3002</p> <p>\u51cf\u6cd5\u7684\u5224\u65ad\u89c4\u5219\uff1a</p> \\[ A-B:\\begin{cases}     A\\geqslant B\\rightarrow A-B\\\\     A-B\\rightarrow -\\left( B-A \\right)\\\\ \\end{cases} \\] <p>\u51cf\u6cd5\u6bcf\u4e00\u4f4d\u7684\u8ba1\u7b97\u65b9\u5f0f\uff1a</p> \\[ A_i-B_i-t:\\begin{cases}     \\geqslant 0: A_i-B_i-t\\\\     &lt;0: A_i-B_i+10-t\\\\ \\end{cases} \\]"},{"location":"zh/Algorithm_Basics/04_Partial_Sum/","title":"\u524d\u7f00\u548c\u4ee5\u53ca\u5dee\u5206","text":""},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_2","title":"\u524d\u7f00\u548c","text":""},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_3","title":"\u4e00\u7ef4","text":"<p>\u539f\u6570\u7ec4\uff1a \\(a_1,a_2,a_3,...,a_n\\) (\u6ce8\u610f\u6570\u7ec4\u4e0b\u6807\u4ece1\u5f00\u59cb)</p> <p>\u6ce8\uff1a\u51e1\u662f\u6d89\u53ca\u4e0b\u6807\u4e3a \\(i-1\\) \u7684\u95ee\u9898\uff0c\u5efa\u8bae\u4e0b\u6807\u4ece1\u5f00\u59cb</p> <p>\u524d\u7f00\u548c\uff1a \\(S_i=a_1+a_2+...+a_n, S_0=0\\)</p> <p>\u5982\u4f55\u6c42\u548c\uff1a \\(S_i=S_{i-1}+a_i\\)</p> <p>\u4f5c\u7528\uff1a\u6c42\u539f\u6570\u7ec4\u4e2d \\([l,r]\\) \u533a\u95f4\u6240\u6709\u6570\u7684\u548c\uff0c\u53ef\u7528 \\(S_r-S_{l-1}\\) \u8ba1\u7b97\u3002</p> <p><code>S[i] = a[1] + a[2] + ... a[i], a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>"},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_4","title":"\u4e8c\u7ef4","text":"<p>\u4e2d\u95f4\u533a\u57df(\u4e5f\u5c31\u662f\u4ee5 \\((x_1,y_1)\\) \u4e3a\u5de6\u4e0a\u89d2\uff0c \\((x_2,y_2)\\) \u4e3a\u53f3\u4e0b\u89d2\u7684\u5b50\u77e9\u9635)\u7684\u9762\u79ef\uff1a \\(S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}\\)</p> <p>\u9012\u63a8\u516c\u5f0f\uff1a \\(S_{i,j}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}\\)</p> <pre><code>S[i, j] = \u7b2ci\u884cj\u5217\u683c\u5b50\u5de6\u4e0a\u90e8\u5206\u6240\u6709\u5143\u7d20\u7684\u548c\n\u4ee5(x1, y1)\u4e3a\u5de6\u4e0a\u89d2\uff0c(x2, y2)\u4e3a\u53f3\u4e0b\u89d2\u7684\u5b50\u77e9\u9635\u7684\u548c\u4e3a\uff1a\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n</code></pre>"},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_5","title":"\u5dee\u5206","text":"<p>\u524d\u7f00\u548c\u7684\u9006\u8fd0\u7b97</p>"},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_6","title":"\u4e00\u7ef4\u5dee\u5206","text":"<p>\u7ed9\u5b9a\u539f\u6570\u7ec4 \\(a_1,a_2,...,a_n\\) \uff0c\u8981\u6c42\u6784\u9020\u6570\u7ec4 \\(b_1,b_2,...,b_n\\) \uff0c\u4f7f\u5f97 \\(a_i=b_1+b_2+...+b_i\\) (\u5373 \\(a\\) \u6570\u7ec4\u662f \\(b\\) \u6570\u7ec4\u7684\u524d\u7f00\u548c)\uff0c\u6b64\u65f6\u79f0 \\(b\\) \u6570\u7ec4\u662f \\(a\\) \u6570\u7ec4\u7684\u5dee\u5206\u3002</p> <p>\u6784\u9020\u65b9\u6cd5\u662f\uff1a</p> \\[ b_1=a_1, \\\\ b_2=a_2-a_1, \\\\ b_3=a_3-a_2, \\\\ \\cdots  \\\\ ,b_n=a_n-a_{n-1} \\] <p>\u4e8b\u5b9e\u4e0a\u53ef\u4ee5\u4e0d\u7528\u8003\u8651\u5982\u4f55\u6784\u9020\uff0c\u53ea\u9700\u8003\u8651\u5982\u4f55\u66f4\u65b0\u3002</p> <pre><code>\u7ed9A\u6570\u7ec4\u533a\u95f4[l, r]\u4e2d\u7684\u6bcf\u4e2a\u6570\u52a0\u4e0ac\uff1aB[l] += c, B[r + 1] -= c\n\u80fd\u8ba9\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4eceO(n)\u53d8\u4e3aO(1)\n</code></pre>"},{"location":"zh/Algorithm_Basics/04_Partial_Sum/#_7","title":"\u4e8c\u7ef4\u5dee\u5206","text":"<p>\u7ed9\u5b9a\u539f\u77e9\u9635 \\(a_{ij}\\) \uff0c\u8981\u6c42\u6784\u9020\u5dee\u5206\u77e9\u9635 \\(b_{ij}\\) \uff0c\u6ee1\u8db3\u539f\u77e9\u9635\u662f\u5dee\u5206\u77e9\u9635\u7684\u4e8c\u7ef4\u524d\u7f00\u548c\u3002</p> <pre><code>\u7ed9\u4ee5(x1, y1)\u4e3a\u5de6\u4e0a\u89d2\uff0c(x2, y2)\u4e3a\u53f3\u4e0b\u89d2\u7684\u5b50\u77e9\u9635a\u4e2d\u7684\u6240\u6709\u5143\u7d20\u52a0\u4e0ac\uff1a\nb[x1, y1] += c, b[x2 + 1, y1] -= c, b[x1, y2 + 1] -= c, b[x2 + 1, y2 + 1] += c\n</code></pre>"},{"location":"zh/Algorithm_Basics/05_Double_Pointer/","title":"\u53cc\u6307\u9488\u7b97\u6cd5","text":""},{"location":"zh/Algorithm_Basics/05_Double_Pointer/#_2","title":"\u7c7b\u578b","text":"<p>\u5e38\u89c1\u95ee\u9898\u5206\u7c7b\uff1a</p> <ul> <li>\u4e00\u4e2a\u6570\u7ec4\u4e24\u4e2a\u6307\u9488\uff1a\u5bf9\u4e8e\u4e00\u4e2a\u5e8f\u5217\uff0c\u7528\u4e24\u4e2a\u6307\u9488\u7ef4\u62a4\u4e00\u6bb5\u533a\u95f4\uff0c\u5982\u5feb\u901f\u6392\u5e8f</li> <li>\u4e24\u4e2a\u6570\u7ec4\u5404\u4e00\u4e2a\u6307\u9488\uff1a\u5bf9\u4e8e\u4e24\u4e2a\u5e8f\u5217\uff0c\u7ef4\u62a4\u67d0\u79cd\u6b21\u5e8f\uff0c\u6bd4\u5982\u5f52\u5e76\u6392\u5e8f\u4e2d\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u5e8f\u5217\u7684\u64cd\u4f5c</li> </ul> <p>\u6838\u5fc3\u601d\u60f3\uff1a\u5c06\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4ece\u6734\u7d20\u7b97\u6cd5\u7684 \\(O(n^2)\\) \u964d\u4f4e\u5230 \\(O(n)\\)</p> <pre><code>for (int i = 0, j = 0; i &lt; n; i++) {\n    while (j &lt; i &amp;&amp; check(i, j)) j++;\n\n    //\u6bcf\u9053\u9898\u76ee\u7684\u5177\u4f53\u903b\u8f91\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u8f93\u51fa\u5b57\u7b26\u4e32 \u4f8b\u9898\uff1a\u6570\u7ec4\u5143\u7d20\u7684\u76ee\u6807\u548c \u6ce8\u610f\u8981\u5bfb\u627e\u5355\u8c03\u6027</p>"},{"location":"zh/Algorithm_Basics/05_Double_Pointer/#_3","title":"\u8303\u4f8b\uff1a\u6700\u957f\u8fde\u7eed\u4e0d\u91cd\u590d\u5b50\u5e8f\u5217","text":"<p>\u4f8b\u9898\uff1a\u6700\u957f\u8fde\u7eed\u4e0d\u91cd\u590d\u5b50\u5e8f\u5217</p> <ul> <li>\u904d\u5386\u6570\u7ec4<code>a</code>\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20<code>a[i]</code>, \u5bf9\u4e8e\u6bcf\u4e00\u4e2a<code>i</code>\uff0c\u627e\u5230<code>j</code>\u4f7f\u5f97\u53cc\u6307\u9488<code>[j, i]</code>\u7ef4\u62a4\u7684\u662f\u4ee5<code>a[i]</code>\u7ed3\u5c3e\u7684\u6700\u957f\u8fde\u7eed\u4e0d\u91cd\u590d\u5b50\u5e8f\u5217\uff0c\u957f\u5ea6\u4e3a<code>i - j + 1</code>, \u5c06\u8fd9\u4e00\u957f\u5ea6\u4e0e<code>res</code>\u7684\u8f83\u5927\u8005\u66f4\u65b0\u7ed9<code>res</code>\u3002</li> <li>\u5bf9\u4e8e\u6bcf\u4e00\u4e2a<code>i</code>\uff0c\u5982\u4f55\u786e\u5b9a<code>j</code>\u7684\u4f4d\u7f6e\uff1a\u7531\u4e8e<code>[j, i - 1]</code>\u662f\u524d\u4e00\u6b65\u5f97\u5230\u7684\u6700\u957f\u8fde\u7eed\u4e0d\u91cd\u590d\u5b50\u5e8f\u5217\uff0c\u6240\u4ee5\u5982\u679c<code>[j, i]</code>\u4e2d\u6709\u91cd\u590d\u5143\u7d20\uff0c\u4e00\u5b9a\u662f<code>a[i]</code>\uff0c\u56e0\u6b64\u53f3\u79fb<code>j</code>\u76f4\u5230<code>a[i]</code>\u4e0d\u91cd\u590d\u4e3a\u6b62(\u7531\u4e8e<code>[j, i - 1]</code>\u5df2\u7ecf\u662f\u524d\u4e00\u6b65\u7684\u6700\u4f18\u89e3\uff0c\u6b64\u65f6<code>j</code>\u53ea\u53ef\u80fd\u53f3\u79fb\u4ee5\u5254\u9664\u91cd\u590d\u5143\u7d20<code>a[i]</code>\uff0c\u4e0d\u53ef\u80fd\u5de6\u79fb\u589e\u52a0\u5143\u7d20\uff0c\u56e0\u6b64\uff0c<code>j</code>\u5177\u6709\u201c\u5355\u8c03\u6027\u201d\u3001\u672c\u9898\u53ef\u7528\u53cc\u6307\u9488\u964d\u4f4e\u590d\u6742\u5ea6)\u3002</li> <li>\u7528\u6570\u7ec4<code>s</code>\u8bb0\u5f55\u5b50\u5e8f\u5217<code>a[j ~ i]</code>\u4e2d\u5404\u5143\u7d20\u51fa\u73b0\u6b21\u6570\uff0c\u904d\u5386\u8fc7\u7a0b\u4e2d\u5bf9\u4e8e\u6bcf\u4e00\u4e2a<code>i</code>\u6709\u56db\u6b65\u64cd\u4f5c\uff1a<code>cin</code>\u5143\u7d20<code>a[i]</code> -&gt; \u5c06<code>a[i]</code>\u51fa\u73b0\u6b21\u6570<code>s[a[i]]</code>\u52a0<code>1</code> -&gt; \u82e5<code>a[i]</code>\u91cd\u590d\u5219\u53f3\u79fb<code>j</code>\uff08<code>s[a[j]]</code>\u8981\u51cf<code>1</code>\uff09 -&gt; \u786e\u5b9a<code>j</code>\u53ca\u66f4\u65b0\u5f53\u524d\u957f\u5ea6<code>i - j + 1</code>\u7ed9<code>res</code>\u3002</li> </ul> <p>\u6ce8\uff1a\u5f53\u6570\u636e\u8303\u56f4\u5f88\u5927\u65f6\uff0c\u53ef\u4ee5\u7528\u54c8\u5e0c\u8868\u505a\u3002</p> <pre><code># include &lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\nint a[N], s[N];\nint main() {\n    int n, res = 0;\n    cin &gt;&gt; n;\n    for (int i = 0, j = 0; i &lt; n; ++ i) {\n        cin &gt;&gt; a[i];\n        ++s[a[i]];\n        // \u5f53a[i]\u91cd\u590d\u65f6\uff0c\u5148\u628aa[j]\u6b21\u6570\u51cf1\uff0c\u518d\u53f3\u79fbj\u3002\n        while (s[a[i]] &gt; 1) --s[a[j++]];\n        res = max(r, i - j + 1);\n    }\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/06_Bit_Operations/","title":"\u4f4d\u8fd0\u7b97","text":"<p>\u4f4d\u8fd0\u7b97\u76f8\u5173\u7684\u77e5\u8bc6\uff1a</p> <ul> <li><code>&amp;</code>\u7b26\u53f7\uff1a<code>x &amp; y</code>\u4f1a\u5c06\u4e24\u4e2a\u5341\u8fdb\u5236\u6570\u5728\u4e8c\u8fdb\u5236\u4e0b\u8fdb\u884c\u4e0e\u8fd0\u7b97(\u90fd1\u4e3a1\uff0c\u5176\u4f59\u4e3a0)\uff0c\u7136\u540e\u8fd4\u56de\u5176\u5341\u8fdb\u5236\u4e0b\u7684\u503c\u3002\u4f8b\u5982<code>3(11) &amp; 2(10) = 2(10)</code>\u3002</li> <li><code>|</code>\u7b26\u53f7\uff1a<code>x | y</code>\u4f1a\u5c06\u4e24\u4e2a\u5341\u8fdb\u5236\u6570\u5728\u4e8c\u8fdb\u5236\u4e0b\u8fdb\u884c\u6216\u8fd0\u7b97(\u90fd0\u4e3a0\uff0c\u5176\u4f59\u4e3a1)\uff0c\u7136\u540e\u8fd4\u56de\u5176\u5341\u8fdb\u5236\u4e0b\u7684\u503c\u3002\u4f8b\u5982<code>3(11) | 2(10) = 3(11)</code>\u3002</li> <li><code>^</code>\u7b26\u53f7\uff1a<code>x^y</code>\u4f1a\u5c06\u4e24\u4e2a\u5341\u8fdb\u5236\u6570\u5728\u4e8c\u8fdb\u5236\u4e0b\u8fdb\u884c\u5f02\u6216\u8fd0\u7b97(\u4e0d\u540c\u4e3a1\uff0c\u5176\u4f59\u4e3a0)\uff0c\u7136\u540e\u8fd4\u56de\u5176\u5341\u8fdb\u5236\u4e0b\u7684\u503c\u3002\u4f8b\u5982<code>3(11) ^ 2(10) = 1(01)</code>\u3002</li> <li><code>~</code>\u7b26\u53f7\uff1a<code>~x</code>\u4e3a\u6309\u4f4d\u53d6\u53cd\uff0c\u4f8b\u5982<code>~101 = 010</code>\u3002</li> <li><code>&lt;&lt;</code>\u7b26\u53f7\uff1a\u5de6\u79fb\u64cd\u4f5c\uff0c<code>x &lt;&lt; 2</code>\u5c06<code>x</code>\u5728\u4e8c\u8fdb\u5236\u4e0b\u7684\u6bcf\u4e00\u4f4d\u5411\u5de6\u79fb\u52a8\u4e24\u4f4d\uff0c\u6700\u53f3\u8fb9\u75280\u586b\u5145\uff0c<code>x &lt;&lt; 2</code>\u76f8\u5f53\u4e8e\u8ba9<code>x</code>\u4e58\u4ee54\u3002</li> <li><code>&gt;&gt;</code>\u7b26\u53f7\uff1a\u662f\u53f3\u79fb\u64cd\u4f5c\uff0c<code>x &gt;&gt; 1</code>\u76f8\u5f53\u4e8e\u7ed9<code>x / 2</code>\uff0c\u53bb\u6389<code>x</code>\u4e8c\u8fdb\u5236\u4e0b\u7684\u6700\u53f3\u4e00\u4f4d\uff1b\u6709\u7b26\u53f7\u53f3\u79fb\uff0c\u6b63\u6570\u75280\u586b\u8865\uff0c\u8d1f\u6570\u75281\u586b\u8865\u3002</li> <li><code>&gt;&gt;&gt;</code>\u7b26\u5408\uff1a\u65e0\u7b26\u53f7\u53f3\u79fb\uff0c\u75280\u586b\u8865\u3002</li> </ul> <p>\u53c2\u89c1\u8fd9\u7bc7\u535a\u6587 (\u539f\u59cb\u5185\u5bb9\u5b58\u6863\u4e8e\u6b64)</p>"},{"location":"zh/Algorithm_Basics/06_Bit_Operations/#k","title":"\u6c42\u7b2ck\u4f4d\u6570\u5b57","text":"<p>\u5e94\u7528\uff1a<code>n</code>\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u7b2c<code>k</code>\u4f4d\u662f\u591a\u5c11 \u6ce8\u610f\uff1a\u4e2a\u4f4d\u662f\u7b2c<code>0</code>\u4f4d\u3002 \u6b65\u9aa4\uff1a</p> <ul> <li>\u5148\u628a\u7b2c<code>k</code>\u4f4d\u6570\u5b57\u79fb\u52a8\u5230\u6700\u540e\u4e00\u4f4d(\u4f7f\u7528\u53f3\u79fb<code>&gt;&gt;</code>\u8fd0\u7b97\u7b26)\u3002</li> <li>\u770b\u4e00\u4e0b\u4e2a\u4f4d\u6570\u5b57\u662f\u591a\u5c11(<code>x&amp;1</code>)\u3002</li> </ul> <p>\u53d6\u6574\u6570<code>n</code>\u7684\u4e8c\u8fdb\u5236\u6570\u7684\u7b2c<code>k</code>\u4f4d\u6570\u4e3a<code>n &gt;&gt; k &amp; 1</code>\uff0c\u6ce8\u610f\u4e8c\u8fdb\u5236\u7684\u4f4d\u6570\u662f\u4ece0\u5f00\u59cb\u800c\u4e0d\u662f1\u3002</p> <p>\u4f8b\u9898\uff1a\u6c42\u4e8c\u8fdb\u5236\u7b2ck\u4f4d</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    cout &lt;&lt; (n &gt;&gt; k &amp; 1) &lt;&lt; endl;  //\u8f93\u51fan\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u6570\u7684\u7b2ck\u4f4d\n\n    //\u5c06n\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u6570,\u4ece\u7b2ck\u4f4d~\u7b2c0\u4f4d\u4f9d\u6b21\u8f93\u51fa\n    for(int j = k; j &gt;= 0; j--) cout &lt;&lt; (n &gt;&gt; j &amp; 1) &lt;&lt; ' ';\n\n    return 0;\n}\n</code></pre>"},{"location":"zh/Algorithm_Basics/06_Bit_Operations/#1","title":"\u8fd4\u56de\u6700\u540e\u4e00\u4f4d1","text":"<p>\u4f8b\u5982\uff1a\u4e8c\u8fdb\u5236\u6570<code>110100</code>\uff0c\u6700\u540e\u4e00\u4f4d<code>1</code>\u8f93\u51fa\u4e3a<code>100</code>\u3002</p> <p>\u4e8c\u8fdb\u5236\u6570\u7684\u8865\u7801\uff1a<code>-x == ~x + 1</code>\uff0c\u5176\u4e2d<code>~x</code>\u8868\u793a\u53d6\u53cd</p> <p>\u4f8b\u9898\uff1a\u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570</p> <pre><code>//\u8fd4\u56dex\u7684\u6700\u540e\u4e00\u4f4d1\n//\u6811\u72b6\u6570\u7ec4\n//\u4f8b\u5b50\uff1a\u8f93\u5165\u4e8c\u8fdb\u5236(10100)\u3002\u8f93\u51fa\u4e8c\u8fdb\u5236(100)\n//\u6ce8\uff1a-x == ~x + 1   \u5176\u4e2d~x\u8868\u793a\u53d6\u53cd\nint low_bit(int n) {\n    return n &amp; -n;\n}\n</code></pre> <p><code>low_bit</code>\u8fd0\u7b97\u662f\u6307\u83b7\u53d6\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u4e2d\u6700\u53f3\u8fb9\u76841\u6240\u5bf9\u5e94\u7684\u6570\u503c\u3002\u5177\u4f53\u6765\u8bf4\uff0c<code>low_bit</code>\u8fd0\u7b97\u53ef\u4ee5\u901a\u8fc7\u5bf9\u4e00\u4e2a\u6570\u53d6\u53cd\u7136\u540e\u52a01\uff0c\u518d\u4e0e\u539f\u6570\u8fdb\u884c\u6309\u4f4d\u4e0e\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u3002\u5047\u8bbe<code>x</code>\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c\u6700\u53f3\u8fb9\u76841\u6240\u5728\u7684\u4f4d\u7f6e\u662f\u7b2c<code>k</code>\u4f4d\uff08\u5373\u7b2c<code>k</code>\u4f4d\u4e3a1, \u4e4b\u540e\u7684\u90fd\u4e3a0\uff09\uff0c\u90a3\u4e48\uff1a</p> <ul> <li>\u5bf9\u4e8e<code>x</code>\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c<code>k</code>\u4f4d\u4e4b\u53f3\u7684\u6570\uff0c\u5b83\u4eec\u5728<code>x</code>\u4e2d\u90fd\u5bf9\u5e94\u4e860\uff0c\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u90e8\u5206\u7684\u6570\u503c\uff0c<code>x &amp; (-x) = 0</code>\u3002</li> <li>\u5bf9\u4e8e<code>x</code>\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c<code>k</code>\u4e4b\u5de6\u7684\u6570\u503c\uff0c\u5b83\u4eec\u5728<code>x</code>\u4e2d\u5bf9\u5e94\u4e860\u6216\u80051\uff0c\u800c\u5728<code>-x</code>\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c\u4ed6\u4eec\u5bf9\u5e941\u62160\uff0c \u4e0e<code>x</code>\u7684\u6570\u503c\u76f8\u53cd\uff080\u5bf91\uff0c1\u5bf90\uff09\u3002\u56e0\u6b64\uff0c\u5728\u8fdb\u884c\u6309\u4f4d\u4e0e\u8fd0\u7b97\u65f6\uff0c<code>x</code>\u4e2d\u7b2c<code>k</code>\u4f4d\u4e4b\u5de6\u7684\u6570\u503c\u80fd\u591f\u4e0e<code>-x</code>\u4e2d\u7684\u76f8\u5e94\u4f4d\u6570\u503c\u5f97\u52300\u3002</li> <li>\u5bf9\u4e8e\u7b2c<code>k</code>\u4f4d\u6765\u8bf4\uff0c<code>x</code>\u7684\u7b2c<code>k</code>\u4f4d\u4e3a1\uff0c<code>-x</code>\u7684\u7b2c<code>k</code>\u4f4d\u4e5f\u4e3a1\uff0c\u56e0\u6b64\uff0c\u5728\u8fdb\u884c\u6309\u4f4d\u4e0e\u8fd0\u7b97\u65f6\uff0c<code>x</code>\u4e2d\u7b2c<code>k</code>\u4f4d\u7684\u6570\u503c\u80fd\u591f\u4e0e<code>-x</code>\u4e2d\u7684\u7b2c<code>k</code>\u4e3a\u6570\u503c\u5f97\u52301\u3002</li> <li>\u56e0\u6b64<code>x &amp; (-x) = 2^k</code></li> </ul> <p>\u7531\u6b64\u53ef\u89c1\uff0c<code>low_bit</code>\u8fd0\u7b97\u786e\u5b9e\u53ef\u4ee5\u5f97\u5230<code>x</code>\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u6700\u53f3\u8fb9\u76841\u6240\u5bf9\u5e94\u7684\u6570\u503c\u3002</p>"},{"location":"zh/Algorithm_Basics/06_Bit_Operations/#_2","title":"\u6539\u53d8\u4e8c\u8fdb\u5236\u67d0\u4f4d\u7684\u6570\u5b57","text":"<ul> <li>\u5224\u65ad\u4e00\u4e2a\u6570\u5b57<code>x</code>\u4e8c\u8fdb\u5236\u4e0b\u7b2c<code>i</code>\u4f4d\u662f\u4e0d\u662f\u7b49\u4e8e1\u3002\uff08\u6700\u4f4e\u7b2c0\u4f4d\uff09</li> <li>\u65b9\u6cd5\uff1a<code>if (((1 &lt;&lt; i) &amp; x ) &gt; 0)</code>\uff1a \u5c061\u5de6\u79fb<code>i</code>\u4f4d\uff0c\u76f8\u5f53\u4e8e\u5236\u9020\u4e86\u4e00\u4e2a\u53ea\u6709\u7b2c<code>i</code>\u4f4d\u4e0a\u662f1\uff0c\u5176\u4ed6\u4f4d\u4e0a\u90fd\u662f0\u7684\u4e8c\u8fdb\u5236\u6570\u3002\u7136\u540e\u4e0e<code>x</code>\u505a\u4e0e\u8fd0\u7b97\uff0c\u5982\u679c\u7ed3\u679c\u5927\u4e8e0\uff0c\u8bf4\u660e<code>x</code>\u7b2c<code>i</code>\u4f4d\u4e0a\u662f1\uff0c\u53cd\u4e4b\u5219\u662f0\u3002</li> <li>\u5c06\u4e00\u4e2a\u6570\u5b57x\u4e8c\u8fdb\u5236\u4e0b\u7b2c<code>i</code>\u4f4d\u66f4\u6539\u62101\u3002</li> <li>\u65b9\u6cd5\uff1a<code>x = x | (1 &lt;&lt; i)</code>\uff1a \u8bc1\u660e\u65b9\u6cd5\u4e0e1\u7c7b\u4f3c\u3002</li> <li>\u5c06\u4e00\u4e2a\u6570\u5b57<code>x</code>\u4e8c\u8fdb\u5236\u4e0b\u7b2c<code>i</code>\u4f4d\u66f4\u6539\u62100\u3002</li> <li>\u65b9\u6cd5\uff1a<code>x = x &amp; ~ (1 &lt;&lt; i)</code></li> <li>\u628a\u4e00\u4e2a\u6570\u5b57\u4e8c\u8fdb\u5236\u4e0b\u6700\u9760\u53f3\u7684\u7b2c\u4e00\u4e2a1\u53bb\u6389\u3002</li> <li>\u65b9\u6cd5\uff1a<code>x = x &amp; (x \u2212 1)</code></li> </ul>"},{"location":"zh/Algorithm_Basics/07_Discretization/","title":"\u79bb\u6563\u5316","text":""},{"location":"zh/Algorithm_Basics/07_Discretization/#_2","title":"\u601d\u8def","text":"<p>\u4e00\u4e32\u6709\u5e8f\u5e8f\u5217\u7684\u503c\u57df\u5f88\u5927( \\(10^9\\) )\uff0c\u4f46\u4e2a\u6570\u76f8\u5bf9\u8f83\u5c11( \\(10^5\\) )\uff0c\u8981\u6c42\u5c06\u81ea\u6570\u7ec4\u7684\u4e0b\u6807\u6620\u5c04\u5230\u4ece0\u5f00\u59cb\u7684\u4f9d\u6b21\u6807\u53f7\u3002\u5982\uff1a</p> \\[ a\\left[ \\cdots \\right] : \\begin{cases}     1\\rightarrow 0\\\\     100\\rightarrow 1\\\\     2000\\rightarrow 2\\\\     50000\\rightarrow 3\\\\ \\end{cases} \\] <p>\u79bb\u6563\u5316\u7684\u672c\u8d28\uff0c\u662f\u6620\u5c04\uff0c\u5c06\u95f4\u9694\u5f88\u5927\u7684\u70b9\uff0c\u6620\u5c04\u5230\u76f8\u90bb\u7684\u6570\u7ec4\u5143\u7d20\u4e2d\u3002\u51cf\u5c11\u5bf9\u7a7a\u95f4\u7684\u9700\u6c42\uff0c\u4e5f\u51cf\u5c11\u8ba1\u7b97\u91cf\u3002\u4e5f\u5c31\u662f\u628a\u65e0\u9650\u7a7a\u95f4\u4e2d\u6709\u9650\u7684\u4e2a\u4f53\u6620\u5c04\u5230\u6709\u9650\u7684\u7a7a\u95f4\u4e2d\u53bb\u3002</p> <p>\u6ce8\u610f\uff1a</p> <ul> <li>\u6570\u7ec4\u662f\u6709\u5e8f\u6570\u7ec4\uff0c\u8981\u5148<code>sort</code></li> <li><code>a[]</code>\u4e2d\u53ef\u80fd\u6709\u91cd\u590d\u5143\u7d20\uff0c\u6240\u4ee5\u8981\u53bb\u91cd\uff1a\u4f7f\u7528\u5e93\u51fd\u6570<code>unique</code>\uff0c\u5c06\u6570\u7ec4\u5143\u7d20\u53bb\u91cd\u5e76\u8fd4\u56de\u53bb\u91cd\u540e\u6570\u7ec4\u7684\u5c3e\u7aef\u70b9\uff0c\u518d<code>erase</code></li> <li>\u5982\u4f55\u7b97\u51fa<code>a[i]</code>(\u4fdd\u5e8f)\u79bb\u6563\u5316\u540e\u7684\u503c\u662f\u591a\u5c11\uff1a\u4e8c\u5206</li> </ul>"},{"location":"zh/Algorithm_Basics/07_Discretization/#_3","title":"\u6a21\u677f","text":"<pre><code>vector&lt;int&gt; alls;  // \u5b58\u50a8\u6240\u6709\u5f85\u79bb\u6563\u5316\u7684\u503c\nsort(alls.begin(), alls.end());  // \u5c06\u6240\u6709\u503c\u6392\u5e8f\n// \u53bb\u6389\u91cd\u590d\u5143\u7d20\nalls.erase(unique(alls.begin(), alls.end()), alls.end());\n\n// \u4e8c\u5206\u6c42\u51fax\u5bf9\u5e94\u7684\u79bb\u6563\u5316\u7684\u503c\nint find(int x) {  // \u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8ex\u7684\u4f4d\u7f6e\n    int l = 0, r = alls.size() - 1;\n    while (l &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if (alls[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    }\n    return r + 1;  // \u6620\u5c04\u52301, 2, ...n\n}\n</code></pre> <p><code>alls.erase(unique(alls.begin(), alls.end()), alls.end());</code>\u4ee3\u7801\u89e3\u6790\uff1a</p> <ul> <li><code>erase(pos, n);</code> \u5220\u9664\u4ece<code>pos</code>\u5f00\u59cb\u7684<code>n</code>\u4e2a\u5b57\u7b26\uff0c\u4f8b\u5982<code>erase(0, 1)</code>\uff0c \u5220\u9664<code>0</code>\u4f4d\u7f6e\u7684\u4e00\u4e2a\u5b57\u7b26\uff0c\u5373\u5220\u9664\u7b2c\u4e00\u4e2a\u5b57\u7b26</li> <li><code>erase(position)</code>; \u5220\u9664<code>position</code>\u5904\u7684\u4e00\u4e2a\u5b57\u7b26\uff08<code>position</code>\u662f\u4e2a<code>string</code>\u7c7b\u578b\u7684\u8fed\u4ee3\u5668\uff09</li> <li><code>erase(first\uff0clast);</code>\u5220\u9664\u4ece<code>first</code>\u5230<code>last</code>\u4e4b\u95f4\u7684\u5b57\u7b26\uff0c\uff08<code>first</code>\u548c<code>last</code>\u90fd\u662f\u8fed\u4ee3\u5668\uff09\uff0c<code>last</code>\u4e0d\u80fd\u662f<code>x.end()</code></li> <li><code>unique</code>\u4f7f\u7528\u5fc5\u987b\u8981\u5148\u8fc7\u4e00\u904d<code>sort</code>\u6392\u5e8f\u3002<code>unique</code>\u51fd\u6570\u8fd4\u7684\u8fd4\u56de\u503c\u662f\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u5b83\u6307\u5411\u7684\u662f\u53bb\u91cd\u540e\u5bb9\u5668\u4e2d\u4e0d\u91cd\u590d\u5e8f\u5217\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u3002\u6240\u4ee5\u5982\u679c\u60f3\u8981\u5f97\u5230\u4e0d\u91cd\u590d\u5143\u7d20\u7684\u4e2a\u6570\u5c31\u9700\u8981\u7528\u8fd4\u56de\u503c\u51cf\u53bb\u5f00\u59cb\u5730\u5740</li> </ul> <p>\u6ce8\uff1a<code>unique()</code>\u51fd\u6570\u7684\u5927\u81f4\u5b9e\u73b0\u601d\u8def\uff1a\u53cc\u6307\u9488\u7b97\u6cd5</p> <p>\u6240\u6709\u4e0d\u540c\u5143\u7d20(\u6392\u5e8f\u540e)\u5fc5\u6ee1\u8db3\u5982\u4e0b\u6027\u8d28\uff1a\u5b83\u662f\u7b2c\u4e00\u4e2a\uff1b\u5b83\u548c\u524d\u9762\u5143\u7d20\u4e0d\u4e00\u6837(<code>a[i] != a[i - 1]</code>)</p> <pre><code>vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a) {\n    int j = 0;\n    for (int i = 0; i &lt; a.size(); i++) {\n        if (!i || a[i] != a[i - 1])\n            a[j++] = a[i];\n        // a[0] ~ a[j - 1] \u6240\u6709a\u4e2d\u4e0d\u91cd\u590d\u7684\u6570\n    }\n    return a.begin() + j;\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u533a\u95f4\u548c</p>"},{"location":"zh/Algorithm_Basics/08_Interval_Merging/","title":"\u533a\u95f4\u5408\u5e76","text":""},{"location":"zh/Algorithm_Basics/08_Interval_Merging/#_2","title":"\u95ee\u9898\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a \\(n\\) \u4e2a\u533a\u95f4 \\([l_i,r_i]\\) \uff0c\u8981\u6c42\u5408\u5e76\u6240\u6709\u6709\u4ea4\u96c6\u7684\u533a\u95f4\u3002</p> <p>\u6ce8\u610f\u5982\u679c\u5728\u7aef\u70b9\u5904\u76f8\u4ea4\uff0c\u4e5f\u7b97\u6709\u4ea4\u96c6\u3002</p> <p>\u8f93\u51fa\u5408\u5e76\u5b8c\u6210\u540e\u7684\u533a\u95f4\u4e2a\u6570\u3002</p> <p>\u4f8b\u5982\uff1a \\([1,3]\\) \u548c \\([2,6]\\) \u53ef\u4ee5\u5408\u5e76\u4e3a\u4e00\u4e2a\u533a\u95f4 \\([1,6]\\)</p> <p>\u4f8b\u9898\uff1a\u533a\u95f4\u5408\u5e76</p>"},{"location":"zh/Algorithm_Basics/08_Interval_Merging/#_3","title":"\u601d\u8def\u4e0e\u6a21\u677f","text":"<p>\u601d\u8def(\u7c7b\u4f3c\u4e8e\u201c\u8d2a\u5fc3\u201d)\uff1a</p> <ul> <li>\u6309\u533a\u95f4\u5de6\u7aef\u70b9\u6392\u5e8f</li> <li>\u626b\u63cf\u6574\u4e2a\u533a\u95f4\uff0c\u5c06\u53ef\u80fd\u6709\u4ea4\u96c6\u7684\u533a\u95f4\u8fdb\u884c\u5408\u5e76</li> <li>\u7ef4\u62a4\u4e00\u4e2a\u201c\u5f53\u524d\u533a\u95f4\u201d</li> <li>\u6bd4\u8f83\u5f53\u524d\u533a\u95f4<code>[st,ed]</code>\u4e0e\u73b0\u5728\u626b\u5230\u533a\u95f4\u7684\u5173\u7cfb<ul> <li>\u5305\u542b\uff1a<code>st</code>\u548c<code>ed</code>\u4e0d\u53d8</li> <li>\u76f8\u4ea4\uff1a<code>ed</code>\u66f4\u65b0(\u5373\u7ef4\u62a4\u533a\u95f4\u548c\u5f53\u524d\u533a\u95f4\u7684\u5e76\u96c6)</li> <li>\u65e0\u4ea4\u96c6\uff1a\u5f53\u524d\u7ef4\u62a4\u7684\u533a\u95f4\u53ef\u4f5c\u4e3a\u6700\u7ec8\u7b54\u6848\u4e4b\u4e00\uff0c\u66f4\u65b0\u5f53\u524d\u7ef4\u62a4\u533a\u95f4\u4e3a\u65b0\u7684\u626b\u5230\u533a\u95f4</li> </ul> </li> </ul> <pre><code>// \u5c06\u6240\u6709\u5b58\u5728\u4ea4\u96c6\u7684\u533a\u95f4\u5408\u5e76\nvoid merge(vector&lt;PII&gt; &amp;segs) {\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st = -2e9, ed = -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first) {\n            if (st != -2e9) res.push_back({st, ed});\n            st = seg.first, ed = seg.second;\n        }\n        else ed = max(ed, seg.second);\n\n    if (st != -2e9) res.push_back({st, ed});\n\n    segs = res;\n}\n</code></pre>"},{"location":"zh/Data_Structures/","title":"\u5e38\u89c1\u6570\u636e\u7ed3\u6784","text":""},{"location":"zh/Data_Structures/01_Linked_List/","title":"\u94fe\u8868","text":"<p>\u8fd9\u91cc\u4e3b\u8981\u6d89\u53ca\u6570\u7ec4\u6a21\u62df\u94fe\u8868\u7684\u65b9\u6cd5(\u6bd4<code>new</code>\u5feb)\uff0c\u800c\u975e\u9762\u8bd5\u4e2d\u5e38\u8003\u7684\u52a8\u6001\u521b\u5efa\u94fe\u8868\u3002</p> <p>\u9644\u6ce8\uff1a\u9762\u8bd5\u4e2d\u521b\u5efa\u94fe\u8868\u7684\u65b9\u5f0f\u5982\u4e0b\uff1a</p> <pre><code>struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</code></pre>"},{"location":"zh/Data_Structures/01_Linked_List/#_2","title":"\u5355\u94fe\u8868","text":"<p>\u5355\u94fe\u8868\u7684\u5e38\u89c1\u7528\u9014\u662f\u90bb\u63a5\u8868(\u5176\u5b9e\u5c31\u662f\u4e00\u5806\u5355\u94fe\u8868)\uff0c\u90bb\u63a5\u8868\u6700\u91cd\u8981\u7684\u5e94\u7528\u662f\u5b58\u50a8\u56fe\u548c\u6811\u3002</p> <p>\u5355\u94fe\u8868\u6bcf\u4e2a\u70b9\u90fd\u4f1a\u5b58\u50a8<code>value</code>\u503c\u548c<code>next</code>\u6307\u9488\u3002\u7528\u6570\u7ec4\u6a21\u62df\u65f6\uff0c\u6784\u5efa\u4e24\u4e2a\u6570\u7ec4<code>e[N]</code>\u548c<code>ne[N]</code>\u5206\u522b\u4ee3\u8868\u67d0\u4e00\u4e2a\u70b9\u7684\u5f53\u524d\u503c\u548c<code>next</code>\u6307\u9488\u3002\u7a7a\u8282\u70b9\u7684\u4e0b\u6807\u7528<code>-1</code>\u8868\u793a\u3002</p> <p></p> <p>\u4f8b\u9898\uff1a\u5355\u94fe\u8868</p> <p><code>head</code>\u8868\u793a\u5934\u8282\u70b9\uff0c<code>e</code>\u6570\u7ec4\u5b58\u50a8\u5143\u7d20\uff0c<code>ne</code>\u6570\u7ec4\u5b58\u50a8\u4e0b\u4e00\u4e2a\u8282\u70b9\u7d22\u5f15\uff0c<code>idx</code>\u8868\u793a\u4e0b\u4e00\u4e2a\u53ef\u4ee5\u5b58\u50a8\u5143\u7d20\u7684\u4f4d\u7f6e\u7d22\u5f15\u3002</p> <ol> <li>\u5934\u8282\u70b9\u524d\u9762\u6dfb\u52a0\u5143\u7d20\uff1a<ol> <li>\u5728<code>e</code>\u7684<code>idx</code>\u5904\u5b58\u50a8\u5143\u7d20<code>e[idx] = x;</code></li> <li>\u8be5\u5143\u7d20\u63d2\u5165\u5230\u5934\u8282\u70b9\u524d\u9762<code>ne[idx] = head;</code></li> <li>\u5934\u8282\u70b9\u6307\u5411\u8be5\u5143\u7d20<code>head = idx;</code></li> <li><code>idx</code>\u6307\u5411\u4e0b\u4e00\u4e2a\u53ef\u5b58\u50a8\u5143\u7d20\u7684\u4f4d\u7f6e <code>idx++;</code></li> </ol> </li> <li>\u5728\u7d22\u5f15<code>k</code>\u540e\u63d2\u5165\u4e00\u4e2a\u6570\uff1a<ol> <li>\u5728<code>e</code>\u7684<code>idx</code>\u5904\u5b58\u50a8\u5143\u7d20<code>e[idx] = x;</code></li> <li>\u8be5\u5143\u7d20\u63d2\u5165\u5230\u7b2c<code>k</code>\u4e2a\u63d2\u5165\u7684\u6570\u540e\u9762<code>ne[idx] = ne[k];</code></li> <li>\u7b2c<code>k</code>\u4e2a\u63d2\u5165\u7684\u6570\u6307\u5411\u8be5\u5143\u7d20<code>ne[k] = idx;</code></li> <li><code>idx</code>\u6307\u5411\u4e0b\u4e00\u4e2a\u53ef\u5b58\u50a8\u5143\u7d20\u7684\u4f4d\u7f6e<code>idx++;</code></li> </ol> </li> <li>\u5220\u7d22\u5f15\u4e3a<code>k</code>\u7684\u5143\u7d20\u7684\u540e\u4e00\u4e2a\u5143\u7d20\uff1a<ol> <li><code>ne[k]</code>\u7684\u503c\u66f4\u65b0\u4e3a<code>ne[ne[k]]</code>\u3002</li> </ol> </li> </ol> <p>\u6a21\u677f\uff1a</p> <pre><code>// head\u5b58\u50a8\u94fe\u8868\u5934\uff0ce[]\u5b58\u50a8\u8282\u70b9\u7684\u503c\n//ne[]\u5b58\u50a8\u8282\u70b9\u7684next\u6307\u9488\uff0cidx\u8868\u793a\u5f53\u524d\u7528\u5230\u4e86\u54ea\u4e2a\u8282\u70b9\nint head, e[N], ne[N], idx;\n\n// \u521d\u59cb\u5316\nvoid init() {\n    head = -1;\n    idx = 0;\n}\n\n// \u5728\u94fe\u8868\u5934\u63d2\u5165\u4e00\u4e2a\u6570a\nvoid insert_from_head(int a) {\n    e[idx] = a, ne[idx] = head, head = idx++;\n}\n\n// \u5c06a\u63d2\u5165\u5230\u4e0b\u6807\u4e3ak\u7684\u70b9\u7684\u540e\u9762\nvoid insert_from_k(int k, int a) {\n    e[idx] = a;\n    ne[idx] = ne[k];\n    ne[k] = idx++;\n}\n\n// \u5c06\u5934\u7ed3\u70b9\u5220\u9664\uff0c\u9700\u8981\u4fdd\u8bc1\u5934\u7ed3\u70b9\u5b58\u5728\nvoid remove_head() {\n    head = ne[head];\n}\n\n// \u5c06\u4e0b\u6807\u662fk\u7684\u70b9\u7684\u540e\u9762\u7684\u70b9\u5220\u6389\nvoid remove_k(int k) {\n    ne[k] = ne[ne[k]];  // \u7b97\u6cd5\u9898\u4e2d\u4e0d\u7528\u8003\u8651\u7a7a\u95f4\u6d6a\u8d39\u95ee\u9898\n}\n\n// \u904d\u5386\u94fe\u8868\nfor (int i = head; i != -1; i = ne[i]) \n    std::cout &lt;&lt; e[i] &lt;&lt; ' ';\n</code></pre>"},{"location":"zh/Data_Structures/01_Linked_List/#_3","title":"\u53cc\u94fe\u8868","text":"<p>\u5e38\u7528\u53cc\u94fe\u8868\u4f18\u5316\u67d0\u4e9b\u95ee\u9898\u3002</p> <p>\u4e3a\u7b80\u5316\u8d77\u89c1\uff0c\u53ef\u4ee5\u4e0d\u5b9a\u4e49\u5934\u8282\u70b9\u3001\u5c3e\u8282\u70b9\uff0c\u800c\u76f4\u63a5\u7528<code>0</code>\u548c<code>1</code>\u4ee3\u8868\u5934\u548c\u5c3e\uff0c\u6240\u4ee5\u6700\u53f3\u8fb9\u63d2\u5165\u53ea\u8981\u5728\u6307\u5411<code>1</code>\u7684\u90a3\u4e2a\u70b9\u7684\u53f3\u8fb9\u63d2\u5165\u5c31\u53ef\u4ee5\u4e86\u3002</p> <p>\u4f8b\u9898\uff1a\u53cc\u94fe\u8868</p> <p>\u6a21\u677f\uff1a</p> <pre><code>// e[]\u8868\u793a\u8282\u70b9\u7684\u503c\uff0cl[]\u8868\u793a\u8282\u70b9\u7684\u5de6\u6307\u9488\n//r[]\u8868\u793a\u8282\u70b9\u7684\u53f3\u6307\u9488\uff0cidx\u8868\u793a\u5f53\u524d\u7528\u5230\u4e86\u54ea\u4e2a\u8282\u70b9\nint e[N], l[N], r[N], idx;\n\n//\u521d\u59cb\u5316\nvoid init() {\n    // 0\u662f\u5de6\u7aef\u70b9\uff0c1\u662f\u53f3\u7aef\u70b9\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n\n// \u5728\u4e0b\u6807\u4e3ak\u7684\u8282\u70b9\u7684\u53f3\u8fb9\u63d2\u5165\u4e00\u4e2a\u6570x\nvoid insert(int k, int x) {\n    e[idx] = x;\n    l[idx] = k, r[idx] = r[k]; //\u5c06\u65b0\u8282\u70b9\u5206\u522b\u6307\u5411\u63d2\u5165\u4f4d\u7f6e\u7684\u53f3\u8282\u70b9\u548c\u5de6\u8282\u70b9\n    //\u5c06\u65b0\u8282\u70b9\u53f3\u8fb9\u4e00\u8282\u70b9\u5411\u5de6\u6307\u5411\u65b0\u8282\u70b9,\u5c06\u65b0\u8282\u70b9\u5de6\u8fb9\u4e00\u8282\u70b9\u5411\u53f3\u6307\u5411\u65b0\u8282\u70b9\n    // \u66f4\u65b0\u7d22\u5f15\n    l[r[k]] = idx, r[k] = idx++;  // \u4e0d\u80fd\u5199\u53cd\uff01\n}\n\n// \u5220\u9664\u8282\u70b9a\nvoid remove(int a) {\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n</code></pre> <p>\u53c2\u8003\u8fd9\u7bc7\u9898\u89e3\u3002</p>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/","title":"\u6808\u4e0e\u961f\u5217","text":"<ul> <li>\u6808\u4e0e\u961f\u5217</li> <li>\u6808<ul> <li>\u666e\u901a\u6808</li> <li>\u5355\u8c03\u6808</li> </ul> </li> <li>\u961f\u5217<ul> <li>\u666e\u901a\u961f\u5217</li> <li>\u5faa\u73af\u961f\u5217</li> <li>\u5355\u8c03\u961f\u5217</li> </ul> </li> </ul>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_2","title":"\u6808","text":"<p>\u6808\u662f\u5148\u8fdb\u540e\u51fa\u7684\u6570\u636e\u7ed3\u6784\u3002</p>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_3","title":"\u666e\u901a\u6808","text":"<p>\u4f8b\u9898\uff1a\u6a21\u62df\u6808</p> <p>\u6570\u7ec4\u6a21\u62df\u6808\uff1a</p> <ul> <li>\u7528<code>top</code>\u8868\u793a\u6808\u9876\u6240\u5728\u7684\u7d22\u5f15\uff0c\u521d\u59cb\u65f6\uff0c<code>top = 0</code>\uff0c\u8868\u793a\u6ca1\u6709\u5143\u7d20\uff1b</li> <li><code>push x</code>\uff1a\u6808\u9876\u6240\u5728\u7d22\u5f15\u5f80\u540e\u79fb\u52a8\u4e00\u683c\uff0c\u7136\u540e\u653e\u5165<code>x</code>\u3002<code>st[++top] = x</code>\uff1b</li> <li><code>pop</code> : <code>top</code>\u5f80\u524d\u79fb\u52a8\u4e00\u683c\u3002<code>top--</code>\uff1b</li> <li><code>empty</code>\uff1a<code>top</code>\u7b49\u4e8e<code>0</code>\u5219\u6808\u975e\u7a7a\uff0c\u5c0f\u4e8e\u7b49\u4e8e<code>0</code>\u5219\u6808\u7a7a\u3002<code>top == 0 ? \"YES\" : \"NO\"</code>\uff1b</li> <li><code>query</code>\uff1a\u8fd4\u56de\u6808\u9876\u5143\u7d20\uff0c<code>st[top]</code>\u3002</li> </ul> <p>\u6a21\u677f\uff1a</p> <pre><code>// tt\u8868\u793a\u6808\u9876\nint stk[N], tt = 0;\n\n// \u5411\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u6570\nstk[++tt] = x;\n\n// \u4ece\u6808\u9876\u5f39\u51fa\u4e00\u4e2a\u6570\ntt--;\n\n// \u6808\u9876\u7684\u503c\nstk[tt];\n\n// \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679ctt &gt; 0\uff0c\u5219\u8868\u793a\u4e0d\u4e3a\u7a7a\nif (tt &gt; 0) {\n  /*do something*/\n}\n</code></pre>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_4","title":"\u5355\u8c03\u6808","text":"<p>\u5355\u8c03\u6808 \u662f\u6808\u7684\u4e00\u79cd\u7279\u6b8a\u5f62\u5f0f\uff0c\u5728\u6808\u4e2d\u7684\u5143\u7d20\u5fc5\u987b\u6ee1\u8db3\u5355\u8c03\u6027(\u4e00\u5b9a\u662f\u5355\u8c03\u4e0a\u5347\u6216\u5355\u8c03\u4e0b\u964d\u7b49\u7b49\u7684\u89c4\u5f8b)\u3002</p> <p>\u5e38\u89c1\u5e94\u7528\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6c42\u51fa\u5e8f\u5217\u4e2d\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u5de6\u8fb9\u79bb\u5b83\u6700\u8fd1\u7684\u6bd4\u5b83\u5c0f\u7684\u6570\u5728\u4ec0\u4e48\u5730\u65b9\uff0c\u82e5\u4e0d\u5b58\u5728\u8fd4\u56de<code>-1</code>\u3002</p> <p>\u4f8b\u9898\uff1a\u5355\u8c03\u6808</p> <p>\u65e2\u7136\u6211\u4eec\u5fc5\u987b\u8ba9\u5143\u7d20\u6ee1\u8db3\u5355\u8c03\u6027\uff0c\u90a3\u4e48\u6bcf\u6b21\u63d2\u5165\u5c31\u548c\u6808\u9876\u4f5c\u6bd4\u8f83\u3002\u5982\u679c\u4e0d\u6ee1\u8db3\u67d0\u4e9b\u6027\u8d28\uff0c\u76f4\u63a5\u5f39\u51fa\u6808\u9876\uff0c\u76f4\u5230\u6808\u4e3a\u7a7a\u6216\u6ee1\u8db3\u8be5\u6027\u8d28\u63d2\u5165\u8fd9\u4e2a\u5143\u7d20\u3002</p> <p>\u4ee5<code>[3, 4, 2, 7, 5]</code>\u4e3a\u4f8b\uff1a</p> <p></p> <p>\u6a21\u677f\uff1a</p> <pre><code>//\u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6bcf\u4e2a\u6570\u5de6\u8fb9\u79bb\u5b83\u6700\u8fd1\u7684\u6bd4\u5b83\u5927/\u5c0f\u7684\u6570\nint tt = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    while (tt &amp;&amp; check(stk[tt], i)) tt--;\n    stk[++tt] = i;\n}\n</code></pre>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_5","title":"\u961f\u5217","text":"<p>\u5148\u8fdb\u5148\u51fa</p>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_6","title":"\u666e\u901a\u961f\u5217","text":"<p>\u8bbe\u7f6e\uff1a</p> <ul> <li>\u7528\u4e00\u4e2a\u6570\u7ec4<code>q</code>\u4fdd\u5b58\u6570\u636e\uff1b</li> <li>\u7528<code>hh</code>\u4ee3\u8868\u961f\u5934\uff0c<code>q[hh]</code>\u5c31\u662f\u961f\u5934\u5143\u7d20\uff0c<code>q[hh + 1]</code>\u5c31\u662f\u7b2c\u4e8c\u4e2a\u5143\u7d20\uff1b</li> <li>\u7528<code>tt</code>\u4ee3\u8868\u961f\u5c3e\uff0c<code>q[tt]</code>\u5c31\u662f\u961f\u5c3e\u5143\u7d20\uff0c<code>q[tt + 1]</code>\u5c31\u662f\u4e0b\u4e00\u6b21\u5165\u961f\uff0c\u5143\u7d20\u5e94\u8be5\u653e\u7684\u4f4d\u7f6e\uff1b</li> <li><code>[hh, tt]</code>\u5de6\u95ed\u53f3\u95ed\uff0c\u4ee3\u8868\u961f\u5217\u4e2d\u5143\u7d20\u6240\u5728\u7684\u533a\u95f4\u3002</li> </ul> <p>\u64cd\u4f5c\uff1a</p> <ul> <li>\u51fa\u961f<code>pop</code>\uff1a\u56e0\u4e3a<code>hh</code>\u4ee3\u8868\u961f\u5934\uff0c<code>[hh, tt]</code>\u4ee3\u8868\u5143\u7d20\u6240\u5728\u533a\u95f4\uff0c\u6240\u4ee5\u51fa\u961f\u53ef\u4ee5\u7528<code>hh++</code>\u5b9e\u73b0\uff0c<code>hh++</code>\u540e\uff0c\u533a\u95f4\u53d8\u4e3a<code>[hh + 1, tt]</code>\uff1b</li> <li>\u5165\u961f<code>push</code>\uff1a\u56e0\u4e3a<code>tt</code>\u4ee3\u8868\u961f\u5c3e\uff0c<code>[hh, tt]</code>\u4ee3\u8868\u5143\u7d20\u6240\u5728\u533a\u95f4\uff0c\u6240\u4ee5\u5165\u961f\u53ef\u4ee5\u7528<code>tt++</code>\u5b9e\u73b0\uff0c<code>tt++</code>\u540e\uff0c\u533a\u95f4\u53d8\u4e3a<code>[hh, tt + 1]</code>, \u7136\u540e\u5728<code>q[tt + 1]</code>\u4f4d\u7f6e\u653e\u5165\u5165\u961f\u5143\u7d20\uff1b</li> <li>\u662f\u5426\u4e3a\u7a7a<code>empty</code>\uff1a<code>[hh, tt]</code>\u4ee3\u8868\u5143\u7d20\u6240\u5728\u533a\u95f4\uff0c\u5f53\u533a\u95f4\u975e\u7a7a\u7684\u65f6\u5019\uff0c\u5bf9\u5217\u975e\u7a7a\u3002\u4e5f\u5c31\u662f<code>tt &gt;= hh</code>\u7684\u65f6\u5019\uff0c\u961f\u5217\u975e\u7a7a\uff1b</li> <li>\u8be2\u95ee\u961f\u5934<code>query</code>\uff1a\u7528<code>hh</code>\u4ee3\u8868\u961f\u5934\uff0c<code>q[hh]</code>\u5c31\u662f\u961f\u5934\u5143\u7d20\uff0c\u8fd4\u56de<code>q[hh]</code>\u5373\u53ef\u3002</li> </ul> <p></p> <p>\u4f8b\u9898\uff1a\u6a21\u62df\u961f\u5217</p> <p>\u6a21\u677f\uff1a</p> <pre><code>//\u5728\u961f\u5c3e\u63d2\u5165\u5143\u7d20\uff0c\u5728\u961f\u5934\u5f39\u51fa\u5143\u7d20\nint q[N], hh = 0, tt = -1;\n\n//\u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570x\nq[++tt] = x;\n\n//\u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570\nhh++;\n\n//\u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679chh &lt;= tt\uff0c\u5219\u8868\u793a\u4e0d\u4e3a\u7a7a\nif (hh &lt;= tt) { /*not empty*/ }\nelse { /*empty*/ }\n\n//\u8bbf\u95ee\u961f\u5934\u5143\u7d20\u7684\u503c\nq[hh];\n\n//\u8bbf\u95ee\u961f\u5c3e\u5143\u7d20\u7684\u503c\nq[tt];\n</code></pre>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_7","title":"\u5faa\u73af\u961f\u5217","text":"<p>\u6a21\u677f\uff1a</p> <pre><code>//hh\u8868\u793a\u961f\u5934\uff0ctt\u8868\u793a\u961f\u5c3e\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e\nint q[N], hh = 0, tt = 0;\n\n//\u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570\nq[tt++] = x;\nif (tt == N) tt = 0;\n\n//\u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570\nhh++;\nif (hh == N) hh = 0;\n\n//\u961f\u5934\u7684\u503c\nq[hh];\n\n//\u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679chh != tt\uff0c\u5219\u8868\u793a\u4e0d\u4e3a\u7a7a\nif (hh != tt) {\n\n}\n</code></pre>"},{"location":"zh/Data_Structures/02_Stack_and_Queue/#_8","title":"\u5355\u8c03\u961f\u5217","text":"<p>\u5355\u8c03\u961f\u5217\u7684\u5b9a\u4e49\u7c7b\u4f3c\u4e8e\u5355\u8c03\u6808\uff1a</p> <ul> <li>\u5355\u8c03\u9012\u589e\u961f\u5217\uff1a\u4ece\u961f\u5c3e\u5230\u961f\u5934\u5355\u8c03\u9012\u589e\uff1b</li> <li>\u5355\u8c03\u9012\u51cf\u961f\u5217\uff1a\u4ece\u961f\u5c3e\u5230\u961f\u5934\u5355\u8c03\u9012\u51cf\u3002</li> </ul> <p>\u4f8b\u5982\u5bf9\u4e8e\u5355\u8c03\u9012\u589e\u961f\u5217\uff0c\u5411\u5176\u4e2d\u63d2\u5165\u5143\u7d20\u7684\u65f6\u5019\uff0c\u4e3a\u4e86\u7ef4\u62a4\u961f\u5217\u7684\u5355\u8c03\u6027\uff0c\u9700\u8981\u5728\u4fdd\u8bc1\u5c06\u8be5\u5143\u7d20\u63d2\u5165\u5230\u961f\u5c3e\u540e\u6574\u4e2a\u961f\u5217\u6ee1\u8db3\u5355\u8c03\u6027\u7684\u524d\u63d0\u4e0b\u5f39\u51fa\u6700\u5c11\u7684\u5143\u7d20(\u4ece\u961f\u5c3e\u5f39\u51fa)\u3002\u53ef\u89c1\u4e25\u683c\u610f\u4e49\u4e0a\u8bb2\u5355\u8c03\u961f\u5217\u5e76\u4e0d\u662f\u961f\u5217\uff0c\u56e0\u4e3a\u5b83\u4e0d\u6ee1\u8db3FIFO\u3002</p> <p>\u5e38\u89c1\u5e94\u7528\u4e3a\u6ed1\u52a8\u7a97\u53e3\uff1a\u786e\u5b9a\u6ed1\u52a8\u7a97\u53e3\u4f4d\u4e8e\u6570\u7ec4\u6bcf\u4e2a\u4f4d\u7f6e\u65f6\uff0c\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u3002</p> <p>\u4f8b\u9898\uff1a\u6ed1\u52a8\u7a97\u53e3\uff1b\u6ed1\u52a8\u7a97\u53e3(STL\u89e3\u6cd5)</p> <p>\u4ee5\u6c42\u6700\u5927\u503c\u4e3a\u4f8b\uff1a\u7531\u4e8e\u6211\u4eec\u9700\u8981\u6c42\u51fa\u7684\u662f\u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5927\u503c\u3002\u5982\u679c\u5f53\u524d\u7684\u6ed1\u52a8\u7a97\u53e3\u4e2d\u6709\u4e24\u4e2a\u4e0b\u6807<code>i</code>\u548c<code>j</code>\uff0c\u5176\u4e2d<code>i</code>\u5728<code>j</code>\u7684\u5de6\u4fa7<code>(i&lt;j)</code>\uff0c\u5e76\u4e14<code>i</code>\u5bf9\u5e94\u7684\u5143\u7d20\u4e0d\u5927\u4e8e<code>j</code>\u5bf9\u5e94\u7684\u5143\u7d20<code>(nums[i] &lt;= nums[j])</code>\uff0c\u5219\u5f53\u6ed1\u52a8\u7a97\u53e3\u5411\u53f3\u79fb\u52a8\u65f6\uff0c\u53ea\u8981<code>i</code>\u8fd8\u5728\u7a97\u53e3\u4e2d\uff0c\u90a3\u4e48<code>j</code>\u4e00\u5b9a\u4e5f\u8fd8\u5728\u7a97\u53e3\u4e2d\u3002\u8fd9\u662f\u7531\u4e8e<code>i</code>\u5728<code>j</code>\u7684\u5de6\u4fa7\u6240\u4fdd\u8bc1\u7684\u3002\u56e0\u6b64\uff0c\u7531\u4e8e<code>nums[j]</code>\u7684\u5b58\u5728\uff0c<code>nums[i]</code>\u4e00\u5b9a\u4e0d\u4f1a\u662f\u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06<code>nums[i]</code>\u6c38\u4e45\u5730\u79fb\u9664\u3002</p> <p>\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u961f\u5217\u5b58\u50a8\u6240\u6709\u8fd8\u6ca1\u6709\u88ab\u79fb\u9664\u7684\u4e0b\u6807\u3002\u5728\u961f\u5217\u4e2d\uff0c\u8fd9\u4e9b\u4e0b\u6807\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u88ab\u5b58\u50a8\uff0c\u5e76\u4e14\u5b83\u4eec\u5728\u6570\u7ec4<code>nums</code>\u4e2d\u5bf9\u5e94\u7684\u503c\u662f\u4e25\u683c\u5355\u8c03\u9012\u51cf\u7684\u3002\u5f53\u6ed1\u52a8\u7a97\u53e3\u5411\u53f3\u79fb\u52a8\u65f6\uff0c\u6211\u4eec\u9700\u8981\u628a\u4e00\u4e2a\u65b0\u7684\u5143\u7d20\u653e\u5165\u961f\u5217\u4e2d\u3002\u4e3a\u4e86\u4fdd\u6301\u961f\u5217\u7684\u6027\u8d28\uff0c\u6211\u4eec\u4f1a\u4e0d\u65ad\u5730\u5c06\u65b0\u7684\u5143\u7d20\u4e0e\u961f\u5c3e\u7684\u5143\u7d20\u76f8\u6bd4\u8f83\uff0c\u5982\u679c\u65b0\u5143\u7d20\u5927\u4e8e\u7b49\u4e8e\u961f\u5c3e\u5143\u7d20\uff0c\u90a3\u4e48\u961f\u5c3e\u7684\u5143\u7d20\u5c31\u53ef\u4ee5\u88ab\u6c38\u4e45\u5730\u79fb\u9664\uff0c\u6211\u4eec\u5c06\u5176\u5f39\u51fa\u961f\u5217\u3002\u6211\u4eec\u9700\u8981\u4e0d\u65ad\u5730\u8fdb\u884c\u6b64\u9879\u64cd\u4f5c\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\u6216\u8005\u65b0\u7684\u5143\u7d20\u5c0f\u4e8e\u961f\u5c3e\u7684\u5143\u7d20\u3002\u7531\u4e8e\u961f\u5217\u4e2d\u4e0b\u6807\u5bf9\u5e94\u7684\u5143\u7d20\u662f\u4e25\u683c\u5355\u8c03\u9012\u51cf\u7684\uff0c\u56e0\u6b64\u6b64\u65f6\u961f\u9996\u4e0b\u6807\u5bf9\u5e94\u7684\u5143\u7d20\u5c31\u662f\u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c\u3002\u7a97\u53e3\u5411\u53f3\u79fb\u52a8\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u4e0d\u65ad\u4ece\u961f\u9996\u5f39\u51fa\u5143\u7d20\u4fdd\u8bc1\u961f\u5217\u4e2d\u7684\u6240\u6709\u5143\u7d20\u90fd\u662f\u7a97\u53e3\u4e2d\u7684\uff0c\u56e0\u6b64\u5f53\u961f\u5934\u5143\u7d20\u5728\u7a97\u53e3\u7684\u5de6\u8fb9\u7684\u65f6\u5019\uff0c\u5f39\u51fa\u961f\u5934\u3002</p> <p>\u4ee5\u6c42\u6700\u5c0f\u503c\u4e3a\u4f8b\uff1a\u6211\u4eec\u4ece\u5de6\u5230\u53f3\u626b\u63cf\u6574\u4e2a\u5e8f\u5217\uff0c\u7528\u4e00\u4e2a\u961f\u5217\u6765\u7ef4\u62a4\u6700\u8fd1<code>k</code>\u4e2a\u5143\u7d20\u3002\u5982\u679c\u7528\u66b4\u529b\u6765\u505a\uff0c\u5c31\u662f\u6bcf\u6b21\u90fd\u904d\u5386\u4e00\u904d\u961f\u5217\u4e2d\u7684\u6240\u6709\u5143\u7d20\uff0c\u627e\u51fa\u6700\u5c0f\u503c\u5373\u53ef\uff0c\u4f46\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u53d8\u6210 \\(O(nk)\\) \u4e86\u3002</p> <p>\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u6027\u8d28\uff1a\u5982\u679c\u961f\u5217\u4e2d\u5b58\u5728\u4e24\u4e2a\u5143\u7d20\uff0c\u6ee1\u8db3<code>a[i] &gt;= a[j]</code>\u4e14<code>i &lt; j</code>\uff0c\u90a3\u4e48\u65e0\u8bba\u5728\u4ec0\u4e48\u65f6\u5019\u6211\u4eec\u90fd\u4e0d\u4f1a\u53d6<code>a[i]</code>\u4f5c\u4e3a\u6700\u5c0f\u503c\u4e86\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u5c06<code>a[i]</code>\u5220\u6389\uff1b\u6b64\u65f6\u961f\u5217\u4e2d\u5269\u4e0b\u7684\u5143\u7d20\u4e25\u683c\u5355\u8c03\u9012\u589e\uff0c\u6240\u4ee5\u961f\u5934\u5c31\u662f\u6574\u4e2a\u961f\u5217\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u53ef\u4ee5\u7528 \\(O(1)\\) \u7684\u65f6\u95f4\u627e\u5230\uff1b\u4e3a\u4e86\u7ef4\u62a4\u961f\u5217\u7684\u8fd9\u4e2a\u6027\u8d28\uff0c\u6211\u4eec\u5728\u5f80\u961f\u5c3e\u63d2\u5165\u5143\u7d20\u4e4b\u524d\uff0c\u5148\u5c06\u961f\u5c3e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u6570\u7684\u5143\u7d20\u5168\u90e8\u5f39\u51fa\u5373\u53ef\u3002\u8fd9\u6837\u6240\u6709\u6570\u5747\u53ea\u8fdb\u961f\u4e00\u6b21\uff0c\u51fa\u961f\u4e00\u6b21\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(n)\\) \u7684\u3002</p> <p></p> <p>\u6a21\u677f\uff1a</p> <pre><code>//\u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c/\u6700\u5c0f\u503c\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++) {\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh++ ;  // \u5224\u65ad\u961f\u5934\u662f\u5426\u6ed1\u51fa\u7a97\u53e3\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt-- ;\n    q[++tt] = i;\n}\n</code></pre> <p>\u793a\u4f8b\u7a0b\u5e8f(\u6ed1\u52a8\u7a97\u53e3\u7684\u6700\u5c0f\u4e0e\u6700\u5927\u503c)\uff1a</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N = 1000010;\nint n, k;\nint a[N], q[N];\n\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);\n\n    // \u7ef4\u62a4\u7a97\u53e3\u6700\u5c0f\u503c\n    int hh = 0, tt = -1;  // \u6e05\u7a7a\u961f\u5217\n    for (int i = 0; i &lt; n; i++) {  // \u679a\u4e3e\u961f\u5217\n        while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) tt--;  // \u961f\u5c3e\u51fa\u961f(\u961f\u5217\u4e0d\u7a7a\u4e14\u65b0\u5143\u7d20\u66f4\u4f18)\n        q[++tt] = i;  // \u961f\u5c3e\u5165\u961f(\u5b58\u50a8\u4e0b\u6807\uff0c\u65b9\u4fbf\u5224\u65ad\u961f\u5934\u51fa\u961f)\n        if (q[hh] &lt; i - k + 1) hh++;  // \u961f\u5934\u51fa\u961f(\u961f\u5934\u5143\u7d20\u6ed1\u51fa\u7a97\u53e3)\n        if (i &gt;= k - 1) printf(\"%d \", a[q[hh]]);  // \u4f7f\u7528\u6700\u503c\n    }\n    puts(\"\");\n\n    // \u7ef4\u62a4\u7a97\u53e3\u6700\u5927\u503c\n    hh = 0, tt = -1;  // \u6e05\u7a7a\u961f\u5217\n    for (int i = 0; i &lt; n; i++) {  // \u679a\u4e3e\u961f\u5217\n        while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt--;  // \u961f\u5c3e\u51fa\u961f(\u961f\u5217\u4e0d\u7a7a\u4e14\u65b0\u5143\u7d20\u66f4\u4f18)\n        q[++tt] = i;  // \u961f\u5c3e\u5165\u961f(\u5b58\u50a8\u4e0b\u6807\uff0c\u65b9\u4fbf\u5224\u65ad\u961f\u5934\u51fa\u961f)\n        if (q[hh] &lt; i - k + 1) hh++;  // \u961f\u5934\u51fa\u961f(\u961f\u5934\u5143\u7d20\u6ed1\u51fa\u7a97\u53e3)\n        if (i &gt;= k - 1) printf(\"%d \", a[q[hh]]);  // \u4f7f\u7528\u6700\u503c\n    }\n    puts(\"\");\n\n    return 0;\n}\n</code></pre>"},{"location":"zh/Data_Structures/03_KMP/","title":"KMP\u5339\u914d\u7b97\u6cd5","text":""},{"location":"zh/Data_Structures/03_KMP/#_1","title":"\u6734\u7d20\u89e3\u6cd5","text":"<p>\u66b4\u529b\u7b97\u6cd5\u600e\u4e48\u505a\uff1f\u5982\u4f55\u53bb\u4f18\u5316\uff1f</p> <p>\u6734\u7d20\u7b97\u6cd5\uff1a</p> <pre><code>int s[N], p[M];\nfor (int i = 1; i &lt;= n; i++) {\n    bool flag = true;\n    for (int j = 1; j &lt;= m; j++) {\n        if (s[i + j - 1] != p[j]) {\n            flag = false;\n            break;\n        }\n    }\n}\n</code></pre> <p>\u6734\u7d20\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(mn)\\)\u3002</p>"},{"location":"zh/Data_Structures/03_KMP/#kmp_1","title":"KMP\u7b97\u6cd5","text":"<p>\u8fd9\u4e2a\u89c6\u9891\u8bb2\u89e3\u5f97\u8f83\u597d\u3002</p> <p><code>next[i] = j</code>\u8868\u793a\u4ee5<code>i</code>\u4e3a\u7ec8\u70b9\u7684\u540e\u7f00\u548c\u4ece<code>1</code>\u5f00\u59cb\u7684\u524d\u7f00\u76f8\u7b49(<code>p[1, j]=p[i - j + 1, i]</code>)\uff0c\u4e14\u540e\u7f00\u6700\u957f\u3002</p> <p><code>next[i]</code>\u8868\u793a\u6240\u6709<code>p[1 : i]</code>\u7684\u76f8\u7b49\u7684 \u975e\u5e73\u51e1 \u7684\u524d\u7f00\u4ee5\u53ca\u540e\u7f00\u4e2d\u7684 \u957f\u5ea6 \u7684\u6700\u5927\u503c\u3002</p> <p>\u4f8b\u9898\uff1aKMP\u5b57\u7b26\u4e32</p> <p>KMP\u6a21\u677f\uff1a</p> <pre><code>//s[]\u662f\u957f\u6587\u672c\uff0cp[]\u662f\u6a21\u5f0f\u4e32\uff0cn\u662fs\u7684\u957f\u5ea6\uff0cm\u662fp\u7684\u957f\u5ea6\n\n//\u6c42\u6a21\u5f0f\u4e32\u7684Next\u6570\u7ec4\nfor (int i = 2, j = 0; i &lt;= m; i++) {\n    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n    if (p[i] == p[j + 1]) j++;\n    ne[i] = j;\n}\n\n//\u5339\u914d\n//s\u4e32\u548cp\u4e32\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\u3002i\u4ece1\u5f00\u59cb\uff0cj\u4ece0\u5f00\u59cb\uff0c\u6bcf\u6b21s[i]\u548cp[j + 1]\u6bd4\u8f83\nfor (int i = 1, j = 0; i &lt;= n; i++) {\n    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j++;\n    if (j == m) {\n        j = ne[j];\n        //\u5339\u914d\u6210\u529f\u540e\u7684\u903b\u8f91\n    }\n}\n</code></pre> <p>C++\u6587\u4ef6\uff1aKMP</p> <p>\u5b8c\u6574\u6a21\u677f\u7a0b\u5e8f\uff1a</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nconst int N = 100010, M = 10010; //N\u4e3a\u6a21\u5f0f\u4e32\u957f\u5ea6\uff0cM\u5339\u914d\u4e32\u957f\u5ea6\n\nint n, m;\nint ne[M]; //next[]\u6570\u7ec4\uff0c\u907f\u514d\u548c\u5934\u6587\u4ef6next\u51b2\u7a81\nchar s[N], p[M];  //s\u4e3a\u6a21\u5f0f\u4e32\uff0c p\u4e3a\u5339\u914d\u4e32\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; s + 1 &gt;&gt; m &gt;&gt; p + 1;  //\u4e0b\u6807\u4ece1\u5f00\u59cb\n\n    //\u6c42next[]\u6570\u7ec4\n    for(int i = 2, j = 0; i &lt;= n; i++) {\n        while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n        if (p[i] == p[j + 1]) j++;\n        ne[i] = j;\n    }\n\n    //\u5339\u914d\u64cd\u4f5c\n    for(int i = 1, j = 0; i &lt;= m; i++) {\n        while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n        if (s[i] == p[j + 1]) j++;\n        if (j == m) { //\u6ee1\u8db3\u5339\u914d\u6761\u4ef6\uff0c\u6253\u5370\u5f00\u5934\u4e0b\u6807, \u4ece0\u5f00\u59cb\n            //\u5339\u914d\u5b8c\u6210\u540e\u7684\u5177\u4f53\u64cd\u4f5c\n            //\u5982\uff1a\u8f93\u51fa\u4ee50\u5f00\u59cb\u7684\u5339\u914d\u5b50\u4e32\u7684\u9996\u5b57\u6bcd\u4e0b\u6807\n            printf(\"%d \", i - m); // (\u82e5\u4ece1\u5f00\u59cb\uff0c\u52a01)\n            j = ne[j];            //\u518d\u6b21\u7ee7\u7eed\u5339\u914d\n        }\n    }\n    return 0;\n}\n</code></pre> <p>KMP\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n+m)\\)\u3002</p>"},{"location":"zh/Data_Structures/04_Trie/","title":"Trie\u6811","text":"<p>Trie\u6811\u662f\u7528\u6765\u9ad8\u6548\u5730\u5b58\u50a8\u548c\u67e5\u627e\u5b57\u7b26\u4e32\u96c6\u5408\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4e5f\u53eb\u5b57\u5178\u6811\u3002</p> <p>\u8fd9\u4e2a\u89c6\u9891\u8bb2\u89e3\u5f97\u8f83\u597d\u3002</p> <p>\u53ef\u4ee5\u4e0d\u7ba1\u662f\u94fe\u8868\uff0cTrie\u6811\u8fd8\u662f\u5806\uff0c\u4ed6\u4eec\u7684\u57fa\u672c\u5355\u5143\u90fd\u662f\u4e00\u4e2a\u4e2a\u8282\u70b9\u8fde\u63a5\u6784\u6210\u7684\uff0c\u53ef\u4ee5\u6210\u4e3a\u201c\u94fe\u201d\u5f0f\u7ed3\u6784\u3002\u8fd9\u4e2a\u8282\u70b9\u5305\u542b\u4e24\u4e2a\u57fa\u672c\u7684\u5c5e\u6027\uff1a\u672c\u8eab\u7684\u503c\u548c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488\u3002\u6309\u9053\u7406\uff0c\u5e94\u8be5\u6309\u7167\u7ed3\u6784\u4f53\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u7684\uff0c\u4f46\u662f\u505a\u7b97\u6cd5\u9898\u4e00\u822c\u7528\u6570\u7ec4\u6a21\u62df\uff0c\u4e3b\u8981\u662f\u56e0\u4e3a\u6bd4\u8f83\u5feb\u3002\u539f\u6765\u8fd9\u4e24\u4e2a\u5c5e\u6027\u90fd\u662f\u4ee5\u7ed3\u6784\u4f53\u7684\u65b9\u5f0f\u8054\u7cfb\u5728\u4e00\u8d77\u7684\uff0c\u73b0\u5728\u5982\u679c\u7528\u6570\u7ec4\u6a21\u62df\uff0c\u5982\u4f55\u624d\u80fd\u628a\u8fd9\u4e24\u4e2a\u5c5e\u6027\u8054\u7cfb\u8d77\u6765\u4ece\u800c\u533a\u5206\u5404\u4e2a\u8282\u70b9\u5462\uff1f\u8fd9\u5c31\u9700\u8981\u7528\u5230<code>idx</code>\u4e86\u3002<code>idx</code>\u7684\u64cd\u4f5c\u603b\u662f<code>idx++</code>\uff0c\u8fd9\u5c31\u4fdd\u8bc1\u4e86\u4e0d\u540c\u7684<code>idx</code>\u503c\u5bf9\u5e94\u4e0d\u540c\u7684\u8282\u70b9\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5229\u7528<code>idx</code>\u628a\u7ed3\u6784\u4f53\u5185\u4e24\u4e2a\u5c5e\u6027\u8054\u7cfb\u5728\u4e00\u8d77\u4e86\u3002\u56e0\u6b64\uff0c<code>idx</code>\u53ef\u4ee5\u7406\u89e3\u4e3a\u8282\u70b9\u3002(\u53c2\u8003\u81ea\u6b64\u6587\u7ae0)</p> <p><code>idx</code>\u76f8\u5f53\u4e8e\u4e00\u4e2a\u5206\u914d\u5668\uff0c\u5982\u679c\u9700\u8981\u52a0\u5165\u65b0\u7684\u8282\u70b9\u5c31\u7528<code>++idx</code>\u5206\u914d\u51fa\u4e00\u4e2a\u4e0b\u6807\u3002</p> <p>Trie\u6811\u4e2d\u6709\u4e2a\u4e8c\u7ef4\u6570\u7ec4<code>son[N][26]</code>\uff0c\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u513f\u5b50\uff0c\u5982\u679c\u6ca1\u6709\u7684\u8bdd\uff0c\u53ef\u4ee5\u7b49\u4e8e<code>++idx</code>\u3002Trie\u6811\u672c\u8d28\u4e0a\u662f\u4e00\u9897\u591a\u53c9\u6811\uff0c\u5bf9\u4e8e\u5b57\u6bcd\u800c\u8a00\u6700\u591a\u670926\u4e2a\u5b50\u8282\u70b9\u3002\u6240\u4ee5\u8fd9\u4e2a\u6570\u7ec4\u5305\u542b\u4e86\u4e24\u6761\u4fe1\u606f\u3002\u6bd4\u5982\uff1a<code>son[1][0]=2</code>\u8868\u793a1\u7ed3\u70b9\u7684\u4e00\u4e2a\u503c\u4e3a<code>a</code>\u7684\u5b50\u7ed3\u70b9\u4e3a\u8282\u70b92\uff1b\u5982\u679c<code>son[1][0] = 0</code>\uff0c\u5219\u610f\u5473\u7740\u6ca1\u6709\u503c\u4e3a<code>a</code>\u7684\u5b50\u8282\u70b9\u3002\u8fd9\u91cc\u7684<code>son[N][26]</code>\u76f8\u5f53\u4e8e\u94fe\u8868\u4e2d\u7684<code>ne[N]</code>\u3002\u8ba1\u6570\u6570\u7ec4<code>cnt[p]</code>\u5b58\u50a8\u4ee5\u8282\u70b9<code>p</code>\u7ed3\u5c3e\u7684\u5355\u8bcd\u7684\u63d2\u5165\u6b21\u6570\u3002</p> <p></p> <p>\u4f8b\u9898\uff1aTrie\u5b57\u7b26\u4e32\u7edf\u8ba1</p> <pre><code>//son[\u7236\u4eb2\u7684\u4f4d\u7f6e][\u513f\u5b50\u7684\u540d\u5b57]=\u513f\u5b50\u7684\u4f4d\u7f6e\nint son[N][26], cnt[N], idx;\n// 0\u53f7\u70b9\u65e2\u662f\u6839\u8282\u70b9\uff0c\u53c8\u662f\u7a7a\u8282\u70b9\n// son[][]\u5b58\u50a8\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u8282\u70b9\n// cnt[]\u5b58\u50a8\u4ee5\u6bcf\u4e2a\u8282\u70b9\u7ed3\u5c3e\u7684\u5355\u8bcd\u6570\u91cf\n\n// \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\nvoid insert(char *str) {\n    int p = 0;\n    for (int i = 0; str[i]; i++) {\n        int u = str[i] - 'a';\n        if (!son[p][u]) son[p][u] = ++idx;\n        p = son[p][u];\n    }\n    cnt[p]++;\n}\n\n// \u67e5\u8be2\u5b57\u7b26\u4e32\u51fa\u73b0\u7684\u6b21\u6570\nint query(char *str) {\n    int p = 0;\n    for (int i = 0; str[i]; i++) {\n        int u = str[i] - 'a';\n        if (!son[p][u]) return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u6700\u5927\u5f02\u6216\u5bf9</p> <p>\u4e00\u4e2a\u6574\u6570\uff0c\u53ef\u4ee5\u8f6c\u5316\u6210\u4e3a\u4e00\u4e2a32\u4f4d\u7684\u4e8c\u8fdb\u5236\u6570\uff0c\u4ece\u800c\u4e5f\u5c31\u53ef\u4ee5\u53d8\u6210\u957f\u5ea6\u4e3a32\u4f4d\u7684\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6bcf\u4e00\u6b21\u68c0\u7d22\u7684\u65f6\u5019,\u6211\u4eec\u90fd\u8d70\u4e0e\u5f53\u524d \\(A_i\\) \u8fd9\u4e00\u4f4d\u76f8\u53cd\u7684\u4f4d\u7f6e\u8d70\uff0c\u4e5f\u5c31\u662f\u8ba9<code>XOR</code>\u503c\u6700\u5927\uff0c\u5982\u679c\u8bf4\u6ca1\u6709\u8def\u53ef\u4ee5\u8d70\u7684\u8bdd\uff0c\u90a3\u4e48\u5c31\u8d70\u76f8\u540c\u7684\u8def\u3002\u56e0\u4e3a\u8fd9\u6837\u5c31\u53ef\u4ee5\u904d\u5386\u6240\u6709\u7684\u60c5\u51b5\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u6570\u5b57\u9009\u62e9\u7684\u90fd\u662f\u524d\u9762\u548c\u5b83\u5f02\u6216\u4ea7\u751f\u7684\u503c\u6700\u5927\u7684\u6570\u5b57\uff0c\u5373\u4f7f\u5f53\u524d\u6570\u5b57\u662f\u548c\u540e\u9762\u7684\u67d0\u4e2a\u6570\u5b57\u5f02\u6216\u503c\u6700\u5927\uff0c\u904d\u5386\u540e\u9762\u90a3\u4e2a\u6570\u5b57\u7684\u65f6\u5019\u5c31\u4f1a\u5c06\u8fd9\u4e2a\u6570\u5b57\u9009\u62e9\u51fa\u6765\u3002</p>"},{"location":"zh/Data_Structures/05_Disjoint_Set/","title":"\u5e76\u67e5\u96c6","text":"<p>\u7279\u70b9\uff1a\u601d\u7ef4\u6027\u8f83\u5f3a\uff0c\u4ee3\u7801\u8f83\u77ed\uff0c\u5e38\u51fa\u73b0\u4e8e\u9762\u8bd5\u3002</p>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#_2","title":"\u5b9a\u4e49","text":"<p>\u5e76\u67e5\u96c6\u7684\u64cd\u4f5c\uff1a</p> <ul> <li>\u5c06\u4e24\u4e2a\u96c6\u5408\u5408\u5e76(\u5e76)\uff1b</li> <li>\u8be2\u95ee\u4e24\u4e2a\u5143\u7d20\u662f\u5426\u5728\u4e00\u4e2a\u96c6\u5408\u5f53\u4e2d(\u67e5)\u3002</li> </ul> <p>\u5e76\u67e5\u96c6\u7ef4\u62a4\u7684\u662f\u4e00\u5806\u96c6\u5408(\u96c6)\u3002</p>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#_3","title":"\u7b97\u6cd5","text":""},{"location":"zh/Data_Structures/05_Disjoint_Set/#_4","title":"\u7406\u8bba\u8003\u5bdf","text":"<p>\u539f\u59cb\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u6570\u7ec4\uff1a\u7b2c\u4e00\u4e2a\u6570\u7ec4\u4fdd\u5b58\u6240\u6709\u5143\u7d20\uff1b\u7b2c\u4e8c\u4e2a\u6570\u7ec4\u4f7f\u7528\u6570\u7ec4\u7684\u4e0b\u6807\u6765\u4ee3\u8868\u6570\u7ec4\u4e00\u4e2d\u5143\u7d20\uff0c\u5bf9\u5e94\u4f4d\u7f6e\u4e0a\u5b58\u653e\u7684\u503c\u8868\u793a\u5143\u7d20\u6240\u5c5e\u7684\u96c6\u5408\u3002\u4f46\u7b2c\u4e8c\u4e2a\u6570\u7ec4\u4e2d\u4fdd\u5b58\u7684\u662f\u7b2c\u4e00\u4e2a\u6570\u7ec4\u4e2d\u5404\u4e2a\u5143\u7d20\u6240\u5c5e\u96c6\u5408\uff0c\u6240\u4ee5\u5408\u5e76\u96c6\u5408\u7684\u65f6\u5019\uff0c\u7b2c\u4e8c\u4e2a\u6570\u7ec4\u4e2d\u9700\u8981\u4fee\u6539\u5143\u7d20\u6bd4\u8f83\u591a\u3002</p> <p>\u4fee\u6b63\uff1a\u53ef\u4ee5\u4e3a\u6bcf\u4e2a\u5143\u7d20\u9009\u51fa\u4e00\u4e2a\u4ee3\u8868\u5b83\u7684\u5143\u7d20\uff0c\u6570\u7ec4\u4e8c\u4e2d\u5b58\u653e\u4ee3\u8868\u5143\u7d20\u3002\u7b2c\u4e00\u4e2a\u6570\u7ec4\u4fdd\u5b58\u4e86\u6240\u6709\u5143\u7d20\uff0c\u7b2c\u4e8c\u4e2a\u6570\u7ec4\u4fdd\u5b58\u4e86\u80fd\u4ee3\u8868\u8be5\u5143\u7d20\u7684\u5143\u7d20\u3002\u8fd9\u4e2a\u65f6\u5019\uff0c\u5982\u679c\u8981\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff0c\u53ea\u9700\u8981\u4fee\u6539\u4ee3\u8868\u5143\u7d20\u5373\u53ef\u3002</p> <p>\u6b65\u9aa4\uff1a</p> <ul> <li>\u7528\u4e00\u4e2a\u6570\u7ec4\u4fdd\u5b58\u5bf9\u5e94\u4f4d\u7f6e\u5143\u7d20\u6240\u5c5e\u96c6\u5408\u7684\u4ee3\u8868\u5143\u7d20\uff1b</li> <li>\\(A,B\\) \u4e24\u4e2a\u96c6\u5408\u5408\u5e76\uff1a\u5c06 \\(B\\) \u96c6\u5408\u4ee3\u8868\u5143\u7d20\u7684\u4ee3\u8868\u5143\u7d20\u8bbe\u7f6e\u4e3a \\(A\\) \u96c6\u5408\u7684\u4ee3\u8868\u5143\u7d20\uff1b</li> <li>\u67e5\u627e \\(C\\) \u5143\u7d20\u5c5e\u4e8e\u54ea\u4e2a\u96c6\u5408\uff1a\u627e \\(C\\) \u5143\u7d20\u7684\u4ee3\u8868\u5143\u7d20\uff0c\u5982\u679c\u4e0d\u662f\u4ed6\u81ea\u5df1\uff0c\u5c31\u91cd\u590d\u67e5\u627e\u4ee3\u8868\u5143\u7d20\u7684\u4ee3\u8868\u5143\u7d20\uff0c\u76f4\u5230\u67e5\u627e\u5230\u4e00\u4e2a\u5143\u7d20\u7684\u4ee3\u8868\u5143\u7d20\u662f\u5b83\u81ea\u5df1\uff0c \\(C\\) \u5c31\u5c5e\u4e8e\u6574\u4e2a\u4ee3\u8868\u5143\u7d20\u6240\u4ee3\u8868\u7684\u96c6\u5408\u3002</li> </ul> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u201c\u8fd1\u4e4e\u201d \\(O(1)\\)\u3002</p>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#_5","title":"\u5b9e\u73b0\u7684\u57fa\u672c\u539f\u7406","text":"<p>\u7528\u6811\u7684\u5f62\u5f0f\u7ef4\u62a4\u96c6\u5408\uff0c\u6bcf\u4e2a\u96c6\u5408\u7528\u4e00\u68f5\u6811\u6765\u8868\u793a\uff0c\u6811\u6839\u7684\u7f16\u53f7\u5c31\u662f\u6574\u4e2a\u96c6\u5408\u7684\u7f16\u53f7\uff0c\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u5b83\u7684\u7236\u8282\u70b9\uff0c<code>p[x]</code>\u8868\u793a<code>x</code>\u7684\u7236\u8282\u70b9\u3002</p> <ul> <li>\u95ee\u98981\uff1a\u5982\u4f55\u5224\u65ad\u6811\u6839\uff1f<code>if (p[x] == x)</code>\uff1b</li> <li>\u95ee\u98982\uff1a\u5982\u4f55\u6c42<code>x</code>\u7684\u96c6\u5408\u7f16\u53f7\uff1f<code>while (p[x] != x) x = p[x];</code>\uff1b</li> <li>\u95ee\u98983\uff1a\u5982\u4f55\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff1f\u8bbe \\(p_x\\) \u662f<code>x</code>\u7684\u96c6\u5408\u7f16\u53f7\uff0c \\(p_y\\) \u662f<code>y</code>\u7684\u96c6\u5408\u7f16\u53f7\uff0c\u4ee4<code>p[x] = y</code>\u3002</li> </ul> <p>\u5e76\u67e5\u96c6\u7684\u4f18\u5316\uff1a \u8def\u5f84\u538b\u7f29 (\u5e38\u7528)\uff1b\u6309\u79e9\u5408\u5e76(\u7565)\u3002</p> <p>\u4e0d\u5e26\u8def\u5f84\u538b\u7f29\u7684\u67e5\u627e\u5982\u4e0b\uff1a</p> <pre><code>//\u6839\u8282\u70b9\u5c31\u662f\u96c6\u5408\u7684\u4ee3\u8868\uff0c\u67e5\u627e\u5c31\u662f\u627e\u5230\u5143\u7d20\u6240\u5728\u96c6\u5408\u7684\u6839\nint find(int x) {\n    //\u5982\u679c\u7236\u8282\u70b9\u7b49\u4e8e\u81ea\u5df1\uff0c\u5219\u627e\u5230\u4e86\u5e76\u8fd4\u56de\n    if (p[x] == x) return x;\n    //\u5982\u679c\u8fd8\u6ca1\u627e\u5230\u6839\uff0c\u5219\u7ee7\u7eed\u9012\u5f52\u67e5\u627e\n    return find(p[x]);\n}\n</code></pre> <p>\u5e26\u8def\u5f84\u538b\u7f29\u7684\u67e5\u627e\u548c\u5408\u5e76\u5982\u4e0b(\u80fd\u591f\u52a0\u5feb\u4ee5\u540e\u7684\u67e5\u627e\u8fdb\u7a0b)\uff1a</p> <pre><code>int find(int x) {\n    if (p[x] == x) return x;\n    //\u5728\u8fd4\u56de\u7684\u8def\u4e0a\uff0c\u987a\u5e26\u4fee\u6539\u5404\u8282\u70b9\u7236\u8282\u70b9\u4e3a\u6839\n    return p[x] = find(p[x]);\n}\n\n//\u628a\u4e00\u4e2a\u96c6\u5408\u7684\u6839\u6307\u5411\u53e6\u4e00\u4e2a\u96c6\u5408\u7684\u6839\nvoid union_set(int x, int y) {\n    p[find(x)] = find(y);\n}\n</code></pre> <p></p> <p>\u4e3a\u4e86\u628a\u5c0f\u96c6\u5408\u7684\u6839\u6307\u5411\u5927\u96c6\u5408\u7684\u6839\uff0c\u5408\u5e76\u65f6\u53ef\u4ee5\u91c7\u7528\u542f\u53d1\u5f0f\u5408\u5e76(\u4e5f\u53eb\u6309\u79e9\u5408\u5e76\uff0c\u4e0d\u5e38\u7528)\uff1a</p> <pre><code>//\u8bb0\u5f55\u5e76\u521d\u59cb\u5316\u5b50\u6811\u7684\u5927\u5c0f\u4e3a1\nvector&lt;int&gt; siz(N, 1);\n\nvoid union_set(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (siz[x] &gt; siz[y]) swap(x, y);\n    p[x] = y;\n    siz[y] += siz[x];  //\u5728\u6839\u8282\u70b9\u4e0a\u7ef4\u62a4\u65b0\u8282\u70b9\u7684\u5927\u5c0f\n}\n</code></pre>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#_6","title":"\u6a21\u677f\u4e0e\u4f8b\u9898","text":""},{"location":"zh/Data_Structures/05_Disjoint_Set/#_7","title":"\u6734\u7d20\u5e76\u67e5\u96c6","text":"<p>\u4f8b\u9898\uff1a\u5408\u5e76\u96c6\u5408</p> <p>\u6a21\u677f\uff1a</p> <pre><code>int p[N]; //\u5b58\u50a8\u6bcf\u4e2a\u70b9\u7684\u7956\u5b97\u8282\u70b9\n\n// \u8fd4\u56dex\u7684\u7956\u5b97\u8282\u70b9\nint find(int x) {\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\n// \u521d\u59cb\u5316\uff0c\u5047\u5b9a\u8282\u70b9\u7f16\u53f7\u662f1~n\n// \u521d\u59cb\u5316\u65f6\uff1a\u6bcf\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u96c6\u5408\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u7236\u8282\u70b9\u662f\u5176\u81ea\u5df1\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n\n// \u5408\u5e76a\u548cb\u6240\u5728\u7684\u4e24\u4e2a\u96c6\u5408\np[find(a)] = find(b);\n</code></pre>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#size","title":"\u7ef4\u62a4size\u7684\u5e76\u67e5\u96c6","text":"<p>\u4f8b\u9898\uff1a\u8fde\u901a\u5757\u4e2d\u70b9\u7684\u6570\u91cf</p> <pre><code>int p[N], size[N];\n//p[]\u5b58\u50a8\u6bcf\u4e2a\u70b9\u7684\u7956\u5b97\u8282\u70b9, size[]\u53ea\u6709\u7956\u5b97\u8282\u70b9\u7684\u6709\u610f\u4e49\uff0c\u8868\u793a\u7956\u5b97\u8282\u70b9\u6240\u5728\u96c6\u5408\u4e2d\u7684\u70b9\u7684\u6570\u91cf\n\n// \u8fd4\u56dex\u7684\u7956\u5b97\u8282\u70b9\nint find(int x) {\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\n// \u521d\u59cb\u5316\uff0c\u5047\u5b9a\u8282\u70b9\u7f16\u53f7\u662f1~n\nfor (int i = 1; i &lt;= n; i++) {\n    p[i] = i;\n    size[i] = 1;\n}\n\n// \u5408\u5e76a\u548cb\u6240\u5728\u7684\u4e24\u4e2a\u96c6\u5408\nsize[find(b)] += size[find(a)];\np[find(a)] = find(b);\n</code></pre>"},{"location":"zh/Data_Structures/05_Disjoint_Set/#_8","title":"\u7ef4\u62a4\u5230\u7956\u5b97\u8282\u70b9\u8ddd\u79bb\u7684\u5e76\u67e5\u96c6","text":"<p>\u4f8b\u9898\uff1a\u98df\u7269\u94fe</p> <p>\u601d\u8def\u662f\u7528\u201c\u8ddd\u79bb\u201d\u6765\u63cf\u8ff0\u5173\u7cfb\u3001\u5224\u65ad\u5173\u7cfb\uff0c\u6240\u6709\u7684\u8ddd\u79bb\u90fd\u4ee5\u6839\u8282\u70b9\u4e3a\u57fa\u51c6\uff0c\u6309\u7167<code>mod</code>\u7c7b\u522b\u65703\u5206\u4e3a\u4e09\u7c7b\u3002</p> <ul> <li>\u201c\u8ddd\u79bb\u201d\uff1a<code>x</code>\u5403<code>y</code>\u8868\u793a<code>y</code>\u5230<code>x</code>\u7684\u8ddd\u79bb\u4e3a1\uff0c<code>y</code>\u662f\u7b2c<code>0</code>\u4ee3\uff0c\u5403<code>y</code>\u7684<code>x</code>\u662f\u7b2c1\u4ee3\uff0c\u5403<code>x</code>\u7684\u662f\u7b2c2\u4ee3\uff0c\u6839\u8282\u70b9\u662f\u7b2c0\u4ee3\u7b49</li> <li>\u4e09\u79cd\u5173\u7cfb\uff1a\u7528\u70b9\u5230\u6839\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u8868\u793a\u5176\u4f59\u6839\u8282\u70b9\u4e4b\u95f4\u7684\u5173\u7cfb</li> <li>\u6a213\u4f591\uff1a\u53ef\u4ee5\u5403\u6839\u8282\u70b9</li> <li>\u6a213\u4f592\uff1a\u53ef\u4ee5\u88ab\u6839\u8282\u70b9\u5403</li> <li>\u6a213\u4f590\uff1a\u548c\u6839\u8282\u70b9\u540c\u7c7b</li> </ul> <p>\u8fd9\u6837\u5c31\u628a\u96c6\u5408\u4e2d\u6240\u6709\u7684\u70b9\u5212\u5206\u4e3a\u4e0a\u8ff0\u4e09\u7c7b\u3002</p> <p><code>d[i]</code>\u7406\u89e3\u662f\u7b2c<code>i</code>\u4e2a\u8282\u70b9\u5230\u5176\u7236\u8282\u70b9\u7684\u8ddd\u79bb\uff0c<code>find()</code>\u51fd\u6570\u8fdb\u884c\u4e86\u8def\u5f84\u538b\u7f29\uff0c\u5f53\u67e5\u8be2\u67d0\u4e2a\u8282\u70b9<code>i</code>\u65f6\uff0c\u5982\u679c<code>i</code>\u7684\u7236\u8282\u70b9\u4e0d\u4e3a\u6839\u8282\u70b9\u7684\u8bdd\uff0c\u5c31\u4f1a\u8fdb\u884c\u9012\u5f52\u8c03\u7528\uff0c\u5c06<code>i</code>\u8282\u70b9\u6cbf\u9014\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u5747\u6307\u5411\u7236\u8282\u70b9\uff0c\u6b64\u65f6\u7684<code>d[i]</code>\u5b58\u653e\u7684\u662f<code>i</code>\u5230\u7236\u8282\u70b9\uff0c\u4e5f\u5c31\u662f\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u3002\u4e0d\u8def\u5f84\u538b\u7f29\u53d6\u5f97\u7684\u662f\u5230\u7236\u8282\u70b9\u7684\u8ddd\u79bb\uff0c\u8def\u5f84\u538b\u7f29\u540e\u65e2\u662f\u5230\u6839\u7684\u8ddd\u79bb\uff0c\u4e5f\u662f\u5230\u7236\u8282\u70b9\u7684\u8ddd\u79bb\uff0c\u56e0\u4e3a\u538b\u7f29\u540e\u5c06\u7236\u4eb2\u6307\u5411\u6839\u4e86\uff0c\u7236\u4eb2\u548c\u6839\u662f\u4e00\u4e2a\u4e1c\u897f\u3002\u800c\u7531\u4e8e\u6bcf\u6b21\u53d6<code>d[x]</code>\u90fd\u5fc5\u7136\u7ecf\u8fc7\u8def\u5f84\u538b\u7f29\uff0c\u56e0\u6b64<code>d[x]</code>\u5728\u7ed3\u679c\u4e0a\u65e2\u662f\u5230\u6839\u7684\u8ddd\u79bb\uff0c\u4e5f\u662f\u5230\u7236\u4eb2\u7684\u8ddd\u79bb\u3002\u4f46\u662f\u5728\u8fc7\u7a0b\u4e2d\u5b83\u4ec5\u4ee3\u8868\u5230\u7236\u4eb2\u7684\u8ddd\u79bb\uff0c\u56e0\u4e3a\u6ca1\u66f4\u65b0\u7684\u65f6\u5019\u5b83\u7684\u7236\u4eb2\u5e76\u4e0d\u662f\u6839\u3002[\u603b\u7ed3\uff1a<code>d[x]</code>\u59cb\u7ec8\u4ee3\u8868\u5230\u7236\u8282\u70b9\u7684\u8ddd\u79bb\uff0c\u53ea\u4e0d\u8fc7\u5728<code>find</code>\u4e4b\u540e<code>x</code>\u7684\u7236\u8282\u70b9\u76f4\u63a5\u53d8\u6210\u4e86\u6839\u8282\u70b9(\u7956\u5b97)\uff0c\u6240\u4ee5\u903b\u8f91\u4e0a\u6210\u4e86\u5230\u7956\u5b97\u7684\u8ddd\u79bb]</p> <pre><code>int p[N], d[N];\n//p[]\u5b58\u50a8\u6bcf\u4e2a\u70b9\u7684\u7956\u5b97\u8282\u70b9, d[x]\u5b58\u50a8x\u5230p[x]\u7684\u8ddd\u79bb\n\n// \u8fd4\u56dex\u7684\u7956\u5b97\u8282\u70b9\nint find(int x) {\n    if (p[x] != x) {\n        //\u5148\u628a\u7236\u8282\u70b9\u53ca\u4ee5\u4e0a\u538b\u7f29\u5230\u6839\u8282\u70b9\uff0c\u8fd9\u65f6\u7236\u8282\u70b9\u662f\u6839\u8282\u70b9\u7684\u4e00\u7ea7\u5b50\u8282\u70b9\uff0cx\u662f\u6839\u8282\u70b9\u7684\u4e8c\u7ea7\u5b50\u8282\u70b9\u3002\u8fc7\u7a0b\u4e2dd[p[x]]\u88ab\u66f4\u65b0\u4e3a\u7236\u8282\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\n        int u = find(p[x]);\n        //\u5148\u66f4\u65b0\u8fb9\u6743\uff0c\u518d\u628ax\u4e5f\u538b\u5230\u6839\u8282\u70b9\u3002\u5426\u5219x\u7684\u7236\u8282\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bbd[p[x]]\u6ca1\u52a0\u4e0a\u5c31\u4e22\u5931\u4e86\n        d[x] += d[p[x]];\n        p[x] = u;\n    }\n    return p[x];\n}\n\n// \u521d\u59cb\u5316\uff0c\u5047\u5b9a\u8282\u70b9\u7f16\u53f7\u662f1~n\nfor (int i = 1; i &lt;= n; i++) {\n    p[i] = i;\n    d[i] = 0;\n}\n\n// \u5408\u5e76a\u548cb\u6240\u5728\u7684\u4e24\u4e2a\u96c6\u5408\np[find(a)] = find(b);\nd[find(a)] = distance; // \u6839\u636e\u5177\u4f53\u95ee\u9898\uff0c\u521d\u59cb\u5316find(a)\u7684\u504f\u79fb\u91cf\n</code></pre>"},{"location":"zh/Data_Structures/06_Heap/","title":"\u5806","text":"<p>\u5982\u4f55\u624b\u5199\u5806\uff1f</p>"},{"location":"zh/Data_Structures/06_Heap/#_2","title":"\u5806\u7684\u4ecb\u7ecd","text":"<p>\u5806\u662f\u4e00\u4e2a\u5b8c\u5168\u4e8c\u53c9\u6811\uff1a\u9664\u4e86\u6700\u540e\u4e00\u5c42\u8282\u70b9\u5916\uff0c\u4e0a\u9762\u6240\u6709\u5c42\u8282\u70b9\u90fd\u662f\u6ee1\u7684\uff0c\u6700\u540e\u4e00\u5c42\u8282\u70b9\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u6392\u5e03\u3002</p> <p>\u5173\u4e8e\u4e8c\u53c9\u6811\u7684\u6982\u5ff5\u8be6\u89c1\u6b64\u6587 (\u539f\u59cb\u5185\u5bb9\u5b58\u6863\u4e8e\u6b64\u9875\u9762)\u3002</p> <p>\u5806\u7684\u7c7b\u578b\uff1a</p> <ul> <li>\u5c0f\u6839\u5806(\u8fd9\u91cc\u8ba8\u8bba)\uff1a\u6bcf\u4e2a\u70b9\u7684\u503c\u90fd\u5c0f\u4e8e\u7b49\u4e8e\u5de6\u53f3\u513f\u5b50\u7684\u503c\uff0c\u5219\u6839\u8282\u70b9\u662f\u6700\u5c0f\u503c\u6240\u5728\u7684\u70b9\uff1b</li> <li>\u5927\u6839\u5806\uff1a\u7236\u8282\u70b9\u7684\u503c\u5927\u4e8e\u7b49\u4e8e\u5176\u5b50\u8282\u70b9\u7684\u503c\u3002</li> </ul> <p>\u5806\u7684\u5b58\u50a8\u65b9\u5f0f\uff1a\u7528 \u4e00\u7ef4\u6570\u7ec4 \u5b58\u50a8\u3002<code>1</code>\u53f7\u70b9\u662f\u6839\u8282\u70b9\uff0c\u91c7\u7528\u5de6\u53f3\u5b69\u5b50\u7f16\u53f7\u6cd5\uff0c\u6bcf\u4e2a\u4e0b\u6807\u4e3a<code>x</code>\u7684\u8282\u70b9\u7684\u5de6\u513f\u5b50(\u82e5\u5b58\u5728)\u4e0b\u6807\u4e3a<code>2 * x</code>\uff0c\u53f3\u513f\u5b50(\u82e5\u5b58\u5728)\u4e0b\u6807\u4e3a<code>2 * x + 1</code>\uff1b\u4e0b\u6807\u4e3a<code>i</code>\u8282\u70b9\u7684\u7236\u8282\u70b9(\u82e5\u5b58\u5728)\u4e0b\u6807\u662f<code>i / 2</code>\u3002</p>"},{"location":"zh/Data_Structures/06_Heap/#_3","title":"\u5806\u7684\u57fa\u672c\u64cd\u4f5c","text":"<p>\u57fa\u672c\u51fd\u6570\uff1a</p> <ul> <li><code>down(x)</code>\uff1a\u628a\u4e00\u4e2a\u8282\u70b9 \u5f80\u4e0b\u8c03\u6574\uff1b</li> <li><code>up(x)</code>\uff1a\u628a\u4e00\u4e2a\u8282\u70b9 \u5f80\u4e0a\u8c03\u6574\u3002</li> </ul> <p>\u5c0f\u6839\u5806\u7684\u64cd\u4f5c(\u4e0b\u6807\u4ece<code>1</code>\u5f00\u59cb)\uff1a</p> <ul> <li>\u63d2\u5165\u4e00\u4e2a\u6570\uff1a\u5728\u6574\u4e2a\u5806\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u63d2\u5165<code>x</code>\uff0c\u4e5f\u5c31\u662f\u9700\u8981\u5148\u628a\u65b0\u5143\u7d20\u4ece\u5806\u5c3e\u63d2\u5165\uff0c\u518d\u9010\u5c42\u4e0a\u6d6e\u5230\u5408\u9002\u4f4d\u7f6e (<code>heap[++size] = x; up(size);</code>)\uff1b</li> <li>\u6c42\u96c6\u5408\u5f53\u4e2d\u7684\u6700\u5c0f\u503c\uff1a\u5bf9\u4e8e\u5c0f\u6839\u5806\u5c31\u662f\u53d6\u51fa\u6839\u8282\u70b9<code>heap[1]</code>\u7684\u503c\uff1b</li> <li>\u5220\u9664\u6700\u5c0f\u503c\uff1a(\u5220\u9664\u5806\u7684\u9876\u70b9)\u56e0\u4e3a\u8fd9\u91cc\u5220\u9664\u4f4d\u4e8e\u5c3e\u90e8\u7684\u8282\u70b9\u8f83\u4e3a\u7b80\u5355\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u6574\u4e2a\u5806\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u8986\u76d6\u6389\u5806\u9876\u5143\u7d20\uff0c\u4e5f\u5c31\u662f\u5148\u628a\u5c3e\u5143\u7d20\u79fb\u5230\u6839\u4e0a\uff0c\u518d\u9010\u5c42\u4e0b\u6c89\u5230\u5408\u9002\u4f4d\u7f6e (<code>heap[1] = heap[size]; size--; down(1);</code>)\uff1b</li> <li>(STL\u7684\u5806\u65e0\u5185\u7f6e\u5b9e\u73b0) \u5220\u9664\u4efb\u610f\u4e00\u4e2a\u5143\u7d20\uff1a\u5220\u9664\u7b2c<code>k</code>\u4e2a\u70b9(<code>heap[k] = heap[size]; size--; down(1); down(k); up(k);</code>)\uff0c\u6ce8\u610f\u8fd9\u91cc<code>down</code>\u548c<code>up</code>\u53ea\u4f1a\u6267\u884c\u4e00\u4e2a\uff1b</li> <li>(STL\u7684\u5806\u65e0\u5185\u7f6e\u5b9e\u73b0) \u4fee\u6539\u4efb\u610f\u4e00\u4e2a\u5143\u7d20\uff1a\u4fee\u6539\u7b2c<code>k</code>\u4e2a\u70b9(<code>heap[k] = x; down(k); up(k);</code>)\u3002</li> </ul>"},{"location":"zh/Data_Structures/06_Heap/#_4","title":"\u6a21\u677f\u4e0e\u4f8b\u9898","text":""},{"location":"zh/Data_Structures/06_Heap/#_5","title":"\u5806\u7684\u63d2\u5165","text":"<p>\u4e00\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)\u3002</p> <p>\u6a21\u677f\uff1a</p> <pre><code>int h[1000010], size_h;\n\nvoid up(int u) {  //\u4e0a\u6d6e\n    if (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) {\n        swap(h[u], h[u / 2]);\n        up(u / 2);\n    }\n}\n\nvoid push(int x) {  //\u538b\u5165\n    h[++size_h] = x;\n    up(size_h);\n}\n</code></pre>"},{"location":"zh/Data_Structures/06_Heap/#_6","title":"\u5806\u7684\u5220\u9664","text":"<p>\u4e00\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)\u3002</p> <p>\u6a21\u677f\uff1a</p> <pre><code>void down(int u) {  //\u4e0b\u6c89\n    int v = u;\n    if (u * 2 &lt;= size_h &amp;&amp; h[u * 2] &lt; h[v]) v = u * 2;\n    if (u * 2 + 1 &lt;= size_h &amp;&amp; h[u * 2 + 1] &lt; h[v]) v = 2 * u + 1;\n    if (u != v) {\n        swap(h[u], h[v]);\n        down(v);\n    }\n}\n\nvoid pop() {  //\u5220\u9664\n    h[1] = h[size_h--];\n    down(1);\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u5806\u6392\u5e8f</p> <p>\u5806\u6392\u5e8f\u548c\u5feb\u901f\u6392\u5e8f\u90fd\u662f\u4e0d\u7a33\u5b9a\u7684\u6392\u5e8f\uff0c\u800c\u5f52\u5e76\u6392\u5e8f\u662f\u7a33\u5b9a\u7684\u3002</p>"},{"location":"zh/Data_Structures/06_Heap/#_7","title":"\u7efc\u5408","text":""},{"location":"zh/Data_Structures/06_Heap/#stl","title":"\u5806\u7684\u63d2\u5165\u4e0e\u5220\u9664\u7684STL\u4ee3\u7801","text":"<p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n \\log n)\\)\u3002</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);  //\u64cd\u4f5c\u6b21\u6570\n    while (n--) {\n        int op, x;\n        scanf(\"%d\", &amp;op);\n        if (op == 1) scanf(\"%d\", &amp;x), q.push(x);\n        else if (op == 2) printf(\"%d\\n\", q.top());\n        else q.pop();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"zh/Data_Structures/06_Heap/#_8","title":"\u6a21\u62df\u5806","text":"<p>\u4f8b\u9898\uff1a\u6a21\u62df\u5806</p> <p>\u5806\u4e2d\u7684\u6bcf\u6b21\u63d2\u5165\u90fd\u662f\u5728\u5806\u5c3e\uff0c\u4f46\u662f\u5806\u4e2d\u7ecf\u5e38\u6709<code>up</code>\u548c<code>down</code>\u64cd\u4f5c\uff0c\u6240\u4ee5\u8282\u70b9\u4e0e\u8282\u70b9\u7684\u5173\u7cfb\u5e76\u4e0d\u662f\u7528\u7c7b\u4f3cTrie\u7684<code>ne[idx][2]</code>\u5c31\u53ef\u4ee5\u5f88\u597d\u5730\u7ef4\u62a4\u7684\u3002\u4f46\u662f\u597d\u5728\u5806\u662f\u4e2a\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u5b50\u7236\u8282\u70b9\u7684\u5173\u7cfb\u53ef\u4ee5\u901a\u8fc7\u4e0b\u6807\u6765\u8054\u7cfb(\u5de6\u513f\u5b50<code>2*n</code>\uff0c\u53f3\u513f\u5b50<code>2*n + 1</code>)\u3002\u5c31\u6570\u7ec4\u6a21\u62df\u6765\u8bf4\uff0c\u77e5\u9053\u6570\u7ec4\u7684\u4e0b\u6807\u5c31\u77e5\u9053\u7ed3\u70b9\u5728\u5806\u4e2d\u7684\u4f4d\u7f6e\u3002\u6240\u4ee5\u6838\u5fc3\u5c31\u5728\u4e8e\u5373\u4f7f\u6709<code>down</code>\u548c<code>up</code>\u64cd\u4f5c\u4e5f\u80fd\u7ef4\u62a4\u5806\u6570\u7ec4\u7684\u4e0b\u6807<code>k</code>\u548c\u8282\u70b9<code>idx</code>\u7684\u6620\u5c04\u5173\u7cfb\u3002\u6bd4\u5982\uff1a<code>h[k] = x</code>\uff0c<code>h</code>\u6570\u7ec4\u5b58\u7684\u662f\u8282\u70b9\u7684\u503c\uff0c\u6309\u7406\u6765\u8bf4\u5e94\u8be5\u7528<code>h[idx]</code>\u6765\u5b58\uff0c\u4f46\u662f\u8282\u70b9\u4f4d\u7f6e\u603b\u662f\u5728\u53d8\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u7ef4\u62a4<code>k</code>\u548c<code>idx</code>\u7684\u6620\u5c04\u5173\u7cfb\uff0c\u6bd4\u5982\u8bf4\u7528<code>ph</code>\u6570\u7ec4\u6765\u8868\u793a<code>ph[idx] = k</code>\uff0c\u90a3\u4e48\u7ed3\u70b9\u503c\u4e3a<code>h[ph[idx]]</code>\uff0c\u513f\u5b50\u4e0b\u6807\u4e3a<code>ph[idx] * 2</code>\u548c<code>ph[idx] * 2 + 1</code>\uff0c\u8fd9\u6837\u503c\u548c\u513f\u5b50\u8282\u70b9\u53ef\u4ee5\u901a\u8fc7<code>idx</code>\u8054\u7cfb\u5728\u4e00\u8d77\u4e86\u3002</p> <p>\u53ef\u89c1<code>ph</code>\u6570\u7ec4\u4e3b\u8981\u7528\u4e8e\u5e2e\u52a9\u4ece<code>idx</code>\u6620\u5c04\u5230\u4e0b\u6807<code>k</code>\uff0c\u4f3c\u4e4e\u6709\u4e86<code>ph</code>\u6570\u7ec4\u5c31\u53ef\u4ee5\u5b8c\u6210\u6240\u6709\u64cd\u4f5c\u4e86\uff0c\u4f46\u4e3a\u4ec0\u4e48\u8fd8\u8981\u6709\u4e00\u4e2a<code>hp</code>\u6570\u7ec4\u5462\uff1f\u539f\u56e0\u5c31\u5728\u4e8e\u5728<code>swap</code>\u64cd\u4f5c\u4e2d\u6211\u4eec\u8f93\u5165\u662f\u5806\u6570\u7ec4\u7684\u4e0b\u6807\uff0c\u65e0\u6cd5\u77e5\u9053\u6bcf\u4e2a\u5806\u6570\u7ec4\u7684<code>k</code>\u4e0b\u6807\u5bf9\u5e94\u7684<code>idx</code>(\u7b2c<code>idx</code>\u4e2a\u63d2\u5165)\uff0c\u6240\u4ee5\u9700\u8981<code>hp</code>\u6570\u7ec4\u65b9\u4fbf\u67e5\u627e<code>idx</code>\u3002</p> <pre><code>// h[N]\u5b58\u50a8\u5806\u4e2d\u7684\u503c, h[1]\u662f\u5806\u9876\uff0cx\u7684\u5de6\u513f\u5b50\u662f2x, \u53f3\u513f\u5b50\u662f2x + 1\n// ph[k]\u5b58\u50a8\u7b2ck\u4e2a\u63d2\u5165\u7684\u70b9\u5728\u5806\u4e2d\u7684\u4f4d\u7f6e\n// hp[k]\u5b58\u50a8\u5806\u4e2d\u4e0b\u6807\u662fk\u7684\u70b9\u662f\u7b2c\u51e0\u4e2a\u63d2\u5165\u7684\nint h[N], ph[N], hp[N], size_h;\n\n// \u4ea4\u6362\u4e24\u4e2a\u70b9\uff0c\u53ca\u5176\u6620\u5c04\u5173\u7cfb\nvoid heap_swap(int a, int b) {\n    swap(ph[hp[a]], ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n\nvoid down(int u) {\n    int t = u;\n    if (u * 2 &lt;= size_h &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size_h &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t) {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n\nvoid up(int u) {\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n\n// O(n)\u5efa\u5806\nfor (int i = n / 2; i; i--) down(i);\n</code></pre>"},{"location":"zh/Data_Structures/07_Hash_Table/","title":"\u54c8\u5e0c\u8868","text":""},{"location":"zh/Data_Structures/07_Hash_Table/#_2","title":"\u7b80\u4ecb","text":"<p>\u54c8\u5e0c\u8868\u7684\u4f5c\u7528\uff1a\u628a\u5927\u7684\u6570\u636e(\u5982\uff1a \\(10^9\\) )\u6620\u5c04\u5230\u5c0f\u7684\u6570\u636e\u8303\u56f4(\u5982\uff1a \\(10^6\\) )\u3002</p> <p>\u54c8\u5e0c\u51fd\u6570\u793a\u4f8b\uff1a</p> \\[ h\\left( x \\right) :x\\in \\left( -10^9,10^9 \\right) \\mapsto h\\in \\left( 0,10^5 \\right) ; \\\\ h\\left( x \\right) =x\\,\\,\\left( \\mathrm{mod}\\ 10^5 \\right)  \\] <p>\u5b9e\u9645\u53ef\u80fd\u4f1a\u6709\u54c8\u5e0c\u51b2\u7a81\u3002</p> <p>\u5b9e\u9645\u64cd\u4f5c\u4e2d\uff0c\u53d6\u6a21\u7684\u6570\u4e00\u822c\u4e3a\u8d28\u6570\uff0c\u4e14\u9700\u79bb2\u7684\u6574\u6570\u6b21\u5e42\u5c3d\u53ef\u80fd\u8fdc\uff0c\u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u51b2\u7a81\u6982\u7387\u6700\u5c0f\u3002</p> <p>\u54c8\u5e0c\u8868\u5b58\u50a8\u7ed3\u6784(\u6309\u7167\u5904\u7406\u51b2\u7a81\u7684\u65b9\u5f0f)\uff1a</p> <ul> <li>\u5f00\u653e\u5bfb\u5740\u6cd5</li> <li>\u62c9\u94fe\u6cd5/\u94fe\u5730\u5740\u6cd5</li> </ul> <p>\u6ce8\uff1a\u79bb\u6563\u5316\u662f\u4e00\u79cd\u6781\u5176\u7279\u6b8a\u7684(\u4fdd\u5e8f)\u7684\u54c8\u5e0c\u65b9\u5f0f\u3002</p>"},{"location":"zh/Data_Structures/07_Hash_Table/#_3","title":"\u6574\u6570\u54c8\u5e0c","text":""},{"location":"zh/Data_Structures/07_Hash_Table/#_4","title":"\u62c9\u94fe\u6cd5","text":"<p>\u62c9\u94fe\u6cd5\u662f\u628a\u6240\u6709\u7684\u540c\u4e49\u8bcd\u7528\u5355\u94fe\u8868\u94fe\u63a5\u8d77\u6765\u7684\u65b9\u6cd5\u3002\u5728\u8fd9\u79cd\u65b9\u6cd5\u4e2d\uff0c\u54c8\u5e0c\u8868\u7684\u6bcf\u4e2a\u5355\u5143\u5b58\u50a8\u7684\u4e0d\u518d\u662f\u5143\u7d20\u672c\u8eab\uff0c\u800c\u662f\u76f8\u5e94\u540c\u4e49\u8bcd\u5355\u94fe\u8868\u7684\u5934\u6307\u9488(\u6ce8\u610f\u662f\u5934\u6307\u9488\u800c\u4e0d\u662f\u5934\u8282\u70b9)\u3002</p> <p>\u4e00\u822c\u800c\u8a00\uff0c\u53ef\u89c6\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) (\u54c8\u5e0c\u7b97\u6cd5\u662f\u4e00\u79cd\u201c\u671f\u671b\u7b97\u6cd5\u201d)\uff1b\u7b97\u6cd5\u9898\u4e2d\u4e00\u822c\u8003\u5bdf\u63d2\u5165\u548c\u67e5\u8be2\uff0c\u800c\u8f83\u5c11\u8003\u5bdf\u5220\u9664\u3002</p> <p>\u5bf9\u4e8e\u5355\u94fe\u8868\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u6a21\u62df\u6570\u7ec4\u7684\u65b9\u5f0f\u8fdb\u884c\u5b9e\u73b0\u3002\u6b64\u5916\uff0c\u4f7f\u7528\u62c9\u94fe\u6cd5\u65f6\uff0c \\(m\\)(\u5f00\u7684\u54c8\u5e0c\u8868\u6570\u7ec4\u8303\u56f4) \u7684\u5927\u5c0f\u901a\u5e38\u548c \\(n\\)(\u9898\u76ee\u8f93\u5165\u6761\u76ee\u6570) \u5dee\u4e0d\u591a\u3002\u4f8b\u5982\uff0c\u82e5 \\(n\\leqslant 10^5\\) \uff0c\u6211\u4eec\u53ef\u4ee5\u5bfb\u627e\u5927\u4e8e\u7b49\u4e8e \\(10^5\\) \u7684\u7b2c\u4e00\u4e2a\u8d28\u6570\uff0c\u5373 \\(m=100003\\) \u3002</p> <p>\u6ce8\uff1a\u628a\u54c8\u5e0c\u8868\u7684\u957f\u5ea6\u8bbe\u8ba1\u4e3a\u8d28\u6570(\u4e14\u8fdc\u79bb2\u7684\u6574\u6570\u6b21\u5e42)\u53ef\u4ee5\u5927\u5927\u51cf\u5c0f\u54c8\u5e0c\u51b2\u7a81\u3002</p> <p>\u4f8b\u9898\uff1a\u62c9\u94fe\u6cd5</p> <pre><code>int h[N], e[N], ne[N], idx;\n\n//\u5411\u54c8\u5e0c\u8868\u4e2d\u63d2\u5165\u4e00\u4e2a\u6570\nvoid insert(int x) {\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx++;\n}\n\n//\u5728\u54c8\u5e0c\u8868\u4e2d\u67e5\u8be2\u67d0\u4e2a\u6570\u662f\u5426\u5b58\u5728\nbool find(int x) {\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i]) {\n        if (e[i] == x)\n            return true;\n    }\n    return false;\n}\n</code></pre>"},{"location":"zh/Data_Structures/07_Hash_Table/#_5","title":"\u5f00\u653e\u5bfb\u5740\u6cd5(\u5e38\u7528)","text":"<p>\u5f00\u653e\u5bfb\u5740\u6cd5\u5c31\u662f\u5728\u63d2\u5165\u4e00\u4e2a\u5173\u952e\u5b57\u4e3a \\(k\\) \u7684\u5143\u7d20\u65f6\uff0c\u82e5\u53d1\u751f\u54c8\u5e0c\u51b2\u7a81\uff0c\u5219\u901a\u8fc7\u67d0\u79cd\u54c8\u5e0c\u51b2\u7a81\u89e3\u51b3\u51fd\u6570(\u4e5f\u79f0\u4e3a\u518d\u54c8\u5e0c)\u5f97\u5230\u4e00\u4e2a\u65b0\u7a7a\u95f2\u5730\u5740\u518d\u63d2\u5165\u8be5\u5143\u7d20\u7684\u65b9\u6cd5\u3002\u518d\u54c8\u5e0c\u7684\u8bbe\u8ba1\u6709\u5f88\u591a\u79cd\uff0c\u5e38\u89c1\u7684\u6709\u7ebf\u6027\u63a2\u6d4b\u6cd5\u548c\u5e73\u65b9\u63a2\u6d4b\u6cd5\uff0c\u6b64\u5904\u53ea\u5206\u6790\u524d\u8005\uff0c\u540e\u8005\u53ef\u7c7b\u6bd4\u5f97\u5230\u3002</p> <p>\u7ebf\u6027\u63a2\u6d4b\u6cd5\u662f\u4ece\u53d1\u751f\u51b2\u7a81\u7684\u5730\u5740\u5f00\u59cb\uff0c\u4f9d\u6b21\u63a2\u6d4b\u4e0b\u4e00\u4e2a\u5730\u5740\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u7a7a\u95f2\u5355\u5143\u4e3a\u6b62\u3002\u5f53\u5230\u8fbe\u4e0b\u6807\u4e3a \\(m-1\\) \u7684\u54c8\u5e0c\u8868\u8868\u5c3e\u65f6\uff0c\u4e0b\u4e00\u4e2a\u63a2\u6d4b\u5730\u5740\u662f\u8868\u9996\u5730\u5740 \\(0\\) \u3002\u5f53 \\(m\\geqslant n\\) \u65f6\u4e00\u5b9a\u80fd\u627e\u5230\u4e00\u4e2a\u7a7a\u95f2\u5355\u5143\u3002</p> <p>\u4f7f\u7528\u5f00\u653e\u5bfb\u5740\u6cd5\u65f6\uff0c \\(m\\) \u901a\u5e38\u53d6 \\(n\\) \u7684 \\(2\\sim 3\\) \u500d\u5de6\u53f3\u3002\u4f8b\u5982\u82e5 \\(n\\leqslant 10^5\\) \uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u53d6\u4e0a\u8868\u4e2d\u7684 \\(196613\\) \u4f5c\u4e3a\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u3002</p> <p>\u4f8b\u9898\uff1a\u5f00\u653e\u5bfb\u5740\u6cd5</p> <pre><code>int h[N];\n\n//\u5982\u679cx\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u8fd4\u56dex\u7684\u4e0b\u6807\uff1b\u5982\u679cx\u4e0d\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u8fd4\u56dex\u5e94\u8be5\u63d2\u5165\u7684\u4f4d\u7f6e\nint find(int x) {\n    int t = (x % N + N) % N;\n    while (h[t] != null_num &amp;&amp; h[t] != x) {\n        t++;\n        if (t == N) t = 0;\n    }\n    return t;\n}\n</code></pre> <p>\u4f8b\u9898\u4ee3\u7801\u6ce8\uff1a</p> <ul> <li><code>const int null = 0x3f3f3f3f</code>\u548c<code>memset(h, 0x3f, sizeof h)</code>\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a</li> <li>\u9996\u5148\uff0c\u5fc5\u987b\u8981\u6e05\u695a<code>memset</code>\u51fd\u6570\u5230\u5e95\u662f\u5982\u4f55\u5de5\u4f5c\u7684\uff1a\u5148\u8003\u8651\u4e00\u4e2a\u95ee\u9898\uff0c\u4e3a\u4ec0\u4e48<code>memset</code>\u521d\u59cb\u5316\u6bd4\u5faa\u73af\u66f4\u5feb\uff1f\u7b54\u6848\uff1a<code>memset</code>\u66f4\u5feb\uff0c\u4e3a\u4ec0\u4e48\uff1f\u56e0\u4e3a<code>memset</code>\u662f\u76f4\u63a5\u5bf9\u5185\u5b58\u8fdb\u884c\u64cd\u4f5c\u3002<code>memset</code>\u662f\u6309\u5b57\u8282(byte)\u8fdb\u884c\u590d\u5236\u7684\u3002</li> <li><code>void * memset(void *_Dst,int _Val,size_t _Size);</code>\u8fd9\u662f<code>memset</code>\u7684\u51fd\u6570\u58f0\u660e\uff1a\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e3a\u4e00\u4e2a\u6307\u9488\uff0c\u5373\u8981\u8fdb\u884c\u521d\u59cb\u5316\u7684\u9996\u5730\u5740\uff1b\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u521d\u59cb\u5316\u503c\uff0c\u6ce8\u610f\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u628a\u8fd9\u4e2a\u503c\u8d4b\u7ed9\u4e00\u4e2a\u6570\u7ec4\u5355\u5143(\u5bf9<code>int</code>\u6765\u8bf4\u4e0d\u662f\u8fd9\u6837)\uff1b\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u8981\u521d\u59cb\u5316\u9996\u5730\u5740\u540e\u591a\u5c11\u4e2a\u5b57\u8282\u3002<code>h</code>\u662f<code>int</code>\u7c7b\u578b\uff0c\u5176\u4e3a4\u4e2a\u5b57\u8282\uff0c \u7b2c\u4e8c\u4e2a\u53c2\u6570<code>0x3f</code>\u516b\u4f4d\u4e3a\u4e00\u4e2a\u5b57\u8282\uff0c\u6240\u4ee5<code>0x3f * 4</code>(\u4ece\u9ad8\u5230\u4f4e\u590d\u52364\u4efd) = <code>0x3f3f3f3f</code>\u3002</li> <li>\u8fd9\u4e5f\u8bf4\u660e\u4e86\u4e3a\u4ec0\u4e48\u5728<code>memset</code>\u4e2d\u4e0d\u8bbe\u7f6e\u9664\u4e86<code>-1,0</code>\u4ee5\u5916\u5e38\u89c1\u7684\u503c\uff1a\u6bd4\u59821, \u5b57\u8282\u8868\u793a\u4e3a<code>00000001</code>\uff0c<code>memset(h, 1, 4)</code>\u5219\u8868\u793a\u4e3a<code>0x01010101</code></li> <li>\u4e3a\u4ec0\u4e48\u8981\u53d6<code>0x3f3f3f</code>,\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u5b9a\u4e49\u65e0\u7a77\u5927<code>INF = 0x7fffffff</code>,\u537332\u4e2a1\u6765\u521d\u59cb\u5316\u5462\uff1f</li> <li>\u9996\u5148\uff0c<code>0x3f3f3f</code>\u7684\u4f53\u9a8c\u611f\u5f88\u597d\uff0c<code>0x3f3f3f3f</code>\u7684\u5341\u8fdb\u5236\u662f<code>1061109567</code>\uff0c\u4e5f\u5c31\u662f<code>10^9</code>\u7ea7\u522b\u7684(\u548c<code>0x7fffffff</code>\u4e00\u4e2a\u6570\u91cf\u7ea7)\uff0c\u800c\u4e00\u822c\u573a\u5408\u4e0b\u7684\u6570\u636e\u90fd\u662f\u5c0f\u4e8e<code>10^9</code>\u7684\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u4f5c\u4e3a\u65e0\u7a77\u5927\u4f7f\u7528\u800c\u4e0d\u81f4\u51fa\u73b0\u6570\u636e\u5927\u4e8e\u65e0\u7a77\u5927\u7684\u60c5\u5f62\u3002\u6bd4\u5982<code>0x3f3f3f3f+0x3f3f3f3f=2122219134</code>\uff0c\u8fd9\u975e\u5e38\u5927\u4f46\u5374\u6ca1\u6709\u8d85\u8fc7<code>32-bit,int</code>\u7684\u8868\u793a\u8303\u56f4\uff0c\u6240\u4ee5<code>0x3f3f3f3f</code>\u8fd8\u6ee1\u8db3\u4e86\u6211\u4eec\u201c\u65e0\u7a77\u5927\u52a0\u65e0\u7a77\u5927\u8fd8\u662f\u65e0\u7a77\u5927\u201d\u7684\u9700\u6c42\u3002\u4f46\u662f<code>INF</code>\u4e0d\u540c\uff0c\u4e00\u65e6\u52a0\u4e0a\u67d0\u4e2a\u503c\uff0c\u5f88\u5bb9\u6613\u4e0a\u6ea2\uff0c\u6570\u503c\u6709\u53ef\u80fd\u8f6c\u6210\u8d1f\u6570\u3002</li> <li><code>0x3f3f3f3f</code>\u8fd8\u80fd\u7ed9\u6211\u4eec\u5e26\u6765\u4e00\u4e2a\u610f\u60f3\u4e0d\u5230\u7684\u989d\u5916\u597d\u5904\uff1a\u5982\u679c\u6211\u4eec\u60f3\u8981\u5c06\u67d0\u4e2a\u6570\u7ec4\u6e05\u96f6\uff0c\u6211\u4eec\u901a\u5e38\u4f1a\u4f7f\u7528<code>memset(a,0,sizeof(a))</code>\u8fd9\u6837\u7684\u4ee3\u7801\u6765\u5b9e\u73b0(\u65b9\u4fbf\u800c\u9ad8\u6548)\uff0c\u4f46\u662f\u5f53\u6211\u4eec\u60f3\u5c06\u67d0\u4e2a\u6570\u7ec4\u5168\u90e8\u8d4b\u503c\u4e3a\u65e0\u7a77\u5927\u65f6(\u4f8b\u5982\u89e3\u51b3\u56fe\u8bba\u95ee\u9898\u65f6\u90bb\u63a5\u77e9\u9635\u7684\u521d\u59cb\u5316)\uff0c\u5c31\u4e0d\u80fd\u4f7f\u7528<code>memset</code>\u51fd\u6570\u800c\u5f97\u81ea\u5df1\u5199\u5faa\u73af\u4e86\uff0c\u6211\u4eec\u77e5\u9053\u8fd9\u662f\u56e0\u4e3a<code>memset</code>\u662f\u6309\u5b57\u8282\u64cd\u4f5c\u7684\uff0c\u5b83\u80fd\u591f\u5bf9\u6570\u7ec4\u6e05\u96f6\u662f\u56e0\u4e3a0\u7684\u6bcf\u4e2a\u5b57\u8282\u90fd\u662f0\uff0c\u73b0\u5728\u5982\u679c\u6211\u4eec\u5c06\u65e0\u7a77\u5927\u8bbe\u4e3a<code>0x3f3f3f3f</code>\uff0c0x3f3f3f3f\u7684\u6bcf\u4e2a\u5b57\u8282\u90fd\u662f<code>0x3f</code>\uff01\u6240\u4ee5\u8981\u628a\u4e00\u6bb5\u5185\u5b58\u5168\u90e8\u7f6e\u4e3a\u65e0\u7a77\u5927\uff0c\u6211\u4eec\u53ea\u9700\u8981<code>memset(a,0x3f,sizeof(a))</code>\u3002</li> </ul>"},{"location":"zh/Data_Structures/07_Hash_Table/#_6","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":""},{"location":"zh/Data_Structures/07_Hash_Table/#_7","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c\u7b80\u4ecb","text":"<p>\u8fd9\u91cc\u8bb2\u8ff0\u5b57\u7b26\u4e32\u524d\u7f00\u54c8\u5e0c\u6cd5\u3002</p> <p>\u4f8b\u5982\uff1a<code>str=\"ASDFGHJ\"</code>\uff0c\u6709<code>h[0]=0</code>\uff0c<code>h[1]=\"A\"</code>\uff0c<code>h[2]=\"AS\"</code>\uff0c<code>h[3]=\"ASD\"</code>\u7b49\u3002</p> <p>\u5728\u8fd9\u91cc\u9700\u8981\u628a\u5b57\u7b26\u4e32<code>str</code>\u5f53\u4f5c\u4e00\u4e2a \\(p\\) \u8fdb\u5236\u6570\uff0c\u6bd4\u5982\u5b57\u7b26\u4e32<code>ABCD</code>\u53ef\u4ee5\u5f53\u4f5c \\(\\left( 1234 \\right) _p\\) \uff0c\u5219\u8f6c\u5316\u4e3a10\u8fdb\u5236\u540e\u53d6\u6a21\u5f97\u5230 \\(\\left( 1\\times p^3+2\\times p^2+3\\times p^1+4\\times p^0 \\right) \\mathrm{mod} Q\\) \uff0c\u4e8b\u5b9e\u4e0a\u53d6\u6a21\u53ef\u4ee5\u901a\u8fc7\u5c06<code>h[...]</code>\u6570\u636e\u7c7b\u578b\u8bbe\u8ba1\u6210<code>unsigned long long</code>\uff0c\u6570\u636e\u6ea2\u51fa\u5c31\u662f\u53d6\u6a21\u3002</p> <p>\u6ce8\u610f\uff1a\u4e0d\u8981\u6620\u5c04\u62100\uff0c\u5426\u5219\u53ef\u80fd\u5bfc\u81f4\u51b2\u7a81\uff0c\u5efa\u8bae\u4ece1\u5f00\u59cb\u3002</p> <p>\u6839\u636e\u7ecf\u9a8c\uff0c\u5f53 \\(p=131\\) \u6216 \\(p=1331\\) \uff0c\u4e14 \\(Q=2^{64}\\) \u65f6\uff0c\u57fa\u672c\u4e0d\u4f1a\u53d1\u751f\u51b2\u7a81\u3002</p> <p>\u524d\u7f00\u54c8\u5e0c\u7684\u597d\u5904\u662f\u53ef\u4ee5\u901a\u8fc7\u524d\u7f00\u7684\u54c8\u5e0c\u7b97\u51fa\u6240\u6709\u5b50\u4e32\u7684\u54c8\u5e0c\u3002</p>"},{"location":"zh/Data_Structures/07_Hash_Table/#_8","title":"\u6570\u5b66\u8bed\u8a00\u63cf\u8ff0","text":"<p>\u5bf9\u4e8e\u4e00\u4e2a\u957f\u5ea6\u4e3a \\(l\\) \u7684\u5b57\u7b26\u4e32 \\(s\\) \u6765\u8bf4\uff0c\u54c8\u5e0c\u51fd\u6570\u5b9a\u4e49\u4e3a\uff1a</p> \\[ h\\left( s \\right) =\\sum_{i=1}^l{s\\left[ i \\right] \\times p^{l-i}}\\left( \\mathrm{mod} Q \\right)  \\] <p>\u5176\u4e2d \\(s[i]\\) \u4e3a\u5b57\u7b26\u7684ASCII\u7801\uff0c \\(p\\) \u901a\u5e38\u53d6 \\(131\\) \u6216 \\(131313\\) \uff0c \\(M\\) \u53d6 \\(2^{64}\\) (\u4f7f\u7528\u8fd9\u79cd\u53d6\u503c\uff0c\u54c8\u5e0c\u51b2\u7a81\u7684\u6982\u7387\u51e0\u4e4e\u4e3a \\(0\\) \uff0c\u6545\u4e0b\u6587\u4e0d\u518d\u8003\u8651\u54c8\u5e0c\u51b2\u7a81)</p> <p>\u6ce8\u610f\u5230\u4f7f\u7528<code>unsigned long long</code>\u8fd9\u4e2a\u53d8\u91cf\u7c7b\u578b\u5b58\u50a8\u54c8\u5e0c\u503c\uff0c\u6ea2\u51fa\u65f6\u5c31\u76f8\u5f53\u4e8e\u5bf9 \\(M\\) \u53d6\u6a21\u3002\u8bb0 \\(h(s)\\triangleq h(s[1..l])\\) \uff0c\u53ef\u89c1\uff1a</p> \\[ h\\left( s\\left[ 1\\cdots l \\right] \\right) =\\sum_{i=1}^{l-1}{s\\left[ i \\right] \\times p^{l-i}}+s\\left[ l \\right] =p\\times h\\left( s\\left[ 1\\cdots l-1 \\right] \\right) +s\\left[ l \\right]  \\] <p>\u63a5\u4e0b\u6765\u5206\u522b\u5f00\u4e24\u4e2a\u6570\u7ec4 \\(h\\) \u548c \\(p\\) \uff0c\u5176\u4e2d \\(h[i]\\triangleq h(s[1..i])\\) \u7528\u6765\u5b58\u50a8\u539f\u4e32\u957f\u5ea6\u4e3a \\(i\\) \u7684\u524d\u7f00\u7684\u54c8\u5e0c\u503c\uff0c \\(p[i]\\) \u7528\u6765\u5b58\u50a8 \\(p^i\\) \uff0c\u4e8e\u662f\u5f97\u5230\u9012\u63a8\u5f0f\uff1a</p> \\[ \\begin{cases}     h\\left[ i \\right] =h\\left[ i-1 \\right] \\cdot p+s\\left[ i \\right] , 1\\leqslant i\\leqslant l\\\\     p\\left[ i \\right] =p\\left[ i-1 \\right] \\cdot p, 1\\leqslant i\\leqslant l\\\\     h\\left[ 0 \\right] =0, p\\left[ 0 \\right] =1\\\\ \\end{cases} \\] <p>\u4ece\u800c\uff0c \\(h[l]\\) \u5c31\u4ee3\u8868\u5b57\u7b26\u4e32 \\(s\\) \u7684\u54c8\u5e0c\u503c\u3002\u5728\u6c42\u89e3\u7684\u8fc7\u7a0b\u4e2d\u6211\u4eec\u8fd8\u5f97\u5230\u4e86 \\(s\\) \u7684\u6240\u6709\u524d\u7f00\u54c8\u5e0c\u503c\u3002\u5229\u7528\u524d\u7f00\u54c8\u5e0c\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 \\(O(1)\\) \u7684\u65f6\u95f4\u5185\u6c42\u51fa \\(s\\) \u7684\u4efb\u4e00\u5b50\u4e32\u7684\u54c8\u5e0c\u503c\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u8bbe\u5b50\u4e32\u4e3a \\(s[l..r]\\)\uff08\u8fd9\u91cc\u7684 \\(l\\) \u5e76\u975e\u6307\u957f\u5ea6\uff0c\u800c\u662f<code>left</code>\u7684\u610f\u601d\uff09\uff0c\u6ce8\u610f\u5230</p> \\[ h\\left[ l-1 \\right] =\\sum_{i=1}^{l-1}{s\\left[ i \\right] \\cdot p^{l-1-i}}, \\\\ h\\left[ r \\right] =\\sum_{i=1}^r{s\\left[ i \\right] \\cdot p^{r-i}} \\] <p>\u5219\u53ef\u4ee5\u5f97\u5230\uff1a</p> \\[ h\\left[ r \\right] -p^{r-l+1}\\cdot h\\left[ l-1 \\right] =\\sum_{i=1}^r{s\\left[ i \\right] \\cdot p^{r-i}}-\\sum_{i=1}^{l-1}{s\\left[ i \\right] \\cdot p^{r-i}} \\\\ =\\sum_{i=l}^r{s\\left[ i \\right] \\cdot p^{r-i}} \\] <p>\u53ef\u8bb0\u5fc6\u5982\u4e0b\u516c\u5f0f\uff1a\u5b57\u7b26\u4e32 \\(h\\) \u7684\u4e0b\u6807 \\(l\\) \u81f3 \\(r\\) \u6bb5\u7684\u54c8\u5e0c\u503c\u4e3a \\(h\\left[ r \\right] -h\\left[ l-1 \\right] \\cdot p^{r-l+1}\\)</p> <p>\u5b57\u7b26\u4e32\u54c8\u5e0c\u7684\u516c\u5f0f\u4e2d \\(h\\left[ r \\right] -h\\left[ l-1 \\right] \\cdot p^{r-l+1}\\) \uff0c \\(h[l-1]\\) \u8981\u4e58\u4e0a \\(p^{r-l+1}\\) \u7684\u539f\u56e0\u4e3e\u4f8b\uff1a</p> <p>\u6bd4\u5982<code>aabbaabb</code>\u8fd9\u4e2a\u5b57\u7b26\u4e32\uff0c\u8981\u6c42\u4e0b\u6807<code>3</code>\u5230<code>7</code>(<code>bbaab</code>)\u8fd9\u4e00\u6bb5\u54c8\u5e0c\u503c\uff0c\u9700\u8981\u77e5\u9053 \\(h[l - 1] = h[2]\\) \u548c \\(h[r] = h[7]\\) \uff0c\u5373<code>aa</code>\u548c<code>aabbaab</code>\u7684\u54c8\u5e0c\u503c\uff0c\u8f6c\u6362\u4e3a \\(p\\) \u8fdb\u5236\u5c31\u662f \\({(11)}_p\\) \u548c \\({(1122112)}_p\\) \uff0c\u6211\u4eec\u9700\u8981\u6c42<code>bbaab</code>\u8fd9\u4e00\u4e2a\u5b50\u4e32\u7684\u54c8\u5e0c\u503c\uff0c\u8f6c\u6362\u4e3a \\(p\\) \u8fdb\u5236\u5c31\u662f \\({(22112)}_p\\)\uff0c\u800c\u5c06 \\(h[l-1] \\times P[r-l+1]\\) \u5c31\u662f\u5de6\u79fb \\(r-l+1\\) \u4f4d\u53d8\u6210 \\({(1100000)}_p\\) \uff0c\u800c \\(h[r] - h[l-1] \\times P[r-l+1]\\) \u5c31\u662f \\({(22112)}_p\\) \uff0c\u4e5f\u5c31\u662f\u5b50\u4e32<code>bbaab</code>\u7684\u54c8\u5e0c\u503c\u3002</p>"},{"location":"zh/Data_Structures/07_Hash_Table/#_9","title":"\u6a21\u677f\u4e0e\u4f8b\u9898","text":"<p>\u5e38\u7528\u4e8e\u5feb\u901f\u5224\u65ad\u4e24\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u76f8\u7b49(\u65f6\u95f4\u590d\u6742\u5ea6\u7531 \\(O(n)\\) \u964d\u4e3a \\(O(1)\\) )\uff0c\u53ef\u4ee5\u66ff\u4ee3KMP(\u4f46\u5728\u5bfb\u627e\u5faa\u73af\u8282\u7684\u95ee\u9898\u4e0a\u53ea\u80fd\u7528KMP)\u3002</p> <p>\u4f8b\u9898\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c</p> <pre><code>//\u6838\u5fc3\u601d\u60f3\uff1a\u5c06\u5b57\u7b26\u4e32\u770b\u6210P\u8fdb\u5236\u6570\uff0cP\u7684\u7ecf\u9a8c\u503c\u662f131\u621613331\uff0c\u53d6\u8fd9\u4e24\u4e2a\u503c\u7684\u51b2\u7a81\u6982\u7387\u4f4e\n//\u5c0f\u6280\u5de7\uff1a\u53d6\u6a21\u7684\u6570\u75282^64\uff0c\u8fd9\u6837\u76f4\u63a5\u7528unsigned long long\u5b58\u50a8\uff0c\u6ea2\u51fa\u7684\u7ed3\u679c\u5c31\u662f\u53d6\u6a21\u7684\u7ed3\u679c\ntypedef unsigned long long ULL;\nULL h[N], p[N];  // h[k]\u5b58\u50a8\u5b57\u7b26\u4e32\u524dk\u4e2a\u5b57\u6bcd\u7684\u54c8\u5e0c\u503c, p[k]\u5b58\u50a8 P^k mod 2^64\n\n// \u521d\u59cb\u5316\np[0] = 1;\nfor (int i = 1; i &lt;= n; i++) {\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n\n// \u8ba1\u7b97\u5b50\u4e32 str[l ~ r] \u7684\u54c8\u5e0c\u503c\nULL get_hash(int l, int r) {\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n</code></pre>"},{"location":"zh/Data_Structures/Special_Topic_STL/","title":"C++ STL","text":"<ul> <li>C++ STL</li> <li>\u6570\u7ec4 (array)</li> <li>\u5411\u91cf (vector)</li> <li>\u5bf9 (pair)</li> <li>\u5b57\u7b26\u4e32 (string)</li> <li>\u94fe\u8868 (list)<ul> <li>\u5355\u5411\u94fe\u8868 (forward_list)</li> <li>\u53cc\u5411\u94fe\u8868 (list)</li> </ul> </li> <li>\u961f\u5217<ul> <li>\u666e\u901a\u961f\u5217 (queue)</li> <li>\u4f18\u5148\u961f\u5217 (priority_queue)</li> </ul> </li> <li>\u6808 (stack)</li> <li>\u53cc\u7aef\u961f\u5217 (deque)</li> <li>\u96c6\u5408\u548c\u6620\u5c04<ul> <li>\u96c6\u5408 (set, multiset)</li> <li>\u6620\u5c04 (map, multimap)</li> </ul> </li> <li>\u54c8\u5e0c\u8868<ul> <li>unordered_set</li> <li>unordered_multiset</li> <li>unordered_map</li> <li>unordered_multimap</li> </ul> </li> <li>\u4f4d\u96c6 (bitset)</li> </ul> <p>STL\u7684\u66f4\u591a\u8d44\u6e90\u8be6\u89c1 \u901f\u67e5\u7f51\u7ad9 \u548c \u901f\u67e5PDF\u3002</p> <p>C++\u7684 Standard Template Library(STL) \u5305\u542b\u4ee5\u4e0b\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ul> <li>Container(\u5bb9\u5668): \u7528\u6765\u5b58\u50a8\u6570\u636e\uff1b</li> <li>Iterator(\u8fed\u4ee3\u5668): \u7528\u6765\u8bbf\u95ee\u6570\u636e\uff1b</li> <li>Algorithm(\u7b97\u6cd5): \u5bf9STL\u76f8\u5173\u64cd\u4f5c\u7684\u7b97\u6cd5\u3002</li> </ul> <p>\u901a\u7528\u64cd\u4f5c\uff1a</p> <ul> <li><code>size()</code>: \u8fd4\u56de\u5143\u7d20\u4e2a\u6570</li> <li><code>empty()</code>: \u8fd4\u56de\u662f\u5426\u4e3a\u7a7a</li> </ul>"},{"location":"zh/Data_Structures/Special_Topic_STL/#array","title":"\u6570\u7ec4 (array)","text":"<p>\u8bed\u6cd5\uff1a<code>std::array&lt;T, N&gt; arr;</code></p> <p><code>array</code>\u662f\u4e00\u4e2a\u5c01\u88c5\u4e86 \u56fa\u5b9a \u5927\u5c0f\u6570\u7ec4\u7684\u5bb9\u5668\uff0c\u7f16\u8bd1\u671f\u95f4\u9700\u8981\u77e5\u9053\u6570\u7ec4\u5927\u5c0f\uff01<code>array</code>\u7684\u201c\u503c\u4f20\u9012\u201d\u786e\u5b9e\u662f\u503c\u4f20\u9012(\u56de\u5fc6\uff1a\u4f20\u7edf\u7684\u975eSTL\u7684\u6570\u7ec4\u662f\u6307\u9488\u4f20\u9012)\u3002</p> <p><code>array</code>\u8bbf\u95ee\u5143\u7d20\u7684\u65b9\u5f0f\uff1a</p> <ul> <li><code>at()</code>: \u4f8b\u5982<code>arr.at(4)</code>\u6307\u7684\u662f<code>arr[4]</code>\uff0c\u5982\u679c\u4e0b\u6807\u8d8a\u754c\u4f1a\u629b\u51faout of bound exception\uff1b</li> <li><code>[]</code>: \u4e0b\u6807\u8d8a\u754c\u7684\u884c\u4e3a\u4e0e<code>at()</code>\u4e0d\u540c\uff1b</li> <li><code>front()</code>: \u8fd4\u56de\u7b2c\u4e00\u4e2a\u5143\u7d20\uff1b</li> <li><code>back()</code>: \u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff1b</li> <li><code>data()</code>: \u8fd4\u56de<code>arr</code>\u7684\u6307\u9488\u3002</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1aarray</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#vector","title":"\u5411\u91cf (vector)","text":"<p>\u8bed\u6cd5\uff1a<code>std::vector&lt;T&gt; vec;</code></p> <p><code>vector</code>( Sequence Container )\u662f \u53d8\u957f\u6570\u7ec4\uff0c\u57fa\u672c\u601d\u60f3\u662f\u500d\u589e\uff0c\u6709\u65f6\u88ab\u79f0\u4e3aDynamic Array\u6216Array List\u3002<code>vector</code>\u53ef\u4ee5\u770b\u4f5c\u96c6\u5408\u4e86\u201c\u94fe\u8868+\u6570\u7ec4\u201d\u4f18\u70b9\u7684\u5bb9\u5668\u3002</p> <p><code>std::vector</code>\u662f\u4e00\u79cd\u5e8f\u5217\u5bb9\u5668\uff0c\u53ef\u5c01\u88c5\u52a8\u6001\u5927\u5c0f\u7684\u6570\u7ec4\u3002\u5143\u7d20\u662f\u8fde\u7eed\u5b58\u50a8\u7684\uff0c\u8fd9\u610f\u5473\u7740\u4e0d\u4ec5\u53ef\u4ee5\u901a\u8fc7\u8fed\u4ee3\u5668\u8bbf\u95ee\u5143\u7d20\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u6307\u5411\u5143\u7d20\u7684\u5e38\u89c4\u6307\u9488\u7684\u504f\u79fb\u91cf\u8bbf\u95ee\u5143\u7d20\u3002\u8fd9\u610f\u5473\u7740\u6307\u5411<code>vector</code>\u5143\u7d20\u7684\u6307\u9488\u53ef\u4ee5\u4f20\u9012\u7ed9\u4efb\u4f55\u671f\u671b\u6307\u5411\u6570\u7ec4\u5143\u7d20\u6307\u9488\u7684\u51fd\u6570\u3002</p> <p><code>vector</code>\u7684\u5b58\u50a8\u4f1a\u81ea\u52a8\u5904\u7406\uff0c\u5e76\u6839\u636e\u9700\u8981\u8fdb\u884c\u6269\u5c55\u3002<code>vector</code>\u901a\u5e38\u6bd4\u9759\u6001\u6570\u7ec4\u5360\u7528\u66f4\u591a\u7a7a\u95f4\uff0c\u56e0\u4e3a\u4f1a\u5206\u914d\u66f4\u591a\u5185\u5b58\u6765\u5904\u7406\u672a\u6765\u7684\u589e\u957f\u3002\u8fd9\u6837\uff0c\u6bcf\u6b21\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c<code>vector</code>\u90fd\u4e0d\u9700\u8981\u91cd\u65b0\u5206\u914d\uff0c\u800c\u53ea\u9700\u5728\u989d\u5916\u5185\u5b58\u7528\u5b8c\u65f6\u91cd\u65b0\u5206\u914d\u3002\u4f7f\u7528<code>capacity()</code>\u51fd\u6570\u53ef\u4ee5\u67e5\u8be2\u5206\u914d\u7684\u5185\u5b58\u603b\u91cf\u3002\u591a\u4f59\u7684\u5185\u5b58\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528<code>shrink_too_fit()</code>\u8fd4\u56de\u7ed9\u7cfb\u7edf\u3002\u5c31\u6027\u80fd\u800c\u8a00\uff0c\u91cd\u65b0\u5206\u914d\u901a\u5e38\u662f\u4ee3\u4ef7\u9ad8\u6602\u7684\u64cd\u4f5c\u3002\u5982\u679c\u4e8b\u5148\u77e5\u9053\u5143\u7d20\u7684\u6570\u91cf\uff0c\u53ef\u4ee5\u4f7f\u7528<code>reserve()</code>\u51fd\u6570\u6765\u6d88\u9664\u91cd\u65b0\u5206\u914d\u3002</p> <p><code>vector</code>\u5e38\u89c1\u64cd\u4f5c\u7684\u5f00\u9500\u5982\u4e0b\uff1a</p> <ul> <li>\u968f\u673a\u5b58\u53d6\uff1a\u5e38\u91cf \\(O(1)\\)</li> <li>\u5728\u672b\u5c3e\u63d2\u5165\u6216\u79fb\u9664\u5143\u7d20\uff1a\u644a\u9500\u65f6\u95f4\u4e3a\u5e38\u6570(Constant Amortized Time) \\(O(1)\\)</li> <li>\u63d2\u5165\u6216\u79fb\u9664\u5143\u7d20\uff1a\u4e0e\u5411\u91cf\u672b\u7aef\u7684\u8ddd\u79bb\u6210\u7ebf\u6027\u5173\u7cfb \\(O(n)\\)</li> </ul> <p><code>vector</code>\u8bbf\u95ee\u5143\u7d20\u7684\u65b9\u5f0f\uff1a</p> <ul> <li><code>at()</code>:</li> <li><code>[]</code>: \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(1)\\)</li> <li><code>front()</code>:</li> <li><code>back()</code>:</li> <li><code>data()</code>:</li> </ul> <p>\u6ce8\uff1a\u7cfb\u7edf\u4e3a\u67d0\u4e00\u4e2a\u7a0b\u5e8f\u5206\u914d\u7a7a\u95f4\u65f6\uff0c\u6240\u9700\u7684\u65f6\u95f4\u4e0e\u7a7a\u95f4\u5927\u5c0f\u57fa\u672c\u65e0\u5173\uff0c\u800c\u4e0e\u7533\u8bf7\u6b21\u6570\u6709\u5173\uff0c\u56e0\u6b64\u53d8\u957f\u6570\u7ec4\u8981\u5c3d\u91cf\u51cf\u5c0f\u7533\u8bf7\u7a7a\u95f4\u7684\u6b21\u6570(\u53ef\u4ee5\u6d6a\u8d39\u7a7a\u95f4)\u3002\u5bf9\u957f\u5ea6\u4e3a \\(n\\) \u7684<code>vector</code>\uff0c\u5f00\u8f9f\u7a7a\u95f4\u7684\u6b21\u6570\u4e3a \\(\\log n\\) \uff0c\u800c\u989d\u5916copy\u7684\u6b21\u6570\u4e3a \\(O(1)\\)\u3002</p> <p><code>vector</code>\u7684\u5e38\u89c1\u64cd\u4f5c\uff1a</p> <ul> <li><code>front()</code>, <code>back()</code>:</li> <li><code>push_back()</code>:</li> <li><code>pop_back()</code>:</li> <li><code>insert()</code>:</li> <li><code>emplace()</code>:</li> <li><code>emplace_back()</code>:</li> <li><code>resize()</code>:</li> <li><code>swap()</code>:</li> <li><code>erase()</code>:</li> <li><code>clear()</code>: \u6e05\u7a7a</li> <li><code>reserve()</code>: \u5c06<code>vector</code>\u7684\u5bb9\u91cf(<code>vector</code>\u5728\u4e0d\u9700\u8981\u91cd\u65b0\u5206\u914d\u7684\u60c5\u51b5\u4e0b\u53ef\u5bb9\u7eb3\u7684\u5143\u7d20\u603b\u6570)\u589e\u52a0\u5230\u5927\u4e8e\u6216\u7b49\u4e8e\u65b0\u8bbe\u5b9a\u7684\u503c\u3002\u5982\u679c\u65b0\u8bbe\u5b9a\u5927\u4e8e\u5f53\u524d\u7684<code>capacity()</code>\uff0c\u5c31\u4f1a\u5206\u914d\u65b0\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u5426\u5219\u51fd\u6570\u4e0d\u4f1a\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\uff1b</li> <li><code>begin()</code>, <code>end()</code>: \u6ce8\u610f<code>end()</code>\u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u6570\u7684\u4e0b\u4e00\u4e2a\u6570\u7684\u8fed\u4ee3\u5668</li> </ul> <p><code>vector</code>\u652f\u6301\u968f\u673a\u5bfb\u5740\uff0c\u652f\u6301\u6bd4\u8f83\u8fd0\u7b97\u3002</p> <p>\u533a\u5206\uff1a</p> <ul> <li><code>size()</code>: \u8fd4\u56de\u5f53\u524d\u5143\u7d20\u4e2a\u6570\uff1b</li> <li><code>capacity()</code>: \u8fd4\u56de\u5f53\u524d\u5206\u914d\u7684\u5b58\u50a8\u7a7a\u95f4\u53ef\u5bb9\u7eb3\u7684\u5143\u7d20\u4e2a\u6570\u3002</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1avector 1; vector 2; vector 3</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#pair","title":"\u5bf9 (pair)","text":"<pre><code>template&lt;\n    class T1,\n    class T2\n&gt; struct pair;\n</code></pre> <p><code>std::pair</code>\u662f\u4e00\u4e2a\u7c7b\u6a21\u677f\uff0c\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06\u4e24\u4e2a\u5f02\u6784\u5bf9\u8c61\u5b58\u50a8\u4e3a\u4e00\u4e2a\u5355\u5143\u7684\u65b9\u6cd5\u3002\u4e00\u4e2a<code>pair</code>\u662f\u5305\u542b\u4e24\u4e2a\u5143\u7d20\u7684<code>std::tuple</code>\u7684\u4e00\u79cd\u7279\u6b8a\u60c5\u51b5\u3002</p> <p><code>pair</code>: \u5b9a\u4e49\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u524d\u540e\u4e24\u4e2a\u53d8\u91cf\u7c7b\u578b\u53ef\u4ee5\u4e0d\u4e00\u6837\uff1b\u7c7b\u4f3c\u4e8e\u6709\u4e24\u4e2a\u53d8\u91cf\u4e14\u5b9e\u73b0\u4e86\u4e00\u4e9b\u51fd\u6570\u7684\u7ed3\u6784\u4f53\u3002</p> <ul> <li><code>first</code>: \u7b2c\u4e00\u4e2a\u5143\u7d20</li> <li><code>second</code>: \u7b2c\u4e8c\u4e2a\u5143\u7d20</li> </ul> <p><code>pair</code>\u652f\u6301\u6bd4\u8f83\u8fd0\u7b97\uff0c\u4ee5<code>first</code>\u4e3a\u7b2c\u4e00\u4e2a\u5173\u952e\u5b57\uff0c<code>second</code>\u4e3a\u7b2c\u4e8c\u4e2a\u5173\u952e\u5b57(\u5b57\u5178\u987a\u5e8f)\u3002</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1apair</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#string","title":"\u5b57\u7b26\u4e32 (string)","text":"<p><code>string</code>: \u5b57\u7b26\u4e32\uff0c<code>substr()</code>, <code>c_str()</code></p> <ul> <li><code>clear()</code>: \u6e05\u7a7a</li> <li><code>substr()</code>: </li> <li><code>c_str()</code>: </li> <li><code>length()</code>: \u4f5c\u7528\u540c<code>size()</code>\uff0c\u90fd\u662f\u8fd4\u56de\u5b57\u7b26\u4e32\u957f\u5ea6</li> </ul>"},{"location":"zh/Data_Structures/Special_Topic_STL/#list","title":"\u94fe\u8868 (list)","text":"<p>STL\u94fe\u8868\u79cd\u7c7b\uff1a</p> <ul> <li><code>forward_list</code>: \u5355\u5411\u94fe\u8868</li> <li><code>list</code>: \u53cc\u5411\u94fe\u8868</li> </ul>"},{"location":"zh/Data_Structures/Special_Topic_STL/#forward_list","title":"\u5355\u5411\u94fe\u8868 (forward_list)","text":"<p><code>std::forward_list</code>\u662f\u4e00\u4e2a\u5bb9\u5668\uff0c\u652f\u6301\u4ece\u5bb9\u5668\u4e2d\u7684\u4efb\u4f55\u4f4d\u7f6e\u5feb\u901f\u63d2\u5165\u548c\u79fb\u9664\u5143\u7d20\u3002\u4e0d\u652f\u6301\u5feb\u901f\u968f\u673a\u5b58\u53d6\u3002\u5b83\u4ee5\u5355\u94fe\u8868\u7684\u5f62\u5f0f\u5b9e\u73b0\u3002\u4e0e<code>std::list</code>\u76f8\u6bd4\uff0c\u5f53\u4e0d\u9700\u8981\u53cc\u5411\u8fed\u4ee3\u65f6\uff0c\u8be5\u5bb9\u5668\u80fd\u63d0\u4f9b\u66f4\u8282\u7701\u7a7a\u95f4\u7684\u5b58\u50a8\u7a7a\u95f4\u3002</p> <p>\u5728\u5217\u8868\u6216\u591a\u4e2a\u5217\u8868\u4e2d\u6dfb\u52a0\u3001\u5220\u9664\u548c\u79fb\u52a8\u5143\u7d20\u4e0d\u4f1a\u4f7f\u5f53\u524d\u5f15\u7528\u5217\u8868\u4e2d\u5176\u4ed6\u5143\u7d20\u7684\u8fed\u4ee3\u5668\u5931\u6548\u3002\u4f46\u662f\uff0c\u5f53\u76f8\u5e94\u7684\u5143\u7d20\u4ece\u5217\u8868\u4e2d\u5220\u9664(\u901a\u8fc7<code>erase_after</code>)\u65f6\uff0c\u6307\u5411\u8be5\u5143\u7d20\u7684\u8fed\u4ee3\u5668\u6216\u5f15\u7528\u5c31\u4f1a\u5931\u6548\u3002</p> <p>\u652f\u6301\u64cd\u4f5c\uff1a<code>operator =</code>, <code>assign</code>, <code>front</code>, <code>empty</code>, <code>max_size</code>, <code>clear</code>, <code>insert_after</code>, <code>emplace_after</code>, <code>reverse</code>, <code>sort</code>, <code>merge</code>, <code>splice_after</code>, <code>unique</code>, <code>remove</code>, <code>remove_if</code>, <code>resize</code>\u7b49\u3002</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1aforward_list</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#list_1","title":"\u53cc\u5411\u94fe\u8868 (list)","text":"<p><code>std::list</code>\u662f\u4e00\u79cd\u5bb9\u5668\uff0c\u652f\u6301\u4ece\u5bb9\u5668\u4e2d\u7684\u4efb\u4f55\u4f4d\u7f6e\u5b9a\u65f6\u63d2\u5165\u548c\u79fb\u9664\u5143\u7d20\u3002\u4e0d\u652f\u6301\u5feb\u901f\u968f\u673a\u5b58\u53d6\u3002\u5b83\u901a\u5e38\u4ee5\u53cc\u94fe\u8868\u7684\u5f62\u5f0f\u5b9e\u73b0\u3002\u4e0e<code>std::forward_list</code>\u76f8\u6bd4\uff0c\u8be5\u5bb9\u5668\u63d0\u4f9b\u53cc\u5411\u8fed\u4ee3\u529f\u80fd\uff0c\u4f46\u7a7a\u95f4\u6548\u7387\u8f83\u4f4e\u3002</p> <p>\u5728\u5217\u8868\u6216\u591a\u4e2a\u5217\u8868\u4e2d\u6dfb\u52a0\u3001\u5220\u9664\u548c\u79fb\u52a8\u5143\u7d20\u4e0d\u4f1a\u4f7f\u8fed\u4ee3\u5668\u6216\u5f15\u7528\u5931\u6548\u3002\u53ea\u6709\u5220\u9664\u76f8\u5e94\u5143\u7d20\u65f6\uff0c\u8fed\u4ee3\u5668\u624d\u4f1a\u5931\u6548\u3002</p> <p>\u652f\u6301\u64cd\u4f5c\uff1a<code>operator =</code>, <code>assign</code>, <code>front</code>, <code>back</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>empty</code>, <code>size</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>max_size</code>, <code>clear</code>, <code>insert</code>, <code>emplace</code>, <code>push_back</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>pop_back</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>push_front</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>pop_front</code>(<code>forward_list</code>\u65e0\u6b64\u64cd\u4f5c), <code>reverse</code>, <code>sort</code>, <code>merge</code>, <code>splice</code>, <code>unique</code>, <code>remove</code>, <code>remove_if</code>, <code>resize</code>\u7b49\u3002</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1alist</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#_1","title":"\u961f\u5217","text":""},{"location":"zh/Data_Structures/Special_Topic_STL/#queue","title":"\u666e\u901a\u961f\u5217 (queue)","text":"<pre><code>template&lt;\n    class T,\n    class Container = std::deque&lt;T&gt;\n&gt; class queue;\n</code></pre> <p><code>std::queue</code>\u7c7b\u662f\u4e00\u4e2a\u5bb9\u5668\u9002\u914d\u5668(container adaptor)\uff0c\u5b83\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u961f\u5217\u7684\u529f\u80fd\uff0c\u7279\u522b\u662f\u5148\u8fdb\u5148\u51fa(FIFO)\u6570\u636e\u7ed3\u6784\u3002\u8be5\u7c7b\u6a21\u677f\u5145\u5f53\u5e95\u5c42\u5bb9\u5668\u7684\u5c01\u88c5\u5668\uff0c\u53ea\u63d0\u4f9b\u4e00\u7ec4\u7279\u5b9a\u7684\u51fd\u6570\u3002<code>queue</code>\u5c06\u5143\u7d20\u63a8\u5230\u5e95\u5c42\u5bb9\u5668\u7684\u540e\u9762\uff0c\u7136\u540e\u4ece\u524d\u9762\u53d6\u51fa\u3002</p> <p><code>queue</code>\u5141\u8bb8\u5728<code>back</code>\u8fdb\u884c<code>push</code>(insert)\uff0c\u6216\u8005\u5728<code>front</code>\u8fdb\u884c<code>pop</code>(remove)\u3002</p> <p><code>queue</code>\u652f\u6301\u64cd\u4f5c: <code>push()</code>, <code>front()</code>, <code>back()</code>, <code>pop()</code>, <code>empty()</code>, <code>size()</code>\u7b49\u3002</p> <ul> <li><code>push()</code>: \u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u5143\u7d20</li> <li><code>front()</code>: \u8fd4\u56de\u961f\u5934\u5143\u7d20</li> <li><code>back()</code>: \u8fd4\u56de\u961f\u5c3e\u5143\u7d20</li> <li><code>pop()</code>: \u5f39\u51fa\u961f\u5934\u5143\u7d20</li> </ul> <p>\u6ce8\uff1a<code>queue</code>\u6ca1\u6709<code>clear()</code>\u51fd\u6570\uff01</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1aquque</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#priority_queue","title":"\u4f18\u5148\u961f\u5217 (priority_queue)","text":"<pre><code>template&lt;\n    class T,\n    class Container = std::vector&lt;T&gt;,\n    class Compare = std::less&lt;typename Container::value_type&gt;\n&gt; class priority_queue;\n</code></pre> <p>\u4f18\u5148\u961f\u5217(\u5806)<code>priority_queue</code>\u662f\u4e00\u79cd\u5bb9\u5668\u9002\u914d\u5668(container adaptor)\uff0c\u5b83\u4ee5 \u5bf9\u6570 \u63d2\u5165\u548c\u63d0\u53d6\u4e3a\u5f00\u9500\uff0c\u63d0\u4f9b \u6700\u5927 (\u9ed8\u8ba4\u60c5\u51b5\u4e0b)\u5143\u7d20\u7684 \u5e38\u6570 \u65f6\u95f4\u67e5\u627e\u3002\u7528\u6237\u53ef\u4ee5\u63d0\u4f9b\u4e00\u4e2a<code>Compare</code>\u6765\u6539\u53d8\u6392\u5e8f\uff0c\u4f8b\u5982\uff0c\u4f7f\u7528<code>std::greater&lt;T&gt;</code>\u4f1a\u4f7f \u6700\u5c0f \u7684\u5143\u7d20\u663e\u793a\u4e3a<code>top()</code>\u3002</p> <p>\u4f7f\u7528<code>priority_queue</code>\u7c7b\u4f3c\u4e8e\u5728\u968f\u673a\u5b58\u53d6\u5bb9\u5668\u4e2d\u7ba1\u7406<code>heap</code>\uff0c\u597d\u5904\u662f\u4e0d\u4f1a\u610f\u5916\u5730\u4f7f<code>heap</code>\u5931\u6548\u3002</p> <p>\u6ce8\u610f<code>Container</code>\u6307\u7684\u662f\u7528\u4e8e\u5b58\u50a8\u5143\u7d20\u7684\u5e95\u5c42\u5bb9\u5668\u7c7b\u578b\uff0c\u6807\u51c6\u5bb9\u5668<code>std::vector</code>(\u5305\u62ec<code>std::vector&lt;bool&gt;</code>)\u548c<code>std::deque</code>\u53ef\u4ee5\u6ee1\u8db3\u8fd9\u4e9b\u8981\u6c42\u3002</p> <p><code>priority_queue</code>\u4f7f\u7528<code>std::make_heap</code>, <code>std::push_heap</code>, <code>std::pop_heap</code>\u51fd\u6570\u4f5c\u4e3a\u5e95\u5c42\u5b9e\u73b0\u3002</p> <p><code>priority_queue</code>\u652f\u6301\u64cd\u4f5c: <code>push()</code>, <code>top()</code>, <code>pop()</code>\u7b49\u3002</p> <p>\u6ce8\uff1a\u9ed8\u8ba4\u4e3a\u5927\u6839\u5806\uff0c\u5982\u679c\u60f3\u5f97\u5230\u5c0f\u6839\u5806\uff0c\u53ef\u4ee5\u63d2\u5165\u539f\u63d2\u5165\u6570\u7684\u8d1f\u6570(<code>h.push(-x)</code>)\uff0c\u6216\u662f\u76f4\u63a5\u5b9a\u4e49\u5c0f\u6839\u5806</p> <p>\u6ce8\uff1a<code>priority_queue</code>\u4e5f\u6ca1\u6709<code>clear()</code>\u51fd\u6570\uff01</p> <ul> <li><code>push()</code>: \u63d2\u5165\u4e00\u4e2a\u5143\u7d20</li> <li><code>top()</code>: \u8fd4\u56de\u5806\u9876\u5143\u7d20</li> <li><code>pop()</code>: \u5f39\u51fa\u5806\u9876\u5143\u7d20</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1apriority_queue</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#stack","title":"\u6808 (stack)","text":"<pre><code>template&lt;\n    class T,\n    class Container = std::deque&lt;T&gt;\n&gt; class stack;\n</code></pre> <p><code>std::stack</code>\u7c7b\u662f\u4e00\u4e2a\u5bb9\u5668\u9002\u914d\u5668(container adaptor)\uff0c\u5b83\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u5806\u6808\u7684\u529f\u80fd\uff0c\u7279\u522b\u662f\u540e\u8fdb\u5148\u51fa(LIFO)\u6570\u636e\u7ed3\u6784\u3002\u8be5\u7c7b\u6a21\u677f\u5145\u5f53\u5e95\u5c42\u5bb9\u5668\u7684\u5c01\u88c5\u5668\uff0c\u53ea\u63d0\u4f9b\u4e00\u7ec4\u7279\u5b9a\u7684\u51fd\u6570\u3002<code>stack</code>\u4ece\u5e95\u5c42\u5bb9\u5668\u7684\u540e\u90e8(\u5373\u5806\u6808\u9876\u90e8)\u63a8\u5165\u548c\u5f39\u51fa\u5143\u7d20\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6ca1\u6709\u4e3a\u7279\u5b9a<code>stack</code>\u5b9e\u4f8b\u5316\u6307\u5b9a\u5bb9\u5668(Container)\u7c7b\uff0c\u5c31\u4f1a\u4f7f\u7528\u6807\u51c6\u5bb9\u5668<code>std::deque</code>\u4f5c\u4e3a\u5e95\u5c42\u5bb9\u5668\u5b9e\u73b0(\u5176\u4ed6\u9009\u9879\u53ef\u80fd\u4e3a<code>std::vector</code>\u6216<code>std::list</code>)\u3002</p> <p><code>stack</code>\u652f\u6301\u64cd\u4f5c: <code>push()</code>, <code>top()</code>, <code>pop()</code>, <code>empty()</code>, <code>size()</code>\u7b49\u3002</p> <p>\u6ce8\uff1a<code>stack</code>\u4e5f\u6ca1\u6709<code>clear()</code>\u51fd\u6570\uff01</p> <ul> <li><code>push()</code>: \u5411\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u5143\u7d20</li> <li><code>top()</code>: \u8fd4\u56de\u6808\u9876\u5143\u7d20</li> <li><code>pop()</code>: \u5f39\u51fa\u6808\u9876\u5143\u7d20</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1astack</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#deque","title":"\u53cc\u7aef\u961f\u5217 (deque)","text":"<pre><code>template&lt;\n    class T,\n    class Allocator = std::allocator&lt;T&gt;\n&gt; class deque;\n</code></pre> <p><code>deque</code>: \u53cc\u7aef\u961f\u5217\uff0c\u961f\u5934\u961f\u5c3e\u5747\u53ef\u63d2\u5165\u548c\u5220\u9664\uff0c\u652f\u6301\u968f\u673a\u8bbf\u95ee\u6216\u5bfb\u5740\uff1b\u7c7b\u4f3c\u4e8e\u52a0\u5f3a\u7248\u7684<code>vector</code>\uff0c\u7f3a\u70b9\u662f\u901f\u5ea6\u6162\u3002</p> <p><code>std::deque</code>(\u53cc\u7aef\u961f\u5217\uff0cdouble-ended queue)\u662f\u4e00\u79cd\u7d22\u5f15\u5e8f\u5217\u5bb9\u5668\uff0c\u5141\u8bb8\u5728\u5176\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u3002\u6b64\u5916\uff0c\u5728<code>deque</code>\u7684\u4efb\u4f55\u4e00\u7aef\u63d2\u5165\u548c\u5220\u9664\u90fd\u4e0d\u4f1a\u4f7f\u6307\u5411\u5176\u4f59\u5143\u7d20\u7684\u6307\u9488\u6216\u5f15\u7528\u5931\u6548\u3002\u4e0e<code>std::vector</code>\u4e0d\u540c\u7684\u662f\uff0c<code>deque</code>\u7684\u5143\u7d20\u5e76 \u4e0d\u662f\u8fde\u7eed\u5b58\u50a8\u7684\uff1a\u5178\u578b\u7684\u5b9e\u73b0\u65b9\u6cd5\u662f\u4f7f\u7528\u4e00\u7cfb\u5217\u5355\u72ec\u5206\u914d\u7684\u56fa\u5b9a\u5927\u5c0f\u6570\u7ec4\uff0c\u5e76\u8fdb\u884c\u989d\u5916\u7684\u7c3f\u8bb0(bookkeeping)\uff0c\u8fd9\u610f\u5473\u7740\u5bf9<code>deque</code>\u7684\u7d22\u5f15\u8bbf\u95ee\u5fc5\u987b\u6267\u884c\u4e24\u6b21\u6307\u9488\u53cd\u5f15\u7528\uff0c\u800c<code>vector</code>\u7684\u7d22\u5f15\u8bbf\u95ee\u53ea\u9700\u6267\u884c\u4e00\u6b21\u3002</p> <p><code>deque</code>\u7684\u5b58\u50a8\u7a7a\u95f4\u4f1a\u6839\u636e\u9700\u8981\u81ea\u52a8\u6269\u5c55\u548c\u6536\u7f29\u3002<code>deque</code>\u7684\u6269\u5c55\u6bd4<code>std::vector</code>\u7684\u6269\u5c55\u6210\u672c \u4f4e\uff0c\u56e0\u4e3a\u5b83\u4e0d\u9700\u8981\u5c06\u73b0\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u7684\u5185\u5b58\u4f4d\u7f6e\u3002\u4f46\u53e6\u4e00\u65b9\u9762\uff0c<code>deque</code>\u901a\u5e38\u5177\u6709\u8f83\u5927\u7684\u6700\u5c0f\u5185\u5b58\u6210\u672c\uff1b\u4e00\u4e2a\u53ea\u5bb9\u7eb3\u4e00\u4e2a\u5143\u7d20\u7684<code>deque</code>\u9700\u8981\u5206\u914d\u5176\u6574\u4e2a\u5185\u90e8\u6570\u7ec4(\u4f8b\u5982\uff0c\u572864\u4f4d<code>libstdc++</code>\u4e0a\u662f\u5bf9\u8c61\u5927\u5c0f\u76848\u500d\uff1b\u572864\u4f4d<code>libc++</code>\u4e0a\u662f\u5bf9\u8c61\u5927\u5c0f\u768416\u500d\u62164096\u5b57\u8282\uff0c\u4ee5\u8f83\u5927\u8005\u4e3a\u51c6)\u3002</p> <p>\u5bf9<code>deque</code>\u8fdb\u884c\u5e38\u89c1\u64cd\u4f5c\u7684\u5f00\u9500\u5982\u4e0b\uff1a</p> <ul> <li>\u968f\u673a\u5b58\u53d6\uff1a\u5e38\u6570 \\(O(1)\\)</li> <li>\u5728\u7ed3\u5c3e\u6216\u5f00\u5934\u63d2\u5165\u6216\u79fb\u9664\u5143\u7d20\uff1a\u5e38\u6570 \\(O(1)\\)</li> <li>\u63d2\u5165\u6216\u5220\u9664\u5143\u7d20\uff1a\u7ebf\u6027 \\(O(n)\\)</li> </ul> <p>\u5e38\u89c1\u64cd\u4f5c\uff1a</p> <ul> <li><code>clear()</code>: \u6e05\u7a7a\u5143\u7d20</li> <li><code>front()</code>: </li> <li><code>back()</code>: </li> <li><code>push_back()</code>: </li> <li><code>pop_back()</code>: </li> <li><code>push_front()</code>: </li> <li><code>pop_front()</code>: </li> <li><code>begin()</code> \\ <code>end()</code>:</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1adeque</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#_2","title":"\u96c6\u5408\u548c\u6620\u5c04","text":"<p><code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code> \u5747\u662f Associative Container\uff0c\u57fa\u4e8e\u5e73\u8861\u4e8c\u53c9\u6811(\u7ea2\u9ed1\u6811)\u5b9e\u73b0\uff0c\u672c\u8d28\u662f\u52a8\u6001\u7ef4\u62a4\u6709\u5e8f\u5e8f\u5217</p> <p>\u901a\u7528\u64cd\u4f5c\uff1a</p> <ul> <li><code>clear()</code>: </li> <li><code>begin()</code> \\ <code>end()</code>: \u652f\u6301<code>++</code>\u548c<code>--</code>\u64cd\u4f5c(\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\) )\uff0c\u8fd4\u56de\u524d\u9a71\u548c\u540e\u7ee7</li> </ul>"},{"location":"zh/Data_Structures/Special_Topic_STL/#set-multiset","title":"\u96c6\u5408 (set, multiset)","text":"<pre><code>template&lt;\n    class Key,\n    class Compare = std::less&lt;Key&gt;,\n    class Allocator = std::allocator&lt;Key&gt;\n&gt; class set;\n</code></pre> <p><code>std::set</code>\u662f\u4e00\u4e2a\u5173\u8054\u5bb9\u5668\uff0c\u5b83\u5305\u542b\u4e00\u4e2a\u7531<code>Key</code>\u7c7b\u578b\u7684\u552f\u4e00\u5bf9\u8c61\u7ec4\u6210\u7684 \u6392\u5e8f \u96c6\u5408\u3002\u6392\u5e8f\u662f\u901a\u8fc7\u952e\u6bd4\u8f83\u51fd\u6570<code>Compare</code>\u5b8c\u6210\u7684\u3002\u641c\u7d22\u3001\u79fb\u9664\u548c\u63d2\u5165\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u4e3a\u5bf9\u6570\u3002<code>set</code>\u901a\u5e38\u4ee5\u7ea2\u9ed1\u6811\u7684\u5f62\u5f0f\u5b9e\u73b0\u3002\u6211\u4eec\u53ef\u4ee5\u5728\u6784\u5efa<code>set</code>\u5bf9\u8c61\u65f6\u4f20\u5165\u6392\u5e8f\u7684\u89c4\u5219\u3002</p> <pre><code>template&lt;\n    class Key,\n    class Compare = std::less&lt;Key&gt;,\n    class Allocator = std::allocator&lt;Key&gt;\n&gt; class multiset;\n</code></pre> <p><code>std::multiset</code>\u662f\u4e00\u4e2a\u5173\u8054\u5bb9\u5668\uff0c\u4f7f\u7528\u7ea2\u9ed1\u6811\u5b9e\u73b0\uff0c\u5b83\u5305\u542b\u4e00\u4e2a\u7531<code>Key</code>\u7c7b\u578b\u5bf9\u8c61\u7ec4\u6210\u7684 \u6392\u5e8f \u96c6\u5408\u3002\u4e0e<code>set</code>\u4e0d\u540c\uff0c\u5b83\u5141\u8bb8 \u591a\u4e2a \u5177\u6709\u76f8\u540c\u503c\u7684\u952e\u3002\u6392\u5e8f\u4f7f\u7528\u952e\u6bd4\u8f83\u51fd\u6570<code>Compare</code>\u5b8c\u6210\u3002\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u4e3a\u5bf9\u6570\u3002\u6211\u4eec\u540c\u6837\u53ef\u4ee5\u5728\u6784\u5efa<code>multiset</code>\u5bf9\u8c61\u65f6\u4f20\u5165\u6392\u5e8f\u7684\u89c4\u5219\u3002</p> <p><code>set</code> / <code>multiset</code>\u652f\u6301\uff1a</p> <ul> <li><code>insert()</code>: \u63d2\u5165\u4e00\u4e2a\u6570\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)</li> <li><code>find()</code>: \u67e5\u627e\u4e00\u4e2a\u6570</li> <li><code>count()</code>: \u8fd4\u56de\u67d0\u4e00\u4e2a\u6570\u7684\u4e2a\u6570(<code>set</code>\u91cc\u4ec5\u67090\u548c1\u4e24\u79cd\u60c5\u51b5)</li> <li><code>erase()</code>: \u82e5\u8f93\u5165\u662f\u4e00\u4e2a\u6570 \\(x\\) \uff0c\u5219\u5220\u9664\u6240\u6709 \\(x\\) \uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(k+\\log n)\\) \uff0c\u5176\u4e2d \\(k\\) \u4e3a \\(x\\) \u7684\u4e2a\u6570\uff1b\u82e5\u8f93\u5165\u662f\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u5219\u5220\u9664\u8fd9\u4e2a\u8fed\u4ee3\u5668</li> <li><code>lower_bound(const Key&amp; x)</code>(\u91cd\u8981): \u8fd4\u56de\u5927\u4e8e\u7b49\u4e8e \\(x\\) \u7684\u6700\u5c0f\u7684\u6570\u7684\u8fed\u4ee3\u5668\uff0c\u82e5\u4e0d\u5b58\u5728\u8fd4\u56de<code>end</code></li> <li><code>upper_bound(const Key&amp; x)</code>(\u91cd\u8981): \u8fd4\u56de\u5927\u4e8e \\(x\\) \u7684\u6700\u5c0f\u7684\u6570\u7684\u8fed\u4ee3\u5668\uff0c\u82e5\u4e0d\u5b58\u5728\u8fd4\u56de<code>end</code></li> </ul> <p>\u6ce8\uff1a<code>emplace</code>\u548c<code>insert</code>\u7684\u533a\u5206\uff1a</p> <ul> <li><code>insert</code>\u51fd\u6570\uff1a</li> <li>\u4f7f\u7528\u65b9\u6cd5\uff1a<code>insert</code>\u51fd\u6570\u7528\u4e8e\u5411\u5bb9\u5668\u4e2d\u6dfb\u52a0\u5143\u7d20\uff0c\u5b83\u53ef\u7528\u4e8e<code>vector</code>\u3001<code>list</code>\u548c<code>map</code>\u7b49\u5404\u79cd\u5bb9\u5668\uff1b</li> <li>\u5de5\u4f5c\u539f\u7406\uff1a\u4f7f\u7528<code>insert</code>\u65f6\uff0c\u9996\u5148\u6784\u9020\u5143\u7d20\uff0c\u7136\u540e\u5c06\u5176\u590d\u5236\u6216\u79fb\u52a8\u5230\u5bb9\u5668\u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u5143\u7d20\u5fc5\u987b\u6709\u4e00\u4e2a\u590d\u5236\u6216\u79fb\u52a8\u6784\u9020\u51fd\u6570\uff1b</li> <li>\u6548\u7387\uff1a\u4e0e<code>emplace</code>\u76f8\u6bd4\uff0c<code>insert</code>\u7684\u6548\u7387\u53ef\u80fd\u8f83\u4f4e\uff0c\u56e0\u4e3a\u5b83\u6d89\u53ca\u590d\u5236\u6216\u79fb\u52a8\u5bf9\u8c61\u3002</li> <li><code>emplace</code>\u51fd\u6570\uff1a</li> <li>\u4f7f\u7528\u65b9\u6cd5\uff1a\u5728C++11\u4e2d\u5f15\u5165\uff0c<code>emplace</code>\u51fd\u6570(<code>vector</code>\u8fd8\u6709<code>emplace_back</code>)\u901a\u8fc7\u5c31\u5730\u6784\u5efa\u7684\u65b9\u5f0f\u5411\u5bb9\u5668\u4e2d\u6dfb\u52a0\u65b0\u5143\u7d20\uff1b</li> <li>\u5de5\u4f5c\u539f\u7406\uff1a<code>emplace</code>\u76f4\u63a5\u5728\u5bb9\u5668\u4e2d\u6784\u9020\u5143\u7d20\uff0c\u8fd9\u662f\u901a\u8fc7\u5c06\u63d0\u4f9b\u7684\u53c2\u6570\u4f20\u7ed9\u5143\u7d20\u7684\u6784\u9020\u51fd\u6570\u6765\u5b9e\u73b0\u7684\uff1b</li> <li>\u6548\u7387\uff1a<code>emplace</code>\u6bd4<code>insert</code>\u66f4\u6709\u6548\u7387\uff0c\u5c24\u5176\u662f\u5bf9\u4e8e\u590d\u6742\u5bf9\u8c61\uff0c\u56e0\u4e3a\u5b83\u7701\u53bb\u4e86\u989d\u5916\u7684\u590d\u5236\u6216\u79fb\u52a8\u64cd\u4f5c\u3002\u5b83\u53ef\u4ee5\u5728\u5bb9\u5668\u4e2d\u9700\u8981\u7684\u4f4d\u7f6e\u6784\u9020\u5bf9\u8c61\u3002</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1ainsert\u548cemplace</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#map-multimap","title":"\u6620\u5c04 (map, multimap)","text":"<pre><code>template&lt;\n    class Key,\n    class T,\n    class Compare = std::less&lt;Key&gt;,\n    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;\n&gt; class map;\n</code></pre> <p><code>std::map</code>\u662f\u4e00\u4e2a\u5df2 \u6392\u5e8f \u7684\u5173\u8054\u5bb9\u5668\uff0c\u5b83\u5305\u542b\u5177\u6709 \u552f\u4e00\u952e \u7684\u952e\u503c\u5bf9\u3002\u952e\u503c\u901a\u8fc7\u6bd4\u8f83\u51fd\u6570<code>Compare</code>\u6392\u5e8f\u3002\u641c\u7d22\u3001\u79fb\u9664\u548c\u63d2\u5165\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u4e3a\u5bf9\u6570\u3002<code>map</code>\u901a\u5e38\u4ee5\u7ea2\u9ed1\u6811\u7684\u5f62\u5f0f\u5b9e\u73b0\u3002</p> <pre><code>template&lt;\n    class Key,\n    class T,\n    class Compare = std::less&lt;Key&gt;,\n    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;\n&gt; class multimap;\n</code></pre> <p><code>std::multimap</code>\u662f\u4e00\u4e2a\u5173\u8054\u5bb9\u5668\uff0c\u5305\u542b\u952e\u503c\u5bf9\u7684 \u6392\u5e8f \u5217\u8868\uff0c\u540c\u65f6\u5141\u8bb8 \u591a\u4e2a \u6761\u76ee\u5177\u6709\u76f8\u540c\u7684\u952e\u503c\u3002\u6392\u5e8f\u662f\u6839\u636e\u5e94\u7528\u4e8e\u952e\u7684\u6bd4\u8f83\u51fd\u6570<code>Compare</code>\u8fdb\u884c\u7684\u3002\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u4e3a\u5bf9\u6570\u3002</p> <p>\u6ce8\u610f\uff1a<code>multimap</code>\u6ca1\u6709\u50cf<code>map</code>\u90a3\u6837\u7684<code>at()</code>\u6216<code>[]</code>\u7684\u7d22\u5f15\u64cd\u4f5c\uff0c\u53ef\u8003\u8651\u4f7f\u7528<code>equal_range()</code>\uff01</p> <p><code>map</code> / <code>multimap</code>\u652f\u6301\uff1a</p> <ul> <li><code>insert()</code>: \u63d2\u5165\u7684\u6570\u662f\u4e00\u4e2a<code>pair</code></li> <li><code>erase()</code>: \u8f93\u5165\u7684\u53c2\u6570\u662f<code>pair</code>\u6216\u8fed\u4ee3\u5668</li> <li><code>find(const Key&amp; key)</code>: \u67e5\u627e\u952e\u503c\u4e0e<code>key</code>\u76f8\u540c\u7684\u5143\u7d20\u3002\u5bf9\u4e8e<code>multimap</code>\u800c\u8a00\uff0c\u5982\u679c\u5bb9\u5668\u4e2d\u6709\u591a\u4e2a\u5177\u6709<code>key</code>\u7684\u5143\u7d20\uff0c\u53ef\u4ee5\u8fd4\u56de\u5176\u4e2d\u4efb\u4f55\u4e00\u4e2a\uff1b</li> <li><code>[]</code>(\u91cd\u8981\uff0c\u4ec5<code>map</code>\u652f\u6301\uff0c<code>multimap</code>\u4e0d\u652f\u6301): \u50cf\u6570\u7ec4\u4e00\u6837\u7528<code>map</code>\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)</li> <li><code>lower_bound(const Key&amp; key)</code>: \u8fd4\u56de\u6307\u5411 \u4e0d\u5c0f\u4e8e (\u5373\u5927\u4e8e\u6216\u7b49\u4e8e)<code>key</code>\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u8fed\u4ee3\u5668\uff1b</li> <li><code>upper_bound(const Key&amp; key)</code>: \u8fd4\u56de\u6307\u5411 \u5927\u4e8e <code>key</code>\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u8fed\u4ee3\u5668\u3002</li> </ul> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1aset\u548cmap 1; set\u548cmap 2</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#_3","title":"\u54c8\u5e0c\u8868","text":"<p><code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code>: \u54c8\u5e0c\u8868</p> <p>\u548c\u4e0a\u9762\u7c7b\u4f3c(\u4e00\u4e00\u5bf9\u5e94)\uff0c\u597d\u5904\u662f\u589e\u5220\u6539\u67e5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) \uff0c\u4f46\u4e0d\u652f\u6301<code>lower_bound()</code>\u548c<code>upper_bound()</code>\uff0c\u4e5f\u4e0d\u652f\u6301\u8fed\u4ee3\u5668\u7684<code>++</code>\u548c<code>--</code>(\u51e1\u662f\u548c\u6392\u5e8f\u6709\u5173\u7684\u64cd\u4f5c\u90fd\u4e0d\u652f\u6301)\u3002</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#unordered_set","title":"unordered_set","text":"<pre><code>template&lt;\n    class Key,\n    class Hash = std::hash&lt;Key&gt;,\n    class KeyEqual = std::equal_to&lt;Key&gt;,\n    class Allocator = std::allocator&lt;Key&gt;\n&gt; class unordered_set;\n</code></pre> <p><code>std::unordered_set</code> \u662f\u4e00\u79cd\u5173\u8054\u5bb9\u5668\uff0c\u5305\u542b\u4e00\u7ec4\u7c7b\u578b\u4e3a<code>Key</code>\u7684\u552f\u4e00\u5bf9\u8c61\u3002\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u5e38\u6570\u3002</p> <p>\u5728\u5185\u90e8\uff0c\u5143\u7d20\u5e76\u6ca1\u6709\u6309\u7167\u7279\u5b9a\u987a\u5e8f\u6392\u5e8f\uff0c\u800c\u662f\u7ec4\u7ec7\u5230\u6876(buckets)\u4e2d\u3002\u5143\u7d20\u88ab\u653e\u5165\u54ea\u4e2a\u6876\u5b8c\u5168\u53d6\u51b3\u4e8e\u5176\u503c\u7684\u54c8\u5e0c\u3002\u8fd9\u5141\u8bb8\u4ee5 \u5e38\u6570 \u65f6\u95f4\u590d\u6742\u5ea6\u5feb\u901f\u8bbf\u95ee\u5355\u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u4e00\u65e6\u8ba1\u7b97\u51fa\u54c8\u5e0c\uff0c\u5b83\u5c31\u6307\u5411\u5143\u7d20\u6240\u5728\u7684\u786e\u5207\u6876\u3002</p> <p>\u7531\u4e8e\u4fee\u6539\u53ef\u80fd\u4f1a\u6539\u53d8\u5143\u7d20\u7684\u54c8\u5e0c\u5e76\u635f\u574f\u5bb9\u5668\uff0c\u56e0\u6b64<code>unordered_set</code>\u4e0d\u5141\u8bb8\u4fee\u6539\u5bb9\u5668\u5143\u7d20 (\u5373\u4f7f\u662f\u975e<code>const</code>\u8fed\u4ee3\u5668\u4e5f\u4e0d\u884c)\u3002</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#unordered_multiset","title":"unordered_multiset","text":"<pre><code>template&lt;\n    class Key,\n    class Hash = std::hash&lt;Key&gt;,\n    class KeyEqual = std::equal_to&lt;Key&gt;,\n    class Allocator = std::allocator&lt;Key&gt;\n&gt; class unordered_multiset;\n</code></pre> <p><code>std::unordered_multiset</code> \u662f\u4e00\u79cd\u5173\u8054\u5bb9\u5668\uff0c\u5305\u542b\u53ef\u80fd\u975e\u552f\u4e00\u7684\u7c7b\u578b\u4e3a<code>Key</code>\u7684\u5bf9\u8c61\u96c6\u5408\u3002\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u5e38\u6570\u3002</p> <p>\u5728\u5185\u90e8\uff0c\u5143\u7d20\u5e76\u6ca1\u6709\u6309\u7167\u7279\u5b9a\u987a\u5e8f\u6392\u5e8f\uff0c\u800c\u662f\u7ec4\u7ec7\u5230\u6876\u4e2d\u3002\u5143\u7d20\u88ab\u653e\u5165\u54ea\u4e2a\u6876\u5b8c\u5168\u53d6\u51b3\u4e8e\u5176\u503c\u7684\u54c8\u5e0c\u3002\u8fd9\u5141\u8bb8\u5feb\u901f\u8bbf\u95ee\u5355\u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u4e00\u65e6\u8ba1\u7b97\u51fa\u54c8\u5e0c\uff0c\u5b83\u5c31\u6307\u5411\u5143\u7d20\u6240\u5728\u7684\u786e\u5207\u6876\u3002</p> <p>\u6b64\u5bb9\u5668\u7684\u8fed\u4ee3\u987a\u5e8f\u4e0d\u8981\u6c42\u7a33\u5b9a(\u56e0\u6b64\uff0c\u4f8b\u5982\uff0c\u4e0d\u80fd\u4f7f\u7528 <code>std::equal</code> \u6765\u6bd4\u8f83\u4e24\u4e2a <code>std::unordered_multiset</code>)\uff0c\u9664\u975e\u6bcf\u7ec4\u952e\u76f8\u7b49\u7684\u5143\u7d20\uff08\u4f7f\u7528 <code>key_eq()</code> \u4f5c\u4e3a\u6bd4\u8f83\u5668\u65f6\u6bd4\u8f83\u76f8\u7b49\uff09\u5728\u8fed\u4ee3\u987a\u5e8f\u4e2d\u5f62\u6210\u4e00\u4e2a\u8fde\u7eed\u7684\u5b50\u8303\u56f4\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>equal_range()</code> \u8bbf\u95ee\u3002</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1a\u54c8\u5e0c</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#unordered_map","title":"unordered_map","text":"<p><code>std::unordered_map</code> \u662f\u4e00\u79cd\u5173\u8054\u5bb9\u5668\uff0c\u5305\u542b\u5177\u6709\u552f\u4e00\u952e\u7684\u952e\u503c\u5bf9\u3002\u5143\u7d20\u7684\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \u5e38\u6570\u3002</p> <p>\u5728\u5185\u90e8\uff0c\u5143\u7d20\u5e76\u6ca1\u6709\u6309\u7167\u7279\u5b9a\u987a\u5e8f\u6392\u5e8f\uff0c\u800c\u662f\u7ec4\u7ec7\u5230\u6876\u4e2d\u3002\u5143\u7d20\u88ab\u653e\u5165\u54ea\u4e2a\u6876\u5b8c\u5168\u53d6\u51b3\u4e8e\u5176\u952e\u7684\u54c8\u5e0c\u3002\u62e5\u6709\u76f8\u540c\u54c8\u5e0c\u7801\u7684\u952e\u51fa\u73b0\u5728\u540c\u4e00\u4e2a\u6876\u4e2d\u3002\u8fd9\u5141\u8bb8\u5feb\u901f\u8bbf\u95ee\u5355\u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u4e00\u65e6\u8ba1\u7b97\u51fa\u54c8\u5e0c\uff0c\u5b83\u5c31\u6307\u5411\u5143\u7d20\u6240\u5728\u7684\u786e\u5207\u6876\u3002</p> <p>\u5982\u679c\u6620\u5c04\u7684\u952e\u7b49\u4ef7\u6027\u8c13\u8bcd(key equality predicate)\u5728\u4f20\u5165\u8fd9\u4e9b\u952e\u65f6\u8fd4\u56de\u771f\uff0c\u5219\u8ba4\u4e3a\u4e24\u4e2a\u952e\u662f\u7b49\u4ef7\u7684\u3002\u5982\u679c\u4e24\u4e2a\u952e\u662f\u7b49\u4ef7\u7684\uff0c\u54c8\u5e0c\u51fd\u6570\u5fc5\u987b\u4e3a\u8fd9\u4e24\u4e2a\u952e\u8fd4\u56de\u76f8\u540c\u7684\u503c\u3002</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#unordered_multimap","title":"unordered_multimap","text":"<p><code>std::unordered_multimap</code> \u662f\u4e00\u79cd\u65e0\u5e8f\u5173\u8054\u5bb9\u5668\uff0c\u652f\u6301\u7b49\u4ef7\u952e\uff08\u4e00\u4e2a <code>unordered_multimap</code> \u53ef\u4ee5\u5305\u542b\u6bcf\u4e2a\u952e\u503c\u7684\u591a\u4e2a\u526f\u672c\uff09\uff0c\u5e76\u5c06\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u503c\u4e0e\u952e\u76f8\u5173\u8054\u3002<code>unordered_multimap</code> \u7c7b\u652f\u6301\u524d\u5411\u8fed\u4ee3\u5668\u3002\u641c\u7d22\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \u5e38\u6570\u3002</p> <p>\u5728\u5185\u90e8\uff0c\u5143\u7d20\u5e76\u6ca1\u6709\u6309\u7167\u7279\u5b9a\u987a\u5e8f\u6392\u5e8f\uff0c\u800c\u662f\u7ec4\u7ec7\u5230\u6876\u4e2d\u3002\u5143\u7d20\u88ab\u653e\u5165\u54ea\u4e2a\u6876\u5b8c\u5168\u53d6\u51b3\u4e8e\u5176\u952e\u7684\u54c8\u5e0c\u3002\u8fd9\u5141\u8bb8\u5feb\u901f\u8bbf\u95ee\u5355\u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u4e00\u65e6\u8ba1\u7b97\u51fa\u54c8\u5e0c\uff0c\u5b83\u5c31\u6307\u5411\u5143\u7d20\u6240\u5728\u7684\u786e\u5207\u6876\u3002</p> <p>\u6b64\u5bb9\u5668\u7684\u8fed\u4ee3\u987a\u5e8f\u4e0d\u8981\u6c42\u7a33\u5b9a(\u56e0\u6b64\uff0c\u4f8b\u5982\uff0c\u4e0d\u80fd\u4f7f\u7528 <code>std::equal</code> \u6765\u6bd4\u8f83\u4e24\u4e2a <code>std::unordered_multimaps</code>)\uff0c\u9664\u975e\u6bcf\u7ec4\u952e\u76f8\u7b49\u7684\u5143\u7d20(\u4f7f\u7528 <code>key_eq()</code> \u4f5c\u4e3a\u6bd4\u8f83\u5668\u65f6\u6bd4\u8f83\u76f8\u7b49)\u5728\u8fed\u4ee3\u987a\u5e8f\u4e2d\u5f62\u6210\u4e00\u4e2a\u8fde\u7eed\u7684\u5b50\u8303\u56f4\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>equal_range()</code> \u8bbf\u95ee\u3002</p> <p>\u6d4b\u8bd5\u4ee3\u7801\uff1a\u54c8\u5e0c</p>"},{"location":"zh/Data_Structures/Special_Topic_STL/#bitset","title":"\u4f4d\u96c6 (bitset)","text":"<p><code>bitset</code>: \u538b\u4f4d</p> <p>\u652f\u6301<code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>!=</code> \u7b49\u64cd\u4f5c\uff0c\u4e5f\u652f\u6301<code>[]</code>\u64cd\u4f5c\u7b26</p> <ul> <li><code>count()</code>: \u8fd4\u56de\u6709\u591a\u5c11\u4e2a1</li> <li><code>any()</code>: \u5224\u65ad\u662f\u5426\u81f3\u5c11\u6709\u4e00\u4e2a1</li> <li><code>none()</code>: \u5224\u65ad\u662f\u5426\u5168\u4e3a0</li> <li><code>set()</code>: \u628a\u6240\u6709\u4f4d\u7f6e\u62101</li> <li><code>set(k, v)</code>: \u5c06\u7b2c<code>k</code>\u4f4d\u53d8\u4e3a<code>v</code></li> <li><code>reset()</code>: \u628a\u6240\u6709\u4f4d\u53d8\u62100</li> <li><code>flip()</code>: \u7b49\u4ef7\u4e8e<code>~</code></li> <li><code>flip(k)</code>: \u628a\u7b2c<code>k</code>\u4f4d\u53d6\u53cd</li> </ul>"},{"location":"zh/Dynamic_Programming/","title":"\u52a8\u6001\u89c4\u5212","text":""},{"location":"zh/Dynamic_Programming/01_Backpack_Problem/","title":"\u80cc\u5305\u95ee\u9898","text":"<p>\u603b\u4efb\u52a1\uff1a\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u88c5\u5165\u80cc\u5305\uff0c\u53ef\u4f7f\u8fd9\u4e9b\u7269\u54c1\u7684\u603b\u4f53\u79ef\u4e0d\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u4e14\u603b\u4ef7\u503c\u6700\u5927\u3002</p> <p>\u52a8\u6001\u89c4\u5212\u95ee\u9898\u4e00\u822c\u6ca1\u6709\u7b97\u6cd5\u6a21\u677f\u3002</p>"},{"location":"zh/Dynamic_Programming/01_Backpack_Problem/#0-1","title":"0-1\u80cc\u5305\u95ee\u9898","text":"<p>\u6761\u4ef6\uff1a\u6709 \\(N\\) \u4ef6\u7269\u54c1\u548c\u4e00\u4e2a\u5bb9\u91cf\u662f \\(V\\) \u7684\u80cc\u5305\u3002\u6bcf\u4ef6\u7269\u54c1\u6700\u591a\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u3002\u7b2c \\(i\\) \u4ef6\u7269\u54c1\u7684\u4f53\u79ef\u662f \\(v_i\\)\uff0c\u4ef7\u503c\u662f \\(w_i\\)\u3002</p> <p>\u4f8b\u9898\uff1a01\u80cc\u5305\u95ee\u9898\u7684\u6734\u7d20\u89e3\u6cd5</p> <p>\u6700\u5927\u4ef7\u503c\u662f\u7269\u54c1\u6570\u91cf \\(i\\) \u548c\u80cc\u5305\u5bb9\u91cf \\(j\\) \u7684\u51fd\u6570\uff0c\u8bbe\u51fd\u6570 \\(f(i,j)\\) \u8868\u793a\u524d \\(i\\) \u4ef6\u7269\u54c1\u653e\u5165\u5bb9\u91cf\u4e3a \\(j\\) \u7684\u80cc\u5305\u7684\u6700\u5927\u4ef7\u503c\uff0c\u6700\u7ec8\u7684\u6700\u5927\u4ef7\u503c\u5c31\u662f\u7269\u54c1\u6570\u91cf \\(i\\) \u4ece \\(0\\) \u589e\u957f\u5230 \\(N\\)\uff0c\u80cc\u5305\u5bb9\u91cf \\(j\\) \u4ece \\(0\\) \u589e\u957f\u5230 \\(V\\) \u65f6\u7684 \\(f(N,V)\\) \u503c\u3002</p> <p>\u52a8\u6001\u89c4\u5212 \\(D_p\\) \u5e38\u7528\u5982\u4e0b\u6a21\u578b\u8fdb\u884c\u5206\u6790\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f(i,j)\\) \u662f\u524d \\(i\\) \u4e2a\u7269\u54c1\uff0c\u80cc\u5305\u5bb9\u91cf \\(j\\) \u4e0b\u7684\u6700\u4f18\u89e3(\u6700\u5927\u4ef7\u503c)\uff1a<ul> <li>\u96c6\u5408\uff1a\u662f\u6240\u6709\u9009\u6cd5\u7684\u96c6\u5408\uff0c\u9700\u8981\u6ee1\u8db3\u5982\u4e0b\u4e24\u4e2a\u6761\u4ef6\uff1a<ul> <li>\u53ea\u4ece\u524d \\(i\\) \u4e2a\u7269\u54c1\u5f53\u4e2d\u9009\uff1b</li> <li>\u9009\u51fa\u7269\u54c1\u7684\u603b\u4f53\u79ef \\(\\leqslant j\\)\u3002</li> </ul> </li> <li>\u5c5e\u6027\uff1a\u662f\u4e00\u4e2a\u6570\u503c\uff0c\u4e00\u822c\u4ee3\u8868\u6240\u6709\u9009\u6cd5\u603b\u4ef7\u503c\u7684\u6700\u5927\u503c \\(\\mu _{\\max}\\)\uff0c\u6700\u5c0f\u503c \\(\\mu _{\\min}\\)\uff0c\u6216\u5143\u7d20\u6570\u91cf\u7b49(\u672c\u9898\u4e3a\u6700\u5927\u503c)\u3002</li> </ul> </li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u6700\u7ec8\u7b54\u6848\u662f \\(f(N,V)\\)\uff0c\u4e00\u822c\u5bf9\u5e94\u96c6\u5408\u7684\u5212\u5206\u3002\u672c\u95ee\u9898\u53ef\u5c06\u96c6\u5408\u5212\u5206\u4e3a\u4ece\u7269\u54c1 \\(1\\) \u5230 \\(i-1\\) \u4e2d\u9009\u62e9\u7684\u603b\u4f53\u79ef\u4e0d\u8d85\u8fc7 \\(j\\) \u7684\u4e0d\u542b \\(i\\) \u7684\u96c6\u5408( \\(f(i-1,j)\\) )\u4ee5\u53ca\u7269\u54c1\u542b \\(i\\) \u7684\u96c6\u5408( \\(f(i-1,j-v_i)+w_i\\) )\uff0c\u5171\u4e24\u4e2a\u5b50\u96c6\uff1b\u96c6\u5408\u5212\u5206\u9700\u6ee1\u8db3\u5982\u4e0b\u539f\u5219\uff1a<ul> <li>\u4e0d\u91cd\uff1a\u4e00\u822c\u8981\u6ee1\u8db3\uff1b</li> <li>\u4e0d\u6f0f\uff1a\u5fc5\u987b\u8981\u6ee1\u8db3\u3002</li> </ul> </li> </ul> <p>\u6ce8\u610f\u4ee5\u4e0a\u201c\u542b \\(i\\) \u7684\u96c6\u5408\u201d\u6307\u7684\u662f\u4ece\u7269\u54c1 \\(1\\) \u5230 \\(i-1\\) \u4e2d\u9009\u62e9\u7684\u603b\u4f53\u79ef\u4e0d\u8d85\u8fc7 \\(j-v_i\\) \u7684\u9009\u6cd5\u7684\u96c6\u5408\uff0c\u4e5f\u5c31\u662f \\(f(i-1,j-v_i)+w_i\\)\u3002</p> <p>\u53ef\u4ee5\u5f97\u5230\uff1a</p> \\[ f\\left( i,j \\right) =\\max [ f\\left( i-1,j \\right) , f\\left( i-1,j-v_i \\right) +w_i ] \\] <p>\u8fdb\u4e00\u6b65\u5199\u51fa\u5b8c\u6574\u7684\u9012\u63a8\u5f0f\uff1a</p> \\[ f\\left( i,j \\right) =\\begin{cases}     f\\left( i-1,j \\right) , j &lt; v\\left[ i \\right]\\\\     \\max \\left[ f\\left( i-1,j \\right) , f\\left( i-1,j-v\\left[ i \\right] \\right) +w\\left[ i \\right] \\right] , j\\geqslant v\\left[ i \\right]\\\\ \\end{cases} \\] <p>\u5176\u4e2d \\(f\\left( i,0 \\right) =0; \\left( 1\\leqslant i\\leqslant N \\right)\\)\uff0c\u4e14 \\(f\\left( 0,j \\right) =0; \\left( 1\\leqslant j\\leqslant V \\right)\\)\uff0c\u53ef\u89c1 \\(f(i,j)\\) \u5e94\u8be5\u5168 \\(0\\) \u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u58f0\u660e\u4e3a\u5168\u5c40\u53d8\u91cf\u3002</p> <p>\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {  // \u7269\u54c1i\n    for (int j = 1; j &lt;= m; j++) {  // \u5bb9\u91cfj\n        if (j &lt; v[i]) f[i][j] = f[i - 1][j];\n        else\n            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);\n    }\n}\ncout &lt;&lt; f[n][m] &lt;&lt; endl;\n</code></pre> <p>\u65f6\u95f4\u548c\u7a7a\u95f4\u590d\u6742\u5ea6\u5747\u4e3a \\(O(N\\cdot V)\\)\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u80fd\u964d\u4f4e\u4e86\uff0c\u4f46\u7a7a\u95f4\u590d\u6742\u5ea6\u8fd8\u53ef\u4ee5\u964d\u4e3a\u4e00\u7ef4\u3002\u662f\u5426\u53ef\u4ee5\u7528\u4e00\u7ef4\u6570\u7ec4<code>f[j]</code>\u53ea\u8bb0\u5f55\u4e00\u884c\u6570\u636e\uff0c\u8ba9 \\(j\\) \u503c\u987a\u5e8f\u5faa\u73af\uff0c\u987a\u5e8f\u66f4\u65b0<code>f[j]</code>\u5462\uff1f\u7b54\u6848\u662f\u4e0d\u884c\uff0c\u56e0\u4e3a\u5982\u679c \\(j\\) \u662f\u987a\u5e8f\u5faa\u73af\uff0c<code>f[j - v[i]]</code>\u4f1a\u5148\u4e8e<code>f[j]</code>\u66f4\u65b0\uff0c\u5373\u7528\u65b0\u503c<code>f[j - v[i]]</code>\u53bb\u66f4\u65b0<code>f[j]</code>\u4f1a\u51fa\u9519\u3002</p> <p>\\(D_p\\) \u4f18\u5316\u6307\u7684\u662f\u5bf9\u5df2\u6709 \\(D_p\\) \u7684\u4ee3\u7801\u3001\u65b9\u7a0b\u8fdb\u884c\u4f18\u5316\u3002</p> <p>\u4f8b\u9898\uff1a01\u80cc\u5305\u95ee\u9898\u7684\u4e00\u7ef4\u4f18\u5316</p> <p>\u5c06\u72b6\u6001<code>f[i][j]</code>\u4f18\u5316\u5230\u4e00\u7ef4<code>f[j]</code>\uff0c\u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u505a\u4e00\u4e2a\u7b49\u4ef7\u53d8\u5f62\u3002\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u8fd9\u6837\u53d8\u5f62\u5462\uff1f\u6211\u4eec\u5b9a\u4e49\u7684\u72b6\u6001<code>f[i][j]</code>\u53ef\u4ee5\u6c42\u5f97\u4efb\u610f\u5408\u6cd5\u7684 \\(i\\) \u4e0e \\(j\\) \u6700\u4f18\u89e3\uff0c\u4f46\u9898\u76ee\u53ea\u9700\u8981\u6c42\u5f97\u6700\u7ec8\u72b6\u6001<code>f[n][m]</code>\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u4e00\u7ef4\u7684\u7a7a\u95f4\u6765\u66f4\u65b0\u72b6\u6001\u3002</p> <p>\u72b6\u6001<code>f[j]$</code>\u5b9a\u4e49\uff1a \\(N\\) \u4ef6\u7269\u54c1\uff0c\u80cc\u5305\u5bb9\u91cf \\(j\\) \u4e0b\u7684\u6700\u4f18\u89e3\u3002\u6ce8\u610f\u679a\u4e3e\u80cc\u5305\u5bb9\u91cf \\(j\\) \u5fc5\u987b\u4ece \\(m\\) \u5f00\u59cb\u3002\u7528\u4e00\u7ef4\u6570\u7ec4<code>f[j]</code>\u53ea\u8bb0\u5f55\u4e00\u884c\u6570\u636e\uff0c\u8ba9 \\(j\\) \u503c\u9006\u5e8f\u5faa\u73af\uff0c\u9006\u5e8f\u66f4\u65b0<code>f[j]</code>\u7684\u503c\u3002<code>f[j]</code>\u79f0\u4e3a\u6eda\u52a8\u6570\u7ec4\u3002\u56e0\u4e3a \\(j\\) \u662f\u9006\u5e8f\u5faa\u73af\uff0c<code>f[j]</code>\u4f1a\u5148\u4e8e<code>f[j-w[i]]</code>\u66f4\u65b0\uff0c\u5373\u7528\u65e7\u503c<code>f[j-w[i]]</code>\u53bb\u66f4\u65b0<code>f[j]</code>\uff0c\u624d\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u7ed3\u679c\u3002</p> <p>\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = m; j &gt;= 1; j--) {  // \u8fd9\u91cc\u662f\u9006\u5e8f\u5faa\u73af\n        if (j &lt; v[i]) f[j] = f[j];\n        else f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n}\n</code></pre> <p>\u8fd9\u4e2a\u89c6\u9891 \u8bb2\u89e3\u8f83\u597d\u3002</p>"},{"location":"zh/Dynamic_Programming/01_Backpack_Problem/#_2","title":"\u5b8c\u5168\u80cc\u5305\u95ee\u9898","text":"<p>\u6761\u4ef6\uff1a\u6709 \\(N\\) \u4e2a\u7269\u54c1\u548c\u4e00\u4e2a\u5bb9\u91cf\u662f \\(V\\) \u7684\u80cc\u5305\u3002\u6bcf\u4e2a\u7269\u54c1\u90fd\u6709\u65e0\u9650\u4ef6\u53ef\u7528\u3002\u7b2c \\(i\\) \u4e2a\u7269\u54c1\u7684\u4f53\u79ef\u662f \\(v_i\\)\uff0c\u4ef7\u503c\u662f \\(w_i\\)\u3002</p> <p>\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a<ul> <li>\u96c6\u5408\uff1a \\(f(i,j)\\)\u8868\u793a\u8003\u8651\u524d \\(i\\) \u4e2a\u7269\u54c1\u4e14\u603b\u4f53\u79ef\u4e0d\u5927\u4e8e \\(j\\) \u7684\u6240\u6709\u9009\u6cd5\uff1b</li> <li>\u5c5e\u6027\uff1a\u6240\u6709\u9009\u6cd5\u7684\u6700\u5927\u4ef7\u503c\u3002</li> </ul> </li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u96c6\u5408\u7684\u5212\u5206\uff0c\u6309\u7167\u7b2c \\(i\\) \u4e2a\u7269\u54c1\u9009\u4e86\u591a\u5c11\u4e2a\u53ef\u4ee5\u5206\u4e3a\u82e5\u5e72\u7ec4\uff0c\u8bbe\u7b2c \\(i\\) \u4e2a\u7269\u54c1\u9009\u4e86 \\(k\\) \u4ef6\uff0c\u53ef\u6309\u5982\u4e0b\u6b65\u9aa4\u8fdb\u884c\u8ba1\u7b97\uff1a<ul> <li>\u53bb\u6389 \\(k\\) \u4ef6\u7269\u54c1 \\(i\\)\uff1b</li> <li>\u6c42\u6700\u5927\u503c\uff1a \\(f(i-1,j-k\\cdot v[i])\\)\uff1b</li> <li>\u518d\u52a0\u56de\u6765 \\(k\\) \u4ef6\u7269\u54c1 \\(i\\)\u3002</li> </ul> </li> </ul> <p>\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a</p> \\[ f\\left( i,j \\right) =\\max [ f\\left( i,j \\right) , f\\left( i-1, j-k\\cdot v\\left[ i \\right] \\right) +k\\cdot w\\left[ i \\right] ] \\] <p>\u66f4\u5b8c\u6574\u5730\uff0c\u8bbe\u7b2c \\(i\\) \u79cd\u7269\u54c1\u6700\u591a\u80fd\u9009 \\(t\\) \u4e2a\uff0c\u53ef\u77e5 \\(t=\\lfloor \\frac{j}{v\\left[ i \\right]} \\rfloor\\)\uff0c\u5176\u4e2d \\(j\\)\u4e3a\u5f53\u524d\u5bb9\u91cf\uff0c\u5219\u53ef\u5f97\u5b8c\u6574\u9012\u63a8\u5f0f\uff1a</p> \\[ f\\left( i,j \\right) =\\max_{0\\leqslant k\\leqslant t} f\\left( i-1, j-k\\cdot v\\left[ i \\right] \\right) +k\\cdot w\\left[ i \\right]  \\] <p>\u4f8b\u9898\uff1a\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u6734\u7d20\u89e3\u6cd5</p> <p>\u6734\u7d20\u89e3\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O\\left( V^2N \\right)\\)\u3002</p> <p>\u4e3a\u4e86\u4f18\u5316\u6734\u7d20\u89e3\u6cd5\uff0c\u53ef\u4ee5\u89c2\u5bdf\u539f\u9012\u63a8\u65b9\u7a0b\uff1a</p> \\[ f\\left( i,j-v\\left[ i \\right] \\right) =\\max\\mathrm{[}f\\left( i-1,j-v\\left[ i \\right] \\right) ,f\\left( j-1,j-2\\cdot v\\left[ i \\right] \\right) +w\\left[ i \\right] , \\] \\[ f\\left( j-1,j-3\\cdot v\\left[ i \\right] \\right) +2\\cdot w\\left[ i \\right] ,\\cdots ]; \\] \\[ f\\left( i,j \\right) =\\max\\mathrm{[}f\\left( i-1,j \\right) ,f\\left( i-1,j-v\\left[ i \\right] \\right) +w\\left[ i \\right] , \\] \\[ f\\left( j-1,j-2\\cdot v\\left[ i \\right] \\right) +2\\cdot w\\left[ i \\right] ,f\\left( j-1,j-3\\cdot v\\left[ i \\right] \\right) +3\\cdot w\\left[ i \\right] ,\\cdots ] \\] \\[ =\\max\\mathrm{[}f\\left( i-1,j \\right) ,f\\left( i,j-v\\left[ i \\right] \\right) +w\\left[ i \\right] ] \\] <p>\u7b80\u5316\u5f97\uff1a</p> \\[ f\\left( i,j \\right) =\\max\\mathrm{[}f\\left( i-1,j \\right) ,f\\left( i,j-v\\left[ i \\right] \\right) +w\\left[ i \\right] ] \\] <p>\u8fd9\u79cd\u9012\u63a8\u4f18\u5316\u7684\u89e3\u6cd5\u5c31\u4e0d\u7528\u518d\u679a\u4e3e \\(k\\) \u91cd\u5faa\u73af\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(NV)\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u9012\u63a8\u4f18\u5316</p> <p>\u53e6\u4e00\u79cd\u89c6\u89d2\uff1a</p> <p>\u5f53\u524d\u80cc\u5305\u5bb9\u91cf\u4e3a \\(j\\)\uff0c\u8981\u8003\u8651\u7b2c \\(i\\) \u4ef6\u7269\u54c1\u80fd\u5426\u653e\u5165\uff0c\u662f\u5426\u653e\u5165\u3002</p> <ul> <li>\u5f53\u524d\u80cc\u5305\u5bb9\u91cf \\(j&lt;v[i]\\)\uff0c\u4e0d\u80fd\u653e\u5165\uff0c\u5219 \\(f(i,j)=f(i-1,j)\\)\uff1b</li> <li>\u5f53\u524d\u80cc\u5305\u5bb9\u91cf \\(j\\geqslant v[i]\\)\uff0c\u80fd\u653e\u5165\uff0c\u4f46\u8981\u6bd4\u8f83\u4ee3\u4ef7\uff1a<ul> <li>\u82e5\u7b2c \\(i\\) \u4ef6\u7269\u54c1\u4e0d\u653e\u5165\u80cc\u5305\uff0c\u5219 \\(f(i,j)=f(i-1,j)\\)\uff1b</li> <li>\u82e5\u7b2c \\(i\\) \u4ef6\u7269\u54c1\u653e\u5165\u80cc\u5305\uff0c\u5219 \\(f(i,j)=f(i,j-v[i])+w[i]\\)\u3002</li> </ul> </li> </ul> <p>\u89e3\u91ca\uff1a\u5bf9\u4e8e\u524d \\(i\\) \u4ef6\u7269\u54c1\uff0c\u80cc\u5305\u5bb9\u91cf\u4e3a \\(j-v[i]\\) \u65f6\u53ef\u80fd\u5df2\u7ecf\u653e\u5165\u4e86\u7b2c \\(i\\) \u4ef6\u7269\u54c1\uff0c\u5bb9\u91cf\u4e3a \\(j\\) \u65f6\u8fd8\u53ef\u4ee5\u518d\u653e\u5165\u7b2c \\(i\\) \u4ef6\u7269\u54c1\uff0c\u6240\u4ee5\u7528 \\(f(i,j-v[i])\\) \u66f4\u65b0 \\(f(i,j)\\) (\u6ce8\u610f\u8fd9\u91cc\u4e0e0-1\u80cc\u5305\u7684\u4e0d\u540c)\u3002</p> <p>\u7efc\u4e0a\uff1a</p> \\[ f\\left( i,j \\right) =\\begin{cases}     f\\left( i-1,j \\right) ,j&lt;v\\left[ i \\right] ;\\\\     \\max \\left[ f\\left( i-1,j \\right) ,f\\left( i,j-v\\left[ i \\right] \\right) +w\\left[ i \\right] \\right] ,j\\geqslant v\\left[ i \\right]\\\\ \\end{cases} \\] <p>\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {  // \u7269\u54c1i\n    for (int j = 1; j &lt;= m; j++) {  // \u5bb9\u91cfj\n        if (j &lt; v[i]) f[i][j] = f[i - 1][j];\n        else\n            f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);\n    }\n}\ncout &lt;&lt; f[n][m] &lt;&lt; endl;\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u4e5f\u53ef\u4ee5\u4f18\u5316\u5230\u4e00\u7ef4\u7a7a\u95f4\u590d\u6742\u5ea6\u3002\u4e0a\u5f0f\u5bf9\u5e94\u7684\u662f \\(j\\) \u4ece\u5c0f\u5230\u5927\u904d\u5386\uff0c\u4e8e\u662f\u6211\u4eec\u53ea\u9700\u628a0-1\u80cc\u5305\u95ee\u9898\u7684\u4ee3\u7801\u4e2d\u7684 \\(j\\) \u6539\u4e3a\u4ece\u5c0f\u5230\u5927\u904d\u5386\u5373\u53ef\u3002\u4e0d\u7528\u7531\u5927\u5230\u5c0f\u904d\u5386\uff0c\u56e0\u4e3a\u8981\u7684\u5c31\u662f\u8986\u76d6\u7684\u6548\u679c\uff01</p> <p>\u4f8b\u9898\uff1a\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u4e00\u7ef4\u4f18\u5316</p> <p>\u4e00\u7ef4\u4f18\u5316\u89e3\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u53d8\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u964d\u4e3a \\(O(V)\\)\u3002</p> <p>\u6ce8\u610f\u8fd9\u91cc\u5b8c\u5168\u80cc\u5305\u7684<code>j</code>\u7684\u5faa\u73af\u987a\u5e8f\u548c0-1\u80cc\u5305\u4e0d\u540c\u3002\u56e0\u4e3a<code>j</code>\u662f\u987a\u5e8f\u5faa\u73af\uff0c<code>f[j-v[i]]</code>\u4f1a\u5148\u4e8e<code>f[j]</code>\u66f4\u65b0\uff0c\u4e5f\u5c31\u662f\u8bf4\u7528\u65b0\u503c<code>f[j-v[i]]</code>\u53bb\u66f4\u65b0<code>f[j]</code>\uff0c\u76f8\u5f53\u4e8e\u7528\u7b2c<code>i</code>\u884c\u7684<code>f[j-v[i]]</code>\u503c\u66f4\u65b0<code>f[j]</code>\uff0c\u6240\u4ee5\u53ef\u4ee5\u987a\u5e8f\u5faa\u73af\u3002</p> <p>\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {  // \u7269\u54c1i\n    for (int j = 1; j &lt;= m; j++) {  // \u5bb9\u91cfj (\u8fd9\u91cc\u662f\u987a\u5e8f\u5faa\u73af)\n        if (j &lt; v[i]) f[j] = f[j];\n        else\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n}\ncout &lt;&lt; f[m] &lt;&lt; endl;\n</code></pre> <p>\u8fdb\u4e00\u6b65\u4f18\u5316(<code>j</code>\u4ece<code>v[i]</code>\u5f00\u59cb\u5faa\u73af)\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {  // \u7269\u54c1i\n    for (int j = v[i]; j &lt;= m; j++) {  // \u5bb9\u91cfj\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n}\n</code></pre>"},{"location":"zh/Dynamic_Programming/01_Backpack_Problem/#_3","title":"\u591a\u91cd\u80cc\u5305\u95ee\u9898","text":"<p>\u6761\u4ef6\uff1a\u6709 \\(N\\) \u4ef6\u7269\u54c1\u548c\u4e00\u4e2a\u5bb9\u91cf\u662f \\(V\\) \u7684\u80cc\u5305\u3002\u7b2c \\(i\\) \u79cd\u7269\u54c1\u6700\u591a\u6709 \\(s_i\\) \u4ef6\u3002\u7b2c \\(i\\) \u4ef6\u7269\u54c1\u7684\u4f53\u79ef\u662f \\(v_i\\)\uff0c\u4ef7\u503c\u662f \\(w_i\\)\u3002</p> <p>\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f(i,j)\\)<ul> <li>\u96c6\u5408\uff1a\u6240\u6709\u53ea\u4ece\u524d \\(i\\) \u4e2a\u7269\u54c1\u4e2d\u9009\u62e9\uff0c\u5e76\u4e14\u603b\u4f53\u79ef\u4e0d\u8d85\u8fc7 \\(j\\) \u7684\u9009\u6cd5\uff1b</li> <li>\u5c5e\u6027\uff1a\u96c6\u5408\u4e2d\u6bcf\u4e2a\u9009\u6cd5\u5bf9\u5e94\u7684\u603b\u4ef7\u503c\u7684\u6700\u5927\u503c\u3002</li> </ul> </li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u6839\u636e\u7b2c \\(i\\) \u4e2a\u7269\u54c1\u9009\u4e86\u591a\u5c11\u4e2a\u6765\u5212\u5206\u96c6\u5408(\u53ef\u9009 \\(0\\) \u4e2a\uff0c \\(1\\) \u4e2a\uff0c...\uff0c\u76f4\u5230 <code>s[i]</code>\u4e2a)\u3002</li> </ul> <p>\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\uff1a</p> \\[ f\\left( i,j \\right) =\\max [ f\\left( i-1,j-v\\left[ i \\right] \\cdot k \\right) +w\\left[ i \\right] \\cdot k ] ; k=0,1,2,\\cdots ,s\\left[ i \\right] \\] <p>\u4f8b\u9898\uff1a\u591a\u91cd\u80cc\u5305\u95ee\u9898\u7684\u6734\u7d20\u89e3\u6cd5</p> <p>\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 0; j &lt;= m; j++) {\n        for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) {\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n        }\n    }\n}\ncout &lt;&lt; f[n][m] &lt;&lt; endl;\n</code></pre> <p>\u6734\u7d20\u89e3\u6cd5\u4e00\u7ef4\u7a7a\u95f4\u4f18\u5316\u7684\u6a21\u677f\uff1a</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = m; j &gt;= v[i]; j--) {\n        for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)\n            f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);\n    }\n}\ncout &lt;&lt; f[m] &lt;&lt; endl;\n</code></pre> <p>\u6734\u7d20\u89e3\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(NVS)\\)\u3002</p> <p>\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u7528\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u7684\u4f18\u5316\u65b9\u6cd5\u6765\u4f18\u5316\u591a\u91cd\u80cc\u5305\u95ee\u9898\uff0c\u56e0\u4e3a<code>max</code>\u64cd\u4f5c\u4e0d\u5177\u6709\u53ef\u51cf\u6027\u3002\u53ef\u4ee5\u91c7\u7528\u4e8c\u8fdb\u5236\u4f18\u5316\u3002</p> <p>\u5f15\u8bba\uff1a\u5982\u4f55\u5c06\u6b63\u6574\u6570 \\(s\\) \u7528\u7c7b\u4f3c\u4e8c\u8fdb\u5236\u7684\u65b9\u5f0f\u8868\u793a\uff1f\u9009\u62e9 \\(1, 2, 4, 8, \\cdots , 2^k, c\\) \u8fd9\u4e9b\u6570\u5b57\u8fdb\u884c\u76f8\u52a0(\u6bcf\u4e2a\u6570\u5b57\u6700\u591a\u9009\u4e00\u6b21)\uff0c\u5176\u4e2d \\(2^k\\leqslant s, 2^{k+1}&gt;s\\)\uff0c\u4e14 \\(c&lt;2^{k+1}\\)\uff1b\u5b83\u4eec(\u9664\u4e86 \\(c\\) \u5916)\u53ef\u4ee5\u51d1\u51fa \\(0\\sim 2^{k+1}-1\\) \u4e4b\u95f4\u7684\u6570\uff0c\u52a0\u4e0a \\(c\\) \u540e\u53ef\u4ee5\u51d1\u51fa \\(c\\sim 2^{k+1}-1+c=s\\) \u4e4b\u95f4\u7684\u6570\uff0c\u8981\u6c42\u533a\u95f4 \\(\\left[ 0, 2^{k+1}-1 \\right] , \\left[ c, s \\right]\\)\u4e2d\u95f4\u4e0d\u80fd\u6709\u7f1d\u9699\uff0c\u4e8b\u5b9e\u4e0a\u56e0\u4e3a \\(c&lt;2^{k+1}\\) \u663e\u7136\u6210\u7acb\u3002\u6545\u4ece \\(0\\) \u5230 \\(s\\) \u7684\u6240\u6709\u6570\u53ef\u4ee5\u62fc\u63a5\u51fa\u6765\u3002</p> <p>\u4e3e\u4f8b\uff1a\u6c34\u679c\u5e97\u91cc\u6709 \\(40\\) \u4e2a\u82f9\u679c\uff0c\u5c0f\u660e\u8ba1\u5212\u8d2d\u4e70 \\(n(1\\leqslant n\\leqslant 40)\\) \u4e2a\u82f9\u679c\uff0c\u5982\u4f55\u8ba9\u5c0f\u660e\u5c3d\u53ef\u80fd\u5feb\u901f\u5730\u5b8c\u6210\u8d2d\u4e70\uff1f\u4e00\u4e2a\u663e\u800c\u6613\u89c1\u7684\u66b4\u529b\u505a\u6cd5\u662f\uff0c\u8ba9\u5c0f\u660e\u4e00\u4e2a\u4e2a\u62ff(\u5355\u4f4d\u662f\u4e2a)\uff0c\u4f46\u6548\u7387\u8fc7\u4e8e\u4f4e\u4e0b\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5e97\u5458\u53ef\u4e8b\u5148\u51c6\u5907\u597d \\(6\\) \u4e2a\u7bb1\u5b50\uff0c\u6bcf\u4e2a\u7bb1\u5b50\u4e2d\u7684\u82f9\u679c\u6570\u91cf\u5206\u522b\u4e3a \\([1,2,4,8,16,9]\\)\uff0c\u518d\u8ba9\u5c0f\u660e\u6309\u7bb1\u5b50\u62ff(\u5355\u4f4d\u662f\u7bb1\u5b50)\uff0c\u65e0\u8bba\u5c0f\u660e\u8ba1\u5212\u8d2d\u4e70\u591a\u5c11\u4e2a\uff0c\u4ed6\u6700\u591a\u53ea\u9700\u8981\u62ff \\(6\\) \u6b21\uff0c\u800c\u5728\u66b4\u529b\u505a\u6cd5\u4e2d\uff0c\u5c0f\u660e\u6700\u591a\u9700\u8981\u62ff \\(40\\) \u6b21\u3002</p> <p>\u7528\u6570\u5b66\u8868\u8fbe\u5f0f\uff0c\u53ef\u4ee5\u65ad\u5b9a\u5bf9\u4efb\u610f\u7684\u6b63\u6574\u6570 \\(s\\)\uff0c\u90fd\u53ef\u4ee5\u627e\u5230 \\(\\lfloor \\log _2s \\rfloor +1\\triangleq k\\) \u4e2a\u6b63\u6574\u6570 \\(a_1,a_2,\\cdots ,a_k\\)\uff0c\u4f7f\u5f97 \\(\\forall n\\in [0,s]\\)\uff0c\u90fd\u6709\uff1a</p> \\[ n=\\boldsymbol{v}^T\\cdot \\boldsymbol{a}; \\boldsymbol{a}=\\left[ \\begin{array}{c}     a_1\\\\     \\vdots\\\\     a_k\\\\ \\end{array} \\right] , a_i=\\begin{cases}     2^{i-1},\\\\     s-2^{i-1}+1;\\left( \\in \\left[ 1,2^{k-1} \\right] \\right)\\\\ \\end{cases} \\] <p>\u5176\u4e2d\uff1a</p> \\[ \\boldsymbol{v}=\\left[ \\begin{array}{c}     v_1\\\\     \\vdots\\\\     v_k\\\\ \\end{array} \\right] \\] <p>\u4e14 \\(\\boldsymbol{v}\\) \u7684\u6bcf\u4e2a\u5206\u91cf\u8981\u4e48\u662f \\(0\\) \u8981\u4e48\u662f \\(1\\)\u3002</p> <p>\u73b0\u5728\u5bf9\u4e8e\u6bcf\u79cd\u7269\u54c1 \\(i\\)\uff0c\u53ef\u4ee5\u5c06\u8fd9 \\(s[i]\\) \u4e2a\u7269\u54c1\u5206\u6563\u81f3 \\(\\lfloor \\log _2s\\left[ i \\right] \\rfloor +1\\) \u4e2a\u7bb1\u5b50\u4e2d\uff0c\u5c06\u591a\u91cd\u80cc\u5305\u4fbf\u5316\u62100-1\u80cc\u5305\uff0c\u591a\u91cd\u80cc\u5305\u95ee\u9898\u4e2d\u7684\u4e00\u4e2a\u7bb1\u5b50\u76f8\u5f53\u4e8e0-1\u80cc\u5305\u95ee\u9898\u4e2d\u7684\u4e00\u4ef6\u7269\u54c1\u3002</p> <p>\u4e8c\u8fdb\u5236\u62c6\u5206\u601d\u60f3\uff1a\u628a\u7b2c \\(i\\) \u79cd\u7269\u54c1\u62c6\u5206\u6210\u82e5\u5e72\u4ef6\u7269\u54c1\uff0c\u6bcf\u4ef6\u7269\u54c1\u7684\u4f53\u79ef\u548c\u4ef7\u503c\u4e58\u4ee5\u4e00\u4e2a\u62c6\u5206\u7cfb\u6570 \\(\\left( 1,2^1,2^2,\\cdots ,2^{k-1},s_i-2^k+1 \\right)\\)\uff0c\u5c31\u53ef\u4ee5\u8f6c\u5316\u62100-1\u80cc\u5305\u95ee\u9898\u6c42\u89e3\u3002\u4f8b\u5982\uff1a\u82e5 \\(s_i = 12\\)\uff0c\u62c6\u5206\u7cfb\u6570\u4e3a \\(1,2,4,5\\)\uff0c\u8f6c\u5316\u6210 \\(4\\) \u4ef60-1\u80cc\u5305\u7684\u7269\u54c1\uff1a \\(\\left( v_i,w_i \\right) ,\\left( 2v_i,2w_i \\right) ,\\left( 4v_i,4w_i \\right) ,\\left( 5v_i,5w_i \\right)\\)\u3002</p> <p>\u8fd9\u6837\u53ef\u4ee5\u628a\u65f6\u95f4\u590d\u6742\u5ea6\u4ece \\(O(N\\cdot V\\cdot S)\\) \u53d8\u4e3a \\(O(N\\cdot V\\cdot \\log S)\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u591a\u91cd\u80cc\u5305\u95ee\u9898\u7684\u4e8c\u8fdb\u5236\u4f18\u5316</p> <p>\u6a21\u677f\u7a0b\u5e8f\uff1a</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N = 25000;\nconst int M = 2010;\n\nint n, m;\nint v[N], w[N], f[N];\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    int num = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        // v \u4f53\u79ef  w \u4ef7\u503c  s \u6570\u91cf\n        int vi, wi, s;\n        cin &gt;&gt; vi &gt;&gt; wi &gt;&gt; s;\n        for (int k = 1; k &lt;= s; k &lt;&lt;= 1) {  // k &lt;&lt;= 1 \u76f8\u5f53\u4e8e k *= 2\n            v[num] = k * vi;\n            w[num++] = k * wi;\n            s -= k;\n        }\n        if (s &gt; 0) {\n            v[num] = s * vi;\n            w[num++] = s * wi;\n        }\n    }\n\n    for (int i = 1; i &lt;= num - 1; i++) {\n        for (int j = m; j &gt;= v[i]; j--) {\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n        }\n    }\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"zh/Dynamic_Programming/01_Backpack_Problem/#_4","title":"\u5206\u7ec4\u80cc\u5305\u95ee\u9898","text":"<p>\u6761\u4ef6\uff1a\u6709 \\(N\\) \u7ec4\u7269\u54c1\u548c\u4e00\u4e2a\u5bb9\u91cf\u662f \\(V\\) \u7684\u80cc\u5305\u3002\u6bcf\u7ec4\u7269\u54c1\u6709\u82e5\u5e72\u4e2a\uff0c\u540c\u4e00\u7ec4\u5185\u7684\u7269\u54c1\u6700\u591a\u53ea\u80fd\u9009\u4e00\u4e2a\u3002\u6bcf\u4ef6\u7269\u54c1\u7684\u4f53\u79ef\u662f \\(v_{ij}\\)\uff0c\u4ef7\u503c\u662f \\(w_{ij}\\)\uff0c\u5176\u4e2d \\(i\\) \u662f\u7ec4\u53f7\uff0c \\(j\\) \u662f\u7ec4\u5185\u7f16\u53f7\u3002 \\(s_i\\) \u8868\u793a\u7b2c \\(i\\) \u4e2a\u7269\u54c1\u7ec4\u7684\u7269\u54c1\u6570\u91cf\u3002</p> <p>\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a<ul> <li>\u96c6\u5408\uff1a\u53ea\u4ece\u524d \\(i\\) \u7ec4\u7269\u54c1\u4e2d\u9009\uff0c\u4e14\u603b\u4f53\u79ef\u4e0d\u5927\u4e8e \\(j\\) \u7684\u6240\u6709\u9009\u6cd5\uff1b</li> <li>\u5c5e\u6027\uff1a\u6700\u5927\u503c\u3002</li> </ul> </li> <li>\u72b6\u6001\u8ba1\u7b97 (\u96c6\u5408\u5212\u5206)\uff1a<ul> <li>\u679a\u4e3e\u7b2c \\(i\\) \u7ec4\u7269\u54c1\u9009 \u54ea\u4e2a\uff1b</li> <li>\u5982\u679c\u4e0d\u9009\u7b2c \\(i\\) \u7ec4\u7b2c \\(k\\) \u4e2a\u7269\u54c1\uff1a \\(f(i,j)\\)\uff1b</li> <li>\u5982\u679c\u9009\u7b2c \\(i\\) \u7ec4\u7b2c \\(k\\) \u4e2a\u7269\u54c1\uff1a \\(f\\left( i-1, j-v\\left[ i,k \\right] \\right) +w\\left[ i,k \\right]\\)\u3002</li> </ul> </li> </ul> <p>\u9012\u63a8\u5f0f\uff1a</p> \\[ f\\left( j \\right) =\\max \\left[ f\\left( j \\right) ,\\max_{1\\leqslant k\\leqslant s\\left[ i \\right]} f\\left( j-v\\left[ i,k \\right] \\right) +w\\left[ i,k \\right] \\right]  \\] <p>\u4f8b\u9898\uff1a\u5206\u7ec4\u80cc\u5305\u95ee\u9898\uff1b\u5206\u7ec4\u80cc\u5305\u95ee\u9898\u4e00\u7ef4\u4f18\u5316</p> <p>\u5206\u7ec4\u80cc\u5305\u95ee\u9898\u96be\u4ee5\u4f7f\u7528\u4e8c\u8fdb\u5236\u6216\u5355\u8c03\u961f\u5217\u8fdb\u884c\u4f18\u5316\uff0c\u4f46\u53ef\u4ee5\u5bf9\u7a7a\u95f4\u8fdb\u884c\u4e00\u5b9a\u7684\u4f18\u5316\u3002</p> <p>\u6a21\u677f\u7a0b\u5e8f\uff1a</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N = 110;\n\nint n, m, s;\nint v[N], w[N];\nint f[N];\n\nint main() {\n    cin &gt;&gt; n &gt;&gt;m;\n    for (int i = 1; i &lt;= n; i++) {  // \u7269\u54c1\n        cin &gt;&gt; s;\n        for (int j = 1; j &lt;= s; j++) cin &gt;&gt; v[j] &gt;&gt; w[j];\n        // \u4e0d\u80fd\u4ea4\u6362\u4f53\u79ef\u548c\u51b3\u7b56\u7684\u5185\u5916\u5faa\u73af\u987a\u5e8f\uff01\n        for (int j = m; j &gt;= 0; j--) {  // \u4f53\u79ef\n            for (int k = 0; k &lt;= s; k++) {  // \u51b3\u7b56\n                if (j &gt;= v[k])\n                    f[j] = max(f[j], f[j - v[k]] + w[k]);\n            }\n        }\n    }\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"zh/Dynamic_Programming/02_Linear_DP/","title":"\u7ebf\u6027\u52a8\u6001\u89c4\u5212","text":""},{"location":"zh/Dynamic_Programming/02_Linear_DP/#_2","title":"\u6570\u5b57\u4e09\u89d2\u5f62\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u6570\u5b57\u4e09\u89d2\u5f62</p> <p></p> <p>\u6570\u5b57\u4e09\u89d2\u5f62\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f(i,j)\\)\uff1a</li> <li>\u96c6\u5408\uff1a\u6240\u6709\u4ece\u8d77\u70b9\u8d70\u5230\u70b9 \\((i,j)\\) \u7684\u8def\u5f84\uff1b</li> <li>\u5c5e\u6027\uff1a\u96c6\u5408\u4e2d\u6240\u6709\u8def\u5f84\u5bf9\u5e94\u7684\u6570\u5b57\u4e4b\u548c\u7684\u6700\u5927\u503c\u3002</li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u5c06\u96c6\u5408 \\(f(i,j)\\) \u5206\u4e3a\u4e24\u7c7b\uff1a</li> <li>\u6765\u81ea\u5de6\u4e0a\u65b9\u7684\u8def\u5f84\uff1a \\(f(i-1,j-1)+a[i][j]\\)\uff1b</li> <li>\u6765\u81ea\u53f3\u4e0a\u65b9\u7684\u8def\u5f84\uff1a \\(f(i-1,j)+a[i][j]\\)\u3002</li> </ul> <p>\u52a8\u6001\u89c4\u5212\u95ee\u9898\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u4e00\u822c\u4e3a\u201c\u72b6\u6001\u6570\u91cf\u201d\u4e58\u4ee5\u201c\u6bcf\u4e2a\u72b6\u6001\u8f6c\u79fb\u9700\u8981\u7684\u8ba1\u7b97\u91cf\u201d\uff0c\u672c\u9898\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\)\u3002</p>"},{"location":"zh/Dynamic_Programming/02_Linear_DP/#_3","title":"\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217</p> <p>\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f[i]\\)</li> <li>\u96c6\u5408\uff1a\u6240\u6709\u4ee5\u7b2c \\(i\\) \u4e2a\u6570\u7ed3\u5c3e\u7684\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u96c6\u5408</li> <li>\u5c5e\u6027\uff1a\u96c6\u5408\u6bcf\u4e2a\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u7684\u6700\u5927\u503c</li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u6309\u5012\u6570\u7b2c\u4e8c\u4e2a\u6570\u662f\u54ea\u4e2a\u6765\u5212\u5206\u96c6\u5408\uff0c\u8981\u4e48\u5e8f\u5217\u91cc\u53ea\u6709\u4e00\u4e2a\u6570(0)\uff0c\u8981\u4e48\u5012\u6570\u7b2c\u4e8c\u4e2a\u6570\u7684\u4e0b\u6807\u53ef\u80fd\u4e3a \\(1,2,\\cdots ,n-1\\)\uff0c\u8fd9\u4e9b\u7c7b\u4e0d\u4e00\u5b9a\u90fd\u5b58\u5728</li> </ul> <p>\u5bf9\u4e8e\u6700\u540e\u4e24\u4e2a\u6570\u5206\u522b\u4e3a \\(a_j,a_i\\) \u7684\u4e0a\u5347\u5b50\u5e8f\u5217( \\(a_j &lt; a_i\\) )\uff0c\u6ee1\u8db3\u5176\u957f\u5ea6\u4e3a \\(f[j]+1\\)\uff0c\u5219 \\(f[i]=\\max (f[j]+1), a_j &lt; a_i, j=0,1,\\cdots ,i-1\\)</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\)</p> <p>\u4f8b\u9898\uff1a\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u52172</p> <p>\u5f53\u6570\u636e\u8303\u56f4\u8f83\u5927\u65f6\uff0c\u5e94\u8be5\u5bfb\u627e\u4e00\u79cd\u65f6\u95f4\u590d\u6742\u5ea6\u66f4\u4f4e\u7684\u65b9\u5f0f\u3002</p> <p>\u6269\u5c55\u89e3\u6cd5\u53ef\u628a\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230 \\(O(n\\log n)\\)</p>"},{"location":"zh/Dynamic_Programming/02_Linear_DP/#_4","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217</p> <p>\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f(i,j)\\)</li> <li>\u96c6\u5408\uff1a\u6240\u6709\u7531\u7b2c\u4e00\u4e2a\u5e8f\u5217\u7684\u524d \\(i\\) \u4e2a\u5b57\u6bcd\u548c\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u7684\u524d \\(j\\) \u4e2a\u5b57\u6bcd\u6784\u6210\u7684\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u4e5f\u5c31\u662f\u6240\u6709\u5728\u7b2c\u4e00\u4e2a\u5e8f\u5217\u7684\u524d \\(i\\) \u4e2a\u5b57\u6bcd\u4e2d\u51fa\u73b0\uff0c\u4e14\u5728\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u7684\u524d \\(j\\) \u4e2a\u5b57\u6bcd\u4e2d\u51fa\u73b0\u7684\u5b50\u5e8f\u5217</li> <li>\u5c5e\u6027\uff1a\u6240\u6709\u8fd9\u4e9b\u5b50\u5e8f\u5217\u957f\u5ea6\u7684\u6700\u5927\u503c</li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u4ee5<code>a[i]</code>\u3001<code>b[j]</code>\u662f\u5426\u5305\u542b\u5728\u5b50\u5e8f\u5217\u4e2d\u6765\u5212\u5206\u96c6\u5408(\u51714\u79cd\u60c5\u51b5)</li> <li>\u60c5\u51b5 \\(00\\) (\u4e0d\u9009<code>a[i]</code>\uff0c\u4e0d\u9009<code>b[j]</code>)\uff1a \\(f(i-1,j-1)\\)\uff0c\u4e00\u822c\u4ee3\u7801\u4e2d\u53ef\u4ee5\u4e0d\u5199\u8fd9\u79cd\u60c5\u51b5\uff0c\u56e0\u4e3a \\(f(i-1,j)\\) \u548c \\(f(i,j-1)\\) \u5df2\u7ecf\u5305\u542b\u4e86\u8fd9\u79cd\u60c5\u5f62</li> <li>\u60c5\u51b5 \\(01\\) (\u4e0d\u9009<code>a[i]</code>\uff0c\u9009<code>b[j]</code>)\uff1a\u6ce8\u610f \\(f(i-1,j)\\) \u4e0d\u4e00\u5b9a\u5305\u542b<code>b[j]</code>(\u5373\u60c5\u51b5 \\(01\\) \u4e3a \\(f(i-1,j)\\) \u7684\u5b50\u96c6\uff0c\u800c\u4e0d\u662f\u76f8\u7b49)\uff0c\u4f46\u4e3a\u4e86\u6c42\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u7528 \\(f(i-1,j)\\) \u6765\u66ff\u6362\uff0c\u5373\u4f7f\u96c6\u5408\u5212\u5206\u51fa\u73b0\u91cd\u590d\u4e5f\u6ca1\u4e8b(\u56e0\u4e3a\u6c42\u7684\u662f\u6700\u5927\u503c\uff0c\u53ea\u8981\u4e0d\u6f0f\u6389\u5143\u7d20\u5c31\u884c)</li> <li>\u60c5\u51b5 \\(10\\) (\u9009<code>a[i]</code>\uff0c\u4e0d\u9009<code>b[j]</code>)\uff1a\u4e3a\u4e86\u6c42\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u7528 \\(f(i,j-1)\\) \u6765\u66ff\u6362</li> <li>\u60c5\u51b5 \\(11\\) (\u9009<code>a[i]</code>\uff0c\u9009<code>b[j]</code>)\uff1a \\(f(i-1,j-1)+1\\)</li> </ul> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\)</p> <p>\u6ce8\uff1a\u4ee5\u4e0a\u7b2c\u4e8c\u79cd\u60c5\u51b5\u6307\u7684\u662f<code>a[i]</code>\u4e0d\u51fa\u73b0\u5728\u5b50\u5e8f\u5217\u4e2d\uff0c<code>b[j]</code>\u4e00\u5b9a\u51fa\u73b0\u5728\u5b50\u5e8f\u5217\u4e2d\uff0c<code>f[i - 1, j]</code>\u4e25\u683c\u5305\u542b\u8fd9\u79cd\u60c5\u51b5\u3002\u4e3a\u4ec0\u4e48\uff1f \u7b2c\u4e8c\u79cd\u72b6\u6001\u7684\u610f\u601d\u662f\uff1a<code>a[i]</code>\u4e00\u5b9a\u4e0d\u5728\u5b50\u5e8f\u5217\u4e2d\uff0c\u4e14\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e00\u5b9a\u662f<code>b[j]</code>\uff1b\u800c<code>f[i - 1, j]</code>\u7684\u610f\u601d\u662f\uff0c<code>a</code>\u7684\u524d<code>i - 1</code>\u548c<code>b</code>\u7684\u524d<code>j</code>\u4e2d\u51fa\u73b0\u516c\u5171\u5b50\u5e8f\u5217\uff0c\u6240\u4ee5\u662f\u7b2c\u4e8c\u79cd\u72b6\u6001\u7684\u6761\u4ef6\u66f4\u5f3a\u3002</p> <ul> <li>\u4e3a\u4ec0\u4e48\u6709\u91cd\u590d\uff1f\u56e0\u4e3a\u7b2c\u4e8c\u79cd\u72b6\u6001\u66f4\u5f3a\uff0c<code>f[i - 1, j]</code>\u6761\u4ef6\u5f31\u4e00\u70b9\uff0c\u6240\u4ee5\u7528<code>f[i - 1, j]</code>\u8868\u793a\u7b2c\u4e8c\u79cd\u72b6\u6001\u91cc\u9762\u80af\u5b9a\u4f1a\u6709\u91cd\u590d\u7684\uff1b</li> <li>\u4e3a\u4ec0\u4e48\u6c42\u6700\u5927\u503c\u53ef\u4ee5\u91cd\u590d\uff1f\u5982\u679c\u53d6\u6700\u5927\u503c\u7684\u8bdd\uff0c\u91cd\u590d\u4e5f\u5c31\u65e0\u6240\u8c13\u4e86\uff0c\u5c31\u7b97\u91cd\u590d\u6700\u5927\u503c\u4f9d\u7136\u662f\u6700\u5927\u503c\u3002</li> </ul>"},{"location":"zh/Dynamic_Programming/02_Linear_DP/#_5","title":"\u7f16\u8f91\u8ddd\u79bb\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u6700\u77ed\u7f16\u8f91\u8ddd\u79bb</p> <p>\u8be5\u95ee\u9898\u53ef\u8fdb\u884c\u5982\u4e0b\u5206\u6790\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a</li> <li>\u96c6\u5408\uff1a\u6240\u6709\u5c06<code>a[1~i]</code>\u53d8\u4e3a<code>b[1~j]</code>\u7684\u64cd\u4f5c\u65b9\u5f0f</li> <li>\u5c5e\u6027\uff1a\u6240\u6709\u64cd\u4f5c\u65b9\u5f0f\u7684\u64cd\u4f5c\u6b21\u6570\u7684\u6700\u5c0f\u503c</li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a<code>f[i,j]</code></li> <li>\u5220\u9664\uff1a<code>f[i - 1, j] + 1</code></li> <li>\u589e\u52a0\uff1a<code>f[i, j - 1] + 1</code></li> <li>\u4fee\u6539\uff1a\u6839\u636e<code>a[i]</code>\u4e0e<code>b[j]</code>\u662f\u5426\u76f8\u7b49\u6765\u5206\u7c7b\u8ba8\u8bba\uff0c<code>f[i - 1, j - 1] + 1\u62160</code></li> </ul> <p><code>f[i, j]</code>\u4e3a\u4ee5\u4e0a\u4e09\u79cd\u60c5\u51b5\u6700\u5c0f\u503c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\)</p> <p>\u4f8b\u9898\uff1a\u7f16\u8f91\u8ddd\u79bb</p>"},{"location":"zh/Dynamic_Programming/03_Interval_DP/","title":"\u533a\u95f4\u52a8\u6001\u89c4\u5212","text":""},{"location":"zh/Dynamic_Programming/03_Interval_DP/#_2","title":"\u77f3\u5b50\u5408\u5e76\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u77f3\u5b50\u5408\u5e76</p> <p>\u77f3\u5b50\u5408\u5e76\u52a8\u6001\u89c4\u5212\u95ee\u9898\uff1a</p> <ul> <li>\u72b6\u6001\u8868\u793a\uff1a \\(f(i,j)\\)</li> <li>\u96c6\u5408\uff1a\u6240\u6709\u5c06\u7b2c \\(i\\) \u5806\u77f3\u5b50\u5230\u7b2c \\(j\\) \u5806\u77f3\u5b50\u5408\u5e76\u6210\u4e00\u5806\u77f3\u5b50\u7684\u5408\u5e76\u65b9\u5f0f</li> <li>\u5c5e\u6027\uff1a\u6240\u6709\u5408\u5e76\u65b9\u5f0f\u4ee3\u4ef7\u6700\u5c0f\u503c\uff0c\u6700\u7ec8\u7b54\u6848\u4e3a \\(f(1,n)\\)</li> <li>\u72b6\u6001\u8ba1\u7b97\uff1a\u4ee5\u6700\u540e\u4e00\u6b21\u5408\u5e76\u7684\u5206\u754c\u7ebf\u4f4d\u7f6e\u6765\u5212\u5206\u96c6\u5408\uff0c\u4ece\u5de6\u8fb91\u4e2a\u5230\u5de6\u8fb9 \\(k-1\\) \u4e2a</li> </ul> <p>\u5982\u679c\u533a\u95f4\u5212\u5206\u4e3a \\([i,k]\\) \u548c \\([k+1,j]\\)\uff0c\u5219\u6700\u5c0f\u4ee3\u4ef7\u53ef\u4ee5\u8868\u793a\u4e3a \\(f(i,k)+f(k+1,j)+s[j]-s[i-1]\\) (\u4e5f\u5c31\u662f\u5de6\u8fb9\u7684\u6700\u5c0f\u4ee3\u4ef7\uff0c\u52a0\u53f3\u8fb9\u7684\u6700\u5c0f\u4ee3\u4ef7\uff0c\u52a0\u6700\u540e\u4e00\u6b65\u7684\u6700\u5c0f\u4ee3\u4ef7)\uff0c\u5176\u4e2d \\(s[j]\\) \u4e3a\u524d\u7f00\u548c\uff0c\u6545\uff1a</p> \\[ f\\left( i,j \\right) =\\min \\left[ f\\left( i,k \\right) +f\\left( k+i,j \\right) +s\\left[ j \\right] -s\\left[ i-1 \\right] \\right] ; k=i,\\cdots ,j-1 \\] <p>\u521d\u503c\u4e3a \\(f(i,i)=0\\)\uff0c\u5176\u4f59\u4e3a\u6b63\u65e0\u7a77\u3002</p> <pre><code>const int N = 310;\nint n;  //\u77f3\u5b50\u5806\u6570\nint a[N];  //\u8bb0\u5f55\u6bcf\u5806\u77f3\u5b50\u7684\u8d28\u91cf\nint s[N]; //\u8bb0\u5f55\u524d\u7f00\u548c\nint f[N][N];  //f[l][r]\u8868\u793a\u628a\u4ecel\u5230r\u5408\u5e76\u6210\u4e00\u5806\u7684\u6700\u5c0f\u4ee3\u4ef7\n\nint main() {\n    //\u9884\u5904\u7406\n    memset(f, 0x3f, sizeof f);\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];  //\u6bcf\u5806\u77f3\u5b50\u7684\u8d28\u91cf\n        s[i] = s[i - 1] + a[i];  //\u524d\u7f00\u548c\n        f[i][i] = 0;  //\u5408\u5e76\u6bcf\u4e00\u5806\u77f3\u5b50\u7684\u4ee3\u4ef7\u4e3a0\n    }\n\n    //\u72b6\u6001\u8ba1\u7b97\n    for (int len = 2; len &lt;= n; len++) {  //\u9636\u6bb5\uff1a\u679a\u4e3e\u533a\u95f4\u957f\u5ea6\n        for (int l = 1; l + len - 1 &lt;= n; l++) {  //\u72b6\u6001\uff1a\u679a\u4e3e\u533a\u95f4\u8d77\u70b9\n            int r = l + len - 1;  //\u533a\u95f4\u7ec8\u70b9\n            for (int k = l; k &lt; r; k++) {  //\u51b3\u7b56\uff1a\u679a\u4e3e\u5206\u5272\u70b9\n                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n            }\n        }\n    }\n\n    cout &lt;&lt; f[1][n] &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^3)\\)</p>"},{"location":"zh/Dynamic_Programming/05_Digital_Counting_DP/","title":"\u6570\u4f4d\u7edf\u8ba1\u52a8\u6001\u89c4\u5212","text":"<p>\u4f8b\u9898\uff1a\u8ba1\u6570\u95ee\u9898</p> <p>\u5206\u60c5\u51b5\u8ba8\u8bba\uff1a</p> <p>\u8981\u7edf\u8ba1<code>[a,b]</code>\u533a\u95f4\u4e2d\u6bcf\u4e2a\u6574\u6570\u51fa\u73b0\u7684\u6570\u5b570\u52309\u7684\u6b21\u6570\uff0c\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u4e2a<code>count</code>\u51fd\u6570\uff1a<code>count(n,x)</code>\u8868\u793a\u4ece1\u5230<code>n</code>\u4e2d<code>x</code>\u51fa\u73b0\u7684\u6b21\u6570(<code>x</code>\u53ef\u4ee5\u662f0\u52309)\uff0c\u5219<code>count(b, x)-count(a - 1, x)</code>\u5c31\u662f\u6211\u4eec\u60f3\u8981\u7684\u7ed3\u679c\u3002\u73b0\u5728\u53ea\u9700\u5b9e\u73b0<code>count</code>\u51fd\u6570\u5373\u53ef\u3002</p> <p>\u4f8b\u5982\uff0c\u5047\u8bbe \\(n\\) \u4e3a \\(\\overline{abcdefg}\\)\uff0c\u9700\u8981\u5206\u522b\u6c42\u51fa1\u5728\u6bcf\u4e00\u4f4d\u4e0a\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u7d2f\u52a0\u8d77\u6765\u5c31\u662f1\u51fa\u73b0\u7684\u6b21\u6570\u3002\u6bd4\u5982\u6c421\u5728\u7b2c4\u4f4d\u4e0a\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5c31\u662f\u8981\u627e\u5230\u5f62\u5982 \\(1\\leqslant \\overline{xxx1yyy}\\leqslant \\overline{abcdefg}\\) \u7684\u6574\u6570\uff1a</p> <ul> <li>\u60c5\u51b5\u4e00\uff1a\u5982\u679c\u524d\u4e09\u4f4d \\(\\overline{xxx}=000\\sim \\overline{abc}-1\\)\uff0c\u5219\u540e\u4e09\u4f4d  \\(\\overline{yyy}=\\overline{000}\\sim \\overline{999}\\)\uff0c\u5171 \\(\\overline{abc}\\cdot 1000\\) \u79cd\u9009\u6cd5</li> <li>\u60c5\u51b5\u4e8c\uff1a\u5982\u679c\u524d\u4e09\u4f4d \\(\\overline{xxx}=\\overline{abc}\\)\uff1a</li> <li>\u82e5 \\(d&lt;1\\)(\u5373 \\(d=0\\) )\uff0c\u5219 \\(\\overline{abc1yyy}&gt;\\overline{abc0efg}\\)\uff0c\u65b9\u6848\u6570\u4e3a0</li> <li>\u82e5 \\(d=1\\)\uff0c\u5219 \\(\\overline{yyy}=\\overline{000}\\sim \\overline{efg}\\)\uff0c\u5171\u6709 \\(\\overline{efg}+1\\)\u79cd\u65b9\u6848</li> <li>\u82e5 \\(d&gt;1\\)\uff0c\u5219 \\(\\overline{yyy}=\\overline{000}\\sim \\overline{999}\\)\uff0c\u5171 \\(1000\\) \u79cd\u65b9\u6848</li> </ul> <p>\u8fd0\u7528\u7c7b\u4f3c\u7684\u5206\u7c7b\u8ba8\u8bba\u65b9\u5f0f\u53ef\u4ee5\u6c42\u51fa1\u5728\u5176\u4ed6\u4f4d\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u4e5f\u53ef\u4ee5\u6c42\u51fa\u5176\u4ed6\u6570\u5b57\u5728\u6bcf\u4e00\u4f4d\u51fa\u73b0\u7684\u6b21\u6570\u3002</p> <p>\u8fb9\u754c\u95ee\u9898\uff1a</p> <ul> <li>\u5f53\u8981\u679a\u4e3e\u7684\u6570\u5b57\u51fa\u73b0\u5728\u6700\u9ad8\u4f4d\u65f6\uff0c\u4ee5\u4e0a\u60c5\u51b5\u4e00\u4e0d\u5b58\u5728\uff1b</li> <li>\u5f53\u8981\u679a\u4e3e\u6570\u5b570\u65f6\uff0c\u4e0d\u80fd\u6709\u524d\u5bfc0\u7684\u5b58\u5728\uff0c\u9700\u8981\u91cd\u65b0\u8003\u8651\u60c5\u51b5\u4e00\uff1a\u5047\u5982\u7b2c \\(k\\) \u4f4d\u4e3a0\uff0c\u5e76\u4e14\u5b83\u7684\u524d\u9762\u662f\u51680\uff0c\u90a3\u4e48\u5c31\u76f8\u5f53\u4e8e\u7b2c \\(k\\) \u4f4d\u5e76\u4e0d\u5b58\u5728\uff0c\u4e5f\u5c31\u4e0d\u80fd\u7b97\u662f\u4e00\u4e2a\u65b9\u6848\u6570\u3002\u4f8b\u5982\uff0c\u8981\u5728 \\(\\overline{abcdefg}\\) \u4e2d\u627e\u7b2c4\u4f4d\u4e3a0\u7684\u6570\u3002\u5047\u5982 \\(\\overline{abc}\\) \u4e3a \\(\\overline{000}\\)\uff0c \\(d\\)\u4e5f\u4e3a0\uff0c\u90a3\u4e48\u5c31\u4f1a\u6709 \\(\\overline{0000efg}\\)\u3002\u4f46\u662f\uff0c \\(\\overline{0000efg}\\) \u5b9e\u9645\u4e0a\u5c31\u662f \\(\\overline{efg}\\)\uff0c\u5b83\u5e76\u4e0d\u5b58\u5728\u7b2c\u56db\u4f4d\uff0c\u56e0\u6b64\u4e5f\u5c31\u4e0d\u80fd\u7b97\u662f\u7b2c4\u4f4d\u4e3a0\u7684\u6570\u3002\u5728\u8be5\u60c5\u51b5\u4e0b\u5e94\u8be5\u628a\u60c5\u51b5\u4e00\u4fee\u6539\u6210\u4ece\u524d\u4e09\u4f4d\u4ece \\(\\overline{001}\\) \u5f00\u59cb\u679a\u4e3e\uff0c\u800c\u4e0d\u662f\u4ece \\(\\overline{000}\\) \u5f00\u59cb\u3002</li> </ul>"},{"location":"zh/Graph_and_Search/","title":"\u56fe\u8bba\u4e0e\u641c\u7d22","text":""},{"location":"zh/Graph_and_Search/01_DFS_BFS/","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u548c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22","text":"\u6570\u636e\u7ed3\u6784 \u7a7a\u95f4 DFS <code>stack</code> \\(O(h)\\) BFS <code>queue</code> \\(O(2^h)\\) <p>\u7a7a\u95f4\u4e0aBFS\u5360\u52a3\u52bf\uff0c\u4f46BFS\u5728\u641c\u7d22\u65f6\u6709\u201c\u6700\u77ed\u8def\u201d\u7684\u6027\u8d28(\u82e5\u4e00\u4e2a\u56fe\u6240\u6709\u8fb9\u7684\u6743\u91cd\u5747\u4e3a<code>1</code>)\uff0c\u800cDFS\u7684\u8def\u5f84\u4e0d\u5177\u6709\u6700\u77ed\u6027\u3002</p> <p>\u52a8\u6001\u89c4\u5212\u662f\u4e00\u79cd\u7279\u6b8a\u7684(\u6ca1\u6709\u73af\u7684)\u6700\u77ed\u8def\u95ee\u9898\u3002</p>"},{"location":"zh/Graph_and_Search/01_DFS_BFS/#dfs","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22DFS","text":"<p>DFS\u9700\u8981\u8003\u8651\u56de\u6eaf\u548c\u526a\u679d\u3002</p> <p>\u6bcf\u4e2aDFS\u5bf9\u5e94\u4e00\u6761\u641c\u7d22\u6811\uff0c\u53ef\u4ee5\u628aDFS\u60f3\u8c61\u6210\u4e00\u4e2a\u201c\u6267\u7740\u7684\u4eba\u201d\u3002</p> <p>\u4f8b\u9898\uff1a\u6392\u5217\u6570\u5b57</p> <p></p> <p>DFS\u9700\u8981\u628a\u987a\u5e8f\u60f3\u6e05\u695a\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u56de\u6eaf\u4e00\u5b9a\u8981\u6062\u590d\u73b0\u573a\uff0c\u7cfb\u7edf\u4f1a\u4e3a\u6211\u4eec\u7ef4\u62a4\u4e00\u6761\u9012\u5f52\u8c03\u7528\u6808\u3002</p> <p>\u4f8b\u9898\uff1an-\u7687\u540e\u95ee\u9898\u65b9\u6cd5\u4e00; n-\u7687\u540e\u95ee\u9898\u65b9\u6cd5\u4e8c</p> <p></p> <ul> <li><code>void dfs(int r)</code>: \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u51fd\u6570\u3002\u53c2\u6570<code>r</code>\uff1a\u4ece\u7b2c<code>r</code>\u884c\u5f00\u59cb\u653e\u68cb\u5b50\uff0c\u5904\u7406\u7b2c<code>r</code>\u884c\u3002</li> <li>\u9012\u5f52\u7ed3\u675f\u5224\u5b9a\uff1a\u5f53<code>r == n</code>\u7684\u65f6\u5019\uff0c\u8bf4\u660e\u5e94\u8be5\u5904\u7406\u7b2c<code>n</code>\u884c\u4e86\uff0c\u4e5f\u4ee3\u8868\u7b2c<code>0 ~ n - 1</code>\u884c\u653e\u597d\u68cb\u5b50\uff0c\u4e5f\u5c31\u662f\u6574\u4e2a\u68cb\u76d8\u653e\u597d\u4e86\u68cb\u5b50\uff0c\u4e5f\u5c31\u662f\u5f97\u5230\u4e86\u4e00\u79cd\u89e3\uff0c\u4e5f\u5c31\u662f\u9012\u5f52\u7ed3\u675f\u3002</li> <li>\u7b2c<code>r</code>\u884c\uff0c\u7b2c<code>i</code>\u5217\u80fd\u4e0d\u80fd\u653e\u68cb\u5b50\uff1a\u7528\u6570\u7ec4<code>dg udg cor</code>\u5206\u522b\u8868\u793a\uff1a\u70b9\u5bf9\u5e94\u7684\u4e24\u4e2a\u659c\u7ebf\u4ee5\u53ca\u5217\u4e0a\u662f\u5426\u6709\u7687\u540e\u3002</li> <li><code>dg[i + r]</code>\u8868\u793a<code>r</code>\u884c<code>i</code>\u5217\u5904\uff0c\u6240\u5728\u7684\u5bf9\u89d2\u7ebf\u4e0a\u6709\u6ca1\u6709\u68cb\u5b50\uff0c<code>udg[n - i + r]</code>\u8868\u793a<code>r</code>\u884c<code>i</code>\u5217\u5904\uff0c\u6240\u5728\u7684\u53cd\u5bf9\u89d2\u7ebf\u4e0a\u6709\u6ca1\u6709\u68cb\u5b50\uff0c<code>cor[i]</code>\u8868\u793a\u7b2c<code>i</code>\u5217\u4e0a\u6709\u6ca1\u6709\u68cb\u5b50\u3002\u5982\u679c<code>r</code>\u884c<code>i</code>\u5217\u7684\u5bf9\u89d2\u7ebf\uff0c\u53cd\u5bf9\u89d2\u7ebf\u4e0a\u90fd\u6ca1\u6709\u68cb\u5b50\uff0c\u5373<code>!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r]</code>\u4e3a\u771f\uff0c\u5219\u4ee3\u8868<code>r</code>\u884c<code>i</code>\u5217\u5904\u53ef\u4ee5\u653e\u68cb\u5b50\u3002</li> </ul> <p>\u526a\u679d\u5c31\u662f\u5224\u65ad\u5f53\u524d\u65b9\u6848\u975e\u6cd5\uff0c\u76f4\u63a5\u820d\u5f03\u3002</p>"},{"location":"zh/Graph_and_Search/01_DFS_BFS/#bfs","title":"\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22BFS","text":"<p>\u6ce8\u610f\uff1a\u5f53\u6240\u6709\u8fb9\u6743\u4e3a<code>1</code>\u65f6\uff0c\u624d\u80fd\u7528BFS\u6c42\u6700\u77ed\u8def\u3002BFS\u901a\u8fc7\u961f\u5217\u5b58\u50a8\u548c\u8fdb\u884c\u4e0b\u4e00\u6b65\u7684\u67e5\u627e\uff0c\u53eb\u505a\u6362\u57fa\u8fed\u4ee3\uff0c\u4e5f\u5c31\u662f\u672c\u6b21\u7684\u641c\u7d22\u65b9\u5411\u662f\u57fa\u4e8e\u4e0a\u4e00\u6b21\u7684\u3002\u5b83\u548c\u52a8\u6001\u89c4\u5212\u4e2d\u7684\u540e\u6548\u6027\u76f8\u4f3c\uff0c\u672c\u6b21\u7684\u7ed3\u679c\u4f1a\u5f71\u54cd\u4e0b\u4e00\u6b21\u7684\u7ed3\u679c\u3002</p> <ul> <li>\u5c06\u8d77\u70b9\u5165\u961f\uff1b</li> <li>\u961f\u9996\u8282\u70b9\u53ef\u62d3\u5c55\u7684\u70b9\u5165\u961f\uff1b\u5982\u679c\u6ca1\u6709\u53ef\u62d3\u5c55\u7684\u70b9\uff0c\u5c06\u961f\u9996\u8282\u70b9\u51fa\u961f\uff1b</li> <li>\u91cd\u590d\u8be5\u6b65\u9aa4\uff0c\u76f4\u5230\u5230\u8fbe\u76ee\u6807\u4f4d\u7f6e\u6216\u961f\u5217\u4e3a\u7a7a\u3002</li> </ul> <p>\u4f8b\u9898\uff1a\u8d70\u8ff7\u5bab; \u8d70\u8ff7\u5babSTL\u65b9\u6cd5\u4e00; \u8d70\u8ff7\u5babSTL\u65b9\u6cd5\u4e8c</p> <pre><code>queue \u2190 \u521d\u59cb\u72b6\u6001\nwhile (queue\u975e\u7a7a) {\n    t \u2190 \u961f\u5934\n    \u62d3\u5c55t\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u516b\u6570\u7801</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/","title":"\u6811\u548c\u56fe\u7684\u57fa\u672c\u77e5\u8bc6","text":"<ul> <li>\u6811\u548c\u56fe\u7684\u57fa\u672c\u77e5\u8bc6</li> <li>\u56fe\u7684\u57fa\u672c\u6982\u5ff5<ul> <li>\u7b80\u5355\u56fe</li> <li>\u90bb\u57df</li> <li>\u5ea6\u6570</li> <li>\u8def\u5f84</li> <li>\u8fde\u901a</li> </ul> </li> <li>\u6811\u548c\u56fe\u7684\u5b58\u50a8<ul> <li>\u90bb\u63a5\u77e9\u9635</li> <li>\u8fb9\u96c6\u6570\u7ec4</li> <li>\u90bb\u63a5\u8868</li> <li>\u94fe\u5f0f\u90bb\u63a5\u8868</li> <li>\u94fe\u5f0f\u524d\u5411\u661f(\u91cd\u8981)</li> </ul> </li> <li>\u6811\u548c\u56fe\u7684\u904d\u5386<ul> <li>\u6df1\u5ea6\u4f18\u5148\u904d\u5386DFS</li> <li>\u5e7f\u5ea6\u4f18\u5148\u904d\u5386BFS</li> </ul> </li> </ul>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_2","title":"\u56fe\u7684\u57fa\u672c\u6982\u5ff5","text":"<p>\u6811\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u56fe\uff0c\u6811\u662f\u65e0\u73af\u8fde\u901a\u56fe\u3002</p> <p>\u56fe \\(G\\) \u662f\u4e00\u4e2a\u4e8c\u5143\u7ec4 \\(G=(V,E)\\) \u3002\u5176\u4e2d \\(V\\) \u662f\u975e\u7a7a\u96c6\uff0c\u79f0\u4e3a\u70b9\u96c6\uff0c \\(V\\) \u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u79f0\u4e3a\u9876\u70b9\u6216\u8282\u70b9\u3002 \\(E\\) \u4e3a\u5404\u8282\u70b9\u4e4b\u95f4\u8fb9\u7684\u96c6\u5408\uff0c\u79f0\u4e3a\u8fb9\u96c6\u3002\u56fe \\(G\\) \u7684\u70b9\u6570 \\(|V|\\) \u79f0\u4f5c \\(G\\) \u7684\u9636\u3002</p> <p>\u5f53 \\(V\\) \u548c \\(E\\) \u90fd\u662f\u6709\u9650\u96c6\u5408\u65f6\uff0c\u79f0 \\(G\\) \u4e3a\u6709\u9650\u56fe\u3002\u5f53 \\(V\\) \u6216 \\(E\\) \u662f\u65e0\u9650\u96c6\u5408\u65f6\uff0c\u79f0 \\(G\\) \u4e3a\u65e0\u9650\u56fe\u3002</p> <p>\u6839\u636e\u8fb9\u662f\u5426\u6709\u5411\u53ef\u5c06\u56fe\u5206\u4e3a\uff1a\u65e0\u5411\u56fe\u3001\u6709\u5411\u56fe\u548c\u6df7\u5408\u56fe\uff1a</p> <ul> <li>\u65e0\u5411\u56fe\uff1a \\(E\\) \u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u662f\u4e00\u4e2a\u65e0\u5e8f\u4e8c\u5143\u7ec4 \\((u,v)\\)\uff0c\u79f0\u4f5c\u65e0\u5411\u8fb9\uff0c\u5176\u4e2d \\(u,v\\in V\\)\u3002\u8bb0 \\(e=(u,v)\\)\uff0c\u5219 \\(u\\) \u548c \\(v\\) \u79f0\u4e3a \\(e\\) \u7684\u7aef\u70b9\uff1b</li> <li>\u6709\u5411\u56fe\uff1a \\(E\\) \u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u662f\u4e00\u4e2a\u6709\u5e8f\u4e8c\u5143\u7ec4 \\((u,v)\\)\uff0c\u6709\u65f6\u4e5f\u5199\u4f5c \\(u\\to v\\)\uff0c\u79f0\u4f5c\u6709\u5411\u8fb9\u6216\u5f27\u3002\u8bb0 \\(e=(u,v)\\)\uff0c\u79f0 \\(u\\) \u4e3a \\(e\\) \u7684\u8d77\u70b9\uff0c \\(v\\) \u4e3a \\(e\\) \u7684\u7ec8\u70b9\uff0c\u8d77\u70b9\u548c\u7ec8\u70b9\u4e5f\u79f0\u4e3a \\(e\\) \u7684\u7aef\u70b9\uff1b</li> <li>\u6df7\u5408\u56fe\uff1a \\(E\\) \u4e2d\u65e2\u6709\u6709\u5411\u8fb9\uff0c\u53c8\u6709\u65e0\u5411\u8fb9\u3002</li> </ul> <p>\u56fe\u4e3b\u8981\u5206\u4e3a\u6709\u5411\u56fe\u548c\u65e0\u5411\u56fe\uff0c\u65e0\u5411\u56fe\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6709\u5411\u56fe\uff0c\u65e0\u5411\u56fe\u5c31\u662f\u4e24\u70b9\u4e4b\u95f4\u8fde\u7740\u53cc\u65b9\u5411\u8fb9\u7684\u6709\u5411\u56fe\u3002\u5bf9\u4e8e\u65e0\u5411\u56fe\u4e2d\u7684\u8fb9 \\(ab\\)\uff0c\u5b58\u50a8\u4e24\u6761\u6709\u5411\u8fb9 \\(a\\rightarrow b, b\\rightarrow a\\)\u3002\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u53ea\u8003\u8651\u6709\u5411\u56fe\u7684\u5b58\u50a8\u3002</p> <p>\u82e5 \\(G\\) \u7684\u6bcf\u6761\u8fb9\u90fd\u88ab\u8d4b\u4e88\u4e00\u4e2a\u6570\u4f5c\u4e3a\u8be5\u8fb9\u7684\u6743\uff0c\u5219\u79f0 \\(G\\) \u4e3a\u8d4b\u6743\u56fe\u3002\u5982\u679c\u8fd9\u4e9b\u6743\u90fd\u662f\u6b63\u5b9e\u6570\uff0c\u5219\u79f0 \\(G\\) \u4e3a\u6b63\u6743\u56fe\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_3","title":"\u7b80\u5355\u56fe","text":"<ul> <li>\u81ea\u73af\uff1a\u5bf9 \\(E\\) \u4e2d\u7684\u8fb9 \\(e=(u,v)\\)\uff0c\u82e5 \\(u=v\\)\uff0c\u5219\u79f0 \\(e\\) \u662f\u4e00\u4e2a\u81ea\u73af\uff1b</li> <li>\u91cd\u8fb9\uff1a\u82e5\u5b58\u5728 \\(e_1,e_2\\in E\\) \u4f7f\u5f97 \\(e_1=e_2\\)\uff0c\u5219\u79f0\u5b83\u4eec\u662f\uff08\u4e00\u7ec4\uff09\u91cd\u8fb9\uff1b</li> <li>\u7b80\u5355\u56fe\uff1a\u82e5\u4e00\u4e2a\u56fe\u4e2d\u6ca1\u6709\u81ea\u73af\u548c\u91cd\u8fb9\uff0c\u5219\u5b83\u88ab\u79f0\u4e3a\u7b80\u5355\u56fe\uff1b</li> <li>\u591a\u91cd\u56fe\uff1a\u56fe\u4e2d\u5b58\u5728\u81ea\u73af\u6216\u91cd\u8fb9\u3002</li> </ul> <p>\u5728\u65e0\u5411\u56fe\u4e2d \\((u,v)\\) \u548c \\((v,u)\\) \u7b97\u4e00\u7ec4\u91cd\u8fb9\uff0c\u4f46\u5728\u6709\u5411\u56fe\u4e2d\u4e0d\u7b97\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_4","title":"\u90bb\u57df","text":"<p>\u5728\u65e0\u5411\u56fe \\(G=(V,E)\\) \u4e2d\uff0c\u82e5\u5bf9 \\(u,v\\in V\\)\uff0c\u5b58\u5728\u8fb9 \\((u,v)\\)\uff0c\u5219\u79f0 \\(u\\) \u548c \\(v\\) \u662f\u76f8\u90bb\u7684\u3002</p> <p>\u4e00\u4e2a\u9876\u70b9 \\(v \\in V\\) \u7684\u90bb\u57df\u662f\u6240\u6709\u4e0e\u4e4b\u76f8\u90bb\u7684\u9876\u70b9\u6240\u6784\u6210\u7684\u96c6\u5408\uff0c\u8bb0\u4f5c \\(N(v)\\)\u3002\u4e00\u4e2a\u70b9\u96c6 \\(S\\) \u7684\u90bb\u57df\u5b9a\u4e49\u5982\u4e0b\uff1a</p> \\[ N\\left( S \\right) =\\bigcup_{v\\in S}{N\\left( v \\right)} \\]"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_5","title":"\u5ea6\u6570","text":"<p>\u4e0e\u4e00\u4e2a\u9876\u70b9 \\(v\\) \u5173\u8054\u7684\u8fb9\u7684\u6761\u6570\u79f0\u4f5c\u8be5\u9876\u70b9\u7684\u5ea6\uff0c\u8bb0\u4f5c \\(d(v)\\)\u3002</p> <p>\u5bf9\u4e8e\u65e0\u5411\u7b80\u5355\u56fe\uff0c\u6709 \\(d(v)=|N(v)|\\)\u3002\u6839\u636e \\(d(v)\\) \u7684\u53d6\u503c\u53ef\u5bf9\u56fe\u4e2d\u7684\u9876\u70b9\u8fdb\u884c\u5206\u7c7b\uff1a</p> \\[ d\\left( v \\right) =\\begin{cases}     0, v\\text{\u662f\u5b64\u7acb\u70b9}\\\\     1, v\\text{\u662f\u53f6\u8282\u70b9}/\\text{\u60ac\u6302\u70b9}\\\\     2k, v\\text{\u662f\u5076\u70b9}\\\\     2k+1, v\\text{\u662f\u5947\u70b9}\\\\     \\left| V \\right|-1, v\\text{\u662f\u652f\u914d\u70b9}\\\\ \\end{cases} \\] <p>\u81ea\u73af \\((v,v)\\) \u5c06\u5bf9 \\(d(v)\\) \u4ea7\u751f \\(2\\) \u7684\u8d21\u732e\u3002</p> <p>\u5bf9\u4e8e\u56fe \\(G\\)\uff0c\u6240\u6709\u8282\u70b9\u7684\u5ea6\u6570\u7684\u6700\u5c0f\u503c\u79f0\u4e3a \\(G\\) \u7684\u6700\u5c0f\u5ea6\uff0c\u8bb0\u4f5c \\(\\delta (G)\\)\uff1b\u6700\u5927\u503c\u79f0\u4e3a\u6700\u5927\u5ea6\uff0c\u8bb0\u4f5c \\(\\Delta (G)\\)\u3002\u5373\uff1a \\(\\Delta \\left( G \\right) =\\max_{v\\in G} d\\left( v \\right)\\)\u3002\u82e5 \\(\\delta(G)=\\Delta(G)=k\\)\uff0c\u5373\u56fe\u4e2d\u6bcf\u4e2a\u9876\u70b9\u7684\u5ea6\u6570\u90fd\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u5e38\u6570 \\(k\\)\uff0c\u5219\u79f0 \\(G\\) \u4e3a \\(k\\) \u2212\u6b63\u5219\u56fe\u3002</p> <p>\u63e1\u624b\u5b9a\u7406\uff08\u56fe\u8bba\u57fa\u672c\u5b9a\u7406\uff09\uff1a\u5bf9\u4efb\u4f55\u65e0\u5411\u56fe\uff0c\u7531\u4e8e\u6bcf\u6761\u8fb9\u90fd\u4f1a\u8d21\u732e\u4e24\u4e2a\u5ea6\uff0c\u6240\u4ee5\uff1a</p> \\[ \\sum_{v\\in V}{d\\left( v \\right)}=2\\left| E \\right| \\] <p>\u4e0b\u9762\u8003\u8651\u6709\u5411\u56fe\u3002\u4ee5\u4e00\u4e2a\u9876\u70b9 \\(v\\) \u4e3a\u8d77\u70b9\u7684\u8fb9\u7684\u6761\u6570\u79f0\u4e3a\u8be5\u9876\u70b9\u7684\u51fa\u5ea6\uff0c\u8bb0\u4f5c \\(d^+(v)\\)\u3002\u4ee5\u4e00\u4e2a\u9876\u70b9 \\(v\\) \u4e3a\u7ec8\u70b9\u7684\u8fb9\u7684\u6761\u6570\u79f0\u4e3a\u8be5\u8282\u70b9\u7684\u5165\u5ea6\uff0c\u8bb0\u4f5c \\(d^-(v)\\)\u3002\u663e\u7136 \\(d^+(v)+d^-(v)=d(v)\\)\u3002\u7531\u4e8e\u6bcf\u6761\u8fb9\u90fd\u4f1a\u8d21\u732e\u4e00\u4e2a\u51fa\u5ea6\u548c\u4e00\u4e2a\u5165\u5ea6\uff0c\u6240\u4ee5\uff1a</p> \\[ \\sum_{v\\in V}{d^+\\left( v \\right)}=\\sum_{v\\in V}{d^-\\left( v \\right)}=\\left| E \\right| \\]"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_6","title":"\u8def\u5f84","text":"<ul> <li>\u9014\u5f84\uff1a\u9014\u5f84\u662f\u8fde\u63a5\u4e00\u8fde\u4e32\u9876\u70b9\u7684\u8fb9\u7684\u5e8f\u5217\uff0c\u53ef\u4ee5\u4e3a\u6709\u9650\u6216\u65e0\u9650\u957f\u5ea6\u3002\u5f62\u5f0f\u5316\u5730\u8bf4\uff0c\u4e00\u6761\u6709\u9650\u9014\u5f84 \\(w\\) \u662f\u4e00\u4e2a\u8fb9\u7684\u5e8f\u5217 \\(e_1, e_2, \\cdots, e_k\\)\uff0c\u4f7f\u5f97\u5b58\u5728\u4e00\u4e2a\u9876\u70b9\u5e8f\u5217 \\(v_0, v_1, \\cdots, v_k\\) \u6ee1\u8db3 \\(e_i = (v_{i-1}, v_i)\\) \u3002\u8fd9\u6837\u7684\u9014\u5f84\u53ef\u4ee5\u7b80\u5199\u4e3a \\(v_0 \\to v_1 \\to v_2 \\to \\cdots \\to v_k\\) \u3002\u901a\u5e38\u6765\u8bf4\uff0c\u8fb9\u7684\u6570\u91cf \\(k\\) \u88ab\u79f0\u4f5c\u8fd9\u6761\u9014\u5f84\u7684\u957f\u5ea6 (\u5982\u679c\u8fb9\u662f\u5e26\u6743\u7684\uff0c\u957f\u5ea6\u901a\u5e38\u6307\u9014\u5f84\u4e0a\u7684\u8fb9\u6743\u4e4b\u548c)\u3002</li> <li>\u8ff9\uff1a\u5bf9\u4e8e\u4e00\u6761\u9014\u5f84 \\(w\\)\uff0c\u82e5 \\(e_1, e_2, \\cdots, e_k\\) \u4e24\u4e24\u4e92\u4e0d\u76f8\u540c\uff0c\u5219\u79f0 \\(w\\) \u662f\u4e00\u6761\u8ff9\u3002</li> <li>\u8def\u5f84\uff1a\u5bf9\u4e8e\u4e00\u6761\u8ff9 \\(w\\)\uff0c\u82e5\u5176\u8fde\u63a5\u7684\u70b9\u7684\u5e8f\u5217\u4e2d\u70b9\u4e24\u4e24\u4e0d\u540c\uff0c\u5219\u79f0 \\(w\\) \u662f\u4e00\u6761\u8def\u5f84\u3002</li> </ul> <p>\u4ee5\u4e0a\u4e09\u8005\u7684\u533a\u522b\u5728\u4e8e\uff1a\u9014\u5f84\u7684\u8fb9\u548c\u9876\u70b9\u90fd\u53ef\u4ee5\u91cd\u590d\uff1b\u8ff9\u7684\u8fb9\u4e0d\u80fd\u91cd\u590d\uff0c\u4f46\u9876\u70b9\u53ef\u4ee5\u91cd\u590d\uff1b\u8def\u5f84\u7684\u8fb9\u548c\u9876\u70b9\u90fd\u4e0d\u80fd\u91cd\u590d\u3002</p> <ul> <li>\u56de\u8def\uff1a\u5bf9\u4e8e\u4e00\u6761\u8ff9 \\(w\\)\uff0c\u82e5 \\(v_0 = v_k\\)\uff0c\u5219\u79f0 \\(w\\) \u662f\u4e00\u6761\u56de\u8def\u3002</li> <li>\u73af / \u5708\uff1a\u5bf9\u4e8e\u4e00\u6761\u56de\u8def \\(w\\)\uff0c\u82e5 \\(v_0 = v_k\\) \u662f\u70b9\u5e8f\u5217\u4e2d\u552f\u4e00\u91cd\u590d\u51fa\u73b0\u7684\u70b9\u5bf9\uff0c\u5219\u79f0 \\(w\\) \u662f\u4e00\u4e2a\u73af\u3002</li> </ul> <p>\u5173\u4e8e\u8def\u5f84\u7684\u5b9a\u4e49\u5728\u4e0d\u540c\u5730\u65b9\u53ef\u80fd\u6709\u6240\u4e0d\u540c\uff0c\u5982\uff0c\u201c\u8def\u5f84\u201d\u53ef\u80fd\u6307\u672c\u6587\u4e2d\u7684\u201c\u9014\u5f84\u201d\uff0c\u201c\u73af\u201d\u53ef\u80fd\u6307\u672c\u6587\u4e2d\u7684\u201c\u56de\u8def\u201d\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_7","title":"\u8fde\u901a","text":"<p>\u5bf9\u4e8e\u4e00\u5f20\u65e0\u5411\u56fe \\(G = (V, E)\\)\uff0c\u5bf9\u4e8e \\(u, v \\in V\\)\uff0c\u82e5\u5b58\u5728\u4e00\u6761\u9014\u5f84\u4f7f\u5f97 $ v_0 = u, v_k = v$\uff0c\u5219\u79f0 \\(u\\) \u548c \\(v\\) \u662f\u8fde\u901a\u7684\u3002\u7531\u5b9a\u4e49\uff0c\u4efb\u610f\u4e00\u4e2a\u9876\u70b9\u548c\u81ea\u8eab\u8fde\u901a\uff0c\u4efb\u610f\u4e00\u6761\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u8fde\u901a\u3002</p> <p>\u82e5\u65e0\u5411\u56fe \\(G\\) \u6ee1\u8db3\u5176\u4e2d\u4efb\u610f\u4e24\u4e2a\u9876\u70b9\u5747\u8fde\u901a\uff0c\u5219\u79f0 \\(G\\) \u662f\u8fde\u901a\u56fe\uff0c \\(G\\) \u7684\u8fd9\u4e00\u6027\u8d28\u79f0\u4f5c\u8fde\u901a\u6027\u3002</p> <p>\u82e5 \\(H\\) \u662f \\(G\\) \u7684\u4e00\u4e2a\u8fde\u901a\u5b50\u56fe\uff0c\u4e14\u4e0d\u5b58\u5728 \\(F\\) \u6ee1\u8db3 \\(H\\subseteq F \\subseteq G\\) \u4e14 \\(F\\) \u4e3a\u8fde\u901a\u56fe\uff0c\u5219\u79f0 \\(H\\) \u662f \\(G\\) \u7684\u4e00\u4e2a\u8fde\u901a\u5757 / \u8fde\u901a\u5206\u91cf\u3002</p> <p>\u5bf9\u4e8e\u4e00\u5f20\u6709\u5411\u56fe \\(G = (V, E)\\)\uff0c\u5bf9\u4e8e \\(u, v \\in V\\)\uff0c\u82e5\u5b58\u5728\u4e00\u6761\u9014\u5f84\u4f7f\u5f97 \\(v_0 = u, v_k = v\\)\uff0c\u5219\u79f0 \\(u\\) \u53ef\u8fbe \\(v\\)\u3002\u7531\u5b9a\u4e49\uff0c\u4efb\u610f\u4e00\u4e2a\u9876\u70b9\u53ef\u8fbe\u81ea\u8eab\uff0c\u4efb\u610f\u4e00\u6761\u8fb9\u7684\u8d77\u70b9\u53ef\u8fbe\u7ec8\u70b9\u3002</p> <p>\u82e5\u6709\u5411\u56fe \\(G\\) \u6ee1\u8db3\u5176\u4e2d\u4efb\u610f\u4e24\u4e2a\u9876\u70b9\u4e92\u76f8\u53ef\u8fbe\uff0c\u5219\u79f0 \\(G\\) \u662f\u5f3a\u8fde\u901a\u7684\u3002\u82e5\u6709\u5411\u56fe \\(G\\) \u7684\u8fb9\u66ff\u6362\u4e3a\u65e0\u5411\u8fb9\u540e\u53ef\u4ee5\u5f97\u5230\u4e00\u5f20\u8fde\u901a\u56fe\uff0c\u5219\u79f0\u539f\u6765\u8fd9\u5f20\u6709\u5411\u56fe\u662f\u5f31\u8fde\u901a\u7684\u3002</p> <p>\u7c7b\u4f3c\u53ef\u5f97\u5f3a\u8fde\u901a\u5206\u91cf\u548c\u5f31\u8fde\u901a\u5206\u91cf\u7684\u5b9a\u4e49\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_8","title":"\u6811\u548c\u56fe\u7684\u5b58\u50a8","text":"<p>\u56fe\u7684\u8f93\u5165\u683c\u5f0f\u901a\u5e38\u4e3a\uff1a\u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f \\(n\\) \u548c \\(m\\)\uff0c\u4ee3\u8868 \\(|V|\\) \u548c \\(|E|\\)\u3002\u63a5\u4e0b\u6765 \\(m\\) \u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f \\(a\\)\uff0c \\(b\\) \u548c \\(c\\)\uff0c\u4ee3\u8868\u8d77\u70b9\uff0c\u7ec8\u70b9\u548c\u8fb9\u6743\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_9","title":"\u90bb\u63a5\u77e9\u9635","text":"<p>\u90bb\u63a5\u77e9\u9635\uff1a \\(g[a,b]\\) \u5b58\u50a8\u8fb9 \\(a \\rightarrow b\\)\uff0c\u904d\u5386\u6574\u5f20\u56fe\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^2)\\) \u4e14\u8f83\u8d39\u7a7a\u95f4(\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\) )\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_10","title":"\u8fb9\u96c6\u6570\u7ec4","text":"<p>\u8fb9\u96c6\u6570\u7ec4<code>e[i]</code>\u5b58\u50a8\u7b2c<code>i</code>\u6761\u8fb9\u7684\u8d77\u70b9<code>u</code>\u3001\u7ec8\u70b9<code>v</code>\u548c\u8fb9\u6743<code>w</code>\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(nm)\\)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m)\\)\u3002</p> <pre><code>struct edge {\n    int u, v, w;\n} e[M];  //\u8fb9\u96c6\nint vis[N];\n\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int i = 1; i &lt;= m; i++) {\n        if (e[i].u == u) {\n            int v = e[i].v, w = e[i].w;\n            printf(\"%d, %d, %d\\n\", u, v, w);\n            if (!vis[v]) dfs(e[i].v);\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        e[i] = {a, b, c};\n        //e[i] = {b, a, c};\n    }\n    dfs(1);\n    return 0;\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_11","title":"\u90bb\u63a5\u8868","text":"<p>\u90bb\u63a5\u8868\uff1a\u4f7f\u7528\u4e00\u4e2a\u652f\u6301\u52a8\u6001\u589e\u52a0\u5143\u7d20\u7684\u6570\u636e\u7ed3\u6784\u6784\u6210\u7684\u6570\u7ec4\uff0c\u5982<code>vector&lt;int&gt; adj[N]</code>\u6765\u5b58\u8fb9\uff0c\u5176\u4e2d<code>adj[u]</code>\u5b58\u50a8\u7684\u662f\u70b9 \\(u\\) \u7684\u6240\u6709\u51fa\u8fb9\u7684\u76f8\u5173\u4fe1\u606f (\u7ec8\u70b9\u3001\u8fb9\u6743\u7b49)\u3002</p> <pre><code>vector&lt;pair&lt;int, int&gt;&gt; adj[N];\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    while (m--) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        adj[a].emplace_back(b, c);\n    }\n    return 0;\n}\n</code></pre> <p>\u90bb\u63a5\u8868\u6709\u5f88\u591a\u79cd\u5b9e\u73b0\u65b9\u5f0f\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5355\u72ec\u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53\u6216\u8005\u5f00\u4e24\u4e2a<code>vector&lt;int&gt;</code>\u578b\u6570\u7ec4\u5206\u522b\u7528\u6765\u5b58\u50a8\u7ec8\u70b9\u548c\u8fb9\u6743\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u7528\u51fa\u8fb9\u6570\u7ec4<code>e[u][i]</code>\u5b58\u50a8<code>u</code>\u70b9\u6240\u6709\u51fa\u8fb9\u7684\u7ec8\u70b9<code>v</code>\u548c\u8fb9\u6743<code>w</code>\uff1a</p> <pre><code>struct edge{\n    int v, w;\n};\nvector&lt;edge&gt; e[N];  //\u8fb9\u96c6\n\nvoid dfs(int u, int father) {\n    for (auto ed : e[u]) {\n        int v = ed.v, w = ed.w;\n        if (v == father) continue;\n        printf(\"%d, %d, %d\\n\", u, v, w);\n        dfs(v, u);\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        e[a].push_back({b, c});\n        e[b].push_back({a, c});\n    }\n    dfs(1, 0);\n    return 0;\n}\n</code></pre> <p></p> <p>\u6ce8\u610f\u4ee5\u4e0a\u65b9\u6cd5\u4e0d\u80fd\u5904\u7406\u53cd\u5411\u8fb9\u3002</p> <p>\u590d\u6742\u5ea6\u5206\u6790\uff1a</p> <ul> <li>\u67e5\u8be2\u662f\u5426\u5b58\u5728 \\(u\\) \u5230 \\(v\\) \u7684\u8fb9\uff1a \\(O(d^+(u))\\)\uff1b</li> <li>\u904d\u5386\u70b9 \\(u\\) \u7684\u6240\u6709\u51fa\u8fb9\uff1a \\(O(d^+(u))\\)\uff1b</li> <li>\u904d\u5386\u6574\u5f20\u56fe\uff1a \\(O(n+m)\\)\uff1b</li> <li>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a \\(O(n+m)\\)\u3002</li> </ul>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_12","title":"\u94fe\u5f0f\u90bb\u63a5\u8868","text":"<p>\u94fe\u5f0f\u90bb\u63a5\u8868\u53ef\u4ee5\u5904\u7406\u53cd\u5411\u8fb9\u3002\u4f7f\u7528\u8fb9\u96c6\u6570\u7ec4<code>e[i]</code>\u5b58\u50a8\u7b2c<code>j</code>\u6761\u8fb9\u7684\u8d77\u70b9<code>u</code>\u3001\u7ec8\u70b9<code>v</code>\u548c\u8fb9\u6743<code>w</code>\uff0c\u8868\u5934\u6570\u7ec4<code>h[u][i]</code>\u5b58\u50a8<code>u</code>\u70b9\u7684\u6240\u6709\u51fa\u8fb9\u7684\u7f16\u53f7\u3002</p> <pre><code>struct edge {\n    int u, v, w;\n};\nvector&lt;edge&gt; e; //\u8fb9\u96c6\nvector&lt;int&gt; h[N];  //\u70b9\u7684\u6240\u6709\u51fa\u8fb9\n\nvoid add(int a, int b, int c) {\n    e.push_back({a, b, c});\n    h[a].push_back(e.size() - 1);\n}\n\nvoid dfs(int u, int father) {\n    for (int i = 0; i &lt; h[u].size(); i++) {\n        int j = h[u][i];\n        int v = e[j].v, w = e[j].w;\n        if (v == father) continue;\n        printf(\"%d, %d, %d\\n\", u, v, w);\n        dfs(v, u);\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n        add(b, a, c);\n    }\n    dfs(1, 0);\n    return 0;\n}\n</code></pre> <p></p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_13","title":"\u94fe\u5f0f\u524d\u5411\u661f(\u91cd\u8981)","text":"<p>\u4e4b\u524d\u7684\u90bb\u63a5\u8868\u662f\u57fa\u4e8e<code>vector</code>\u6765\u5b9e\u73b0\u7684\uff0c\u5982\u679c\u628a<code>vector</code>\u6362\u6210\u7528\u6570\u7ec4\u5b9e\u73b0\u7684\u94fe\u8868\uff0c\u6548\u7387\u5c06\u4f1a\u63d0\u9ad8\u5f88\u591a\uff0c\u800c\u8fd9\u6837\u5b9e\u73b0\u7684\u90bb\u63a5\u8868\u53c8\u88ab\u79f0\u4e3a\u94fe\u5f0f\u524d\u5411\u661f\u3002\u90bb\u63a5\u8868\u7c7b\u4f3c\u54c8\u5e0c\u8868\u7684\u62c9\u94fe\u6cd5\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u4ee3\u8868\u6bcf\u4e2a\u70b9\u53ef\u4ee5\u8d70\u5230\u54ea\u4e2a\u70b9\uff0c\u5355\u94fe\u8868\u5185\u90e8\u70b9\u7684\u6b21\u5e8f\u65e0\u5173\u7d27\u8981\u3002</p> <pre><code>int h[N], e[N], ne[N], idx;\nint w[N];  // \u7528\u6765\u5b58\u50a8\u6bcf\u6761\u8fb9\u7684\u6743\u91cd\n\n// \u5411\u56fe\u4e2d\u6dfb\u52a0a\u5230b\u7684\u6709\u5411\u8fb9\uff0c\u6743\u91cd\u4e3ac\nvoid add(int a, int b, int c) {\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\n\nint main() {\n    memset(h, -1, sizeof(h));  // \u4f7f\u7528\u94fe\u5f0f\u524d\u5411\u661f\u5fc5\u987b\u8fdb\u884c\u521d\u59cb\u5316\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    while (m--) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n\n    return 0;\n}\n</code></pre> <p>\u7cbe\u70bc\u7684\u6a21\u677f\u4ee3\u7801(\u65e0\u6743)\uff1a</p> <pre><code>//\u5bf9\u4e8e\u6bcf\u4e2a\u70b9k\uff0c\u5f00\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u5b58\u50a8k\u6240\u6709\u53ef\u4ee5\u8d70\u5230\u7684\u70b9\n//h[k]\u5b58\u50a8\u8fd9\u4e2a\u5355\u94fe\u8868\u7684\u5934\u7ed3\u70b9\nint h[N], e[M], ne[M], idx;\n\n//\u6dfb\u52a0\u4e00\u6761\u8fb9a-&gt;b\nvoid add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\n//\u521d\u59cb\u5316\nidx = 0;\nmemset(h, -1, sizeof h);\n</code></pre> <p>\u89e3\u6790\uff1a</p> <ul> <li><code>h[N]</code>: \u8868\u793a\u7b2c<code>i</code>\u4e2a\u8282\u70b9\u7684\u7b2c\u4e00\u6761\u8fb9\u7684<code>idx</code>\uff1b</li> <li><code>ne[M]</code>: \u8868\u793a\u4e0e\u7b2c<code>idx</code>\u6761\u8fb9\u540c\u8d77\u70b9\u7684\u4e0b\u4e00\u6761\u8fb9\u7684<code>idx</code>\uff1b</li> <li><code>e[M]</code>: \u8868\u793a\u7b2c<code>idx</code>\u6761\u8fb9\u7684\u7ec8\u70b9\uff1b</li> <li><code>N</code>: \u8282\u70b9\u6570\u91cf\uff1b</li> <li><code>M</code>: \u8fb9\u7684\u6570\u91cf\uff1b</li> <li><code>i</code>: \u8282\u70b9\u7684\u4e0b\u6807\u7d22\u5f15\uff1b</li> <li><code>idx</code>: \u8fb9\u7684\u4e0b\u6807\u7d22\u5f15\u3002</li> </ul> <p>\u53d8\u91cf\u521d\u59cb\u5316\u5b9a\u4e49\uff1a</p> <pre><code>int h[N], e[M], ne[M], idx;\n</code></pre> <p>\u5f53\u6211\u4eec\u52a0\u5165\u4e00\u6761\u8fb9\u7684\u65f6\u5019\uff1a</p> <pre><code>void add(int a, int b) {\n    e[idx] = b;     // \u8bb0\u5f55\u52a0\u5165\u7684\u8fb9\u7684\u7ec8\u70b9\u8282\u70b9\n    /*\n    h[a]\u8868\u793a\u8282\u70b9a\u4e3a\u8d77\u70b9\u7684\u7b2c\u4e00\u6761\u8fb9\u7684\u4e0b\u6807\uff0c\n    ne[idx] = h[a]\u8868\u793a\u628ah[a]\u8fd9\u6761\u8fb9\u63a5\u5728\u4e86idx\u8fd9\u6761\u8fb9\u7684\u540e\u9762\uff0c\n    \u5176\u5b9e\u4e5f\u5c31\u662f\u628aa\u8282\u70b9\u7684\u6574\u6761\u94fe\u8868 \u63a5\u5728\u4e86idx\u8fd9\u6761\u8fb9\u540e\u9762\uff1b\n    \u76ee\u7684\u5c31\u662f\u4e3a\u4e86\u4e0b\u4e00\u6b65\u628aidx\u8fd9\u6761\u8fb9\u5f53\u6210a\u8282\u70b9\u7684\u5355\u94fe\u8868\u7684\u7b2c\u4e00\u6761\u8fb9\uff0c\n    \u5b8c\u6210\u628a\u6700\u65b0\u7684\u4e00\u6761\u8fb9\u63d2\u5165\u5230\u94fe\u8868\u5934\u7684\u64cd\u4f5c\n    */\n    ne[idx] = h[a];\n    h[a] = idx++; //a\u8282\u70b9\u5f00\u5934\u7684\u7b2c\u4e00\u6761\u8fb9\u7f6e\u4e3a\u5f53\u524d\u8fb9\uff0cidx\u79fb\u52a8\u5230\u4e0b\u4e00\u6761\u8fb9\n}\n</code></pre> <p>\u8865\u5145\uff1a\u5e26\u6743\u56fe\u4e5f\u53ef\u4ee5\u5229\u7528<code>struct</code>\u6765\u5b9e\u73b0\u94fe\u5f0f\u524d\u5411\u661f(\u4e00\u4e2a\u8868\u5934\u6570\u7ec4\u60ac\u6302\u591a\u4e2a\u94fe\u8868)\uff0c\u4f7f\u7528\u8fb9\u96c6\u6570\u7ec4<code>e[i]</code>\u5b58\u50a8\u7b2c<code>i</code>\u6761\u51fa\u8fb9\u7684\u7ec8\u70b9<code>v</code>\u3001\u8fb9\u6743<code>w</code>\u548c\u4e0b\u4e00\u6761\u8fb9<code>ne</code>\uff1b\u4f7f\u7528\u8868\u5934\u6570\u7ec4<code>h[u]</code>\u5b58\u50a8<code>u</code>\u70b9\u7684\u7b2c\u4e00\u6761\u51fa\u8fb9\u7684\u7f16\u53f7\uff1b\u8fb9\u7684\u7f16\u53f7<code>idx</code>\u53ef\u53d6<code>0,1,2,3...</code>\u7b49\uff0c\u6ce8\u610f\u8d8a\u5f80\u540e\u63d2\u7684\u8fb9\u8d8a\u9760\u8fd1<code>h</code>\uff0c\u8fd9\u6837\u7684\u63d2\u5165\u65b9\u6cd5\u79f0\u4e3a\u5934\u63d2\u6cd5(\u5728<code>DFS</code>\u4e2d\uff0c\u540e\u63d2\u7684\u5148\u88ab\u8bbf\u95ee)\u3002</p> <pre><code>struct edge{\n    int v, w, ne;\n};\nedge e[M];  //\u8fb9\u96c6\nint idx, h[N];  //\u70b9\u7684\u7b2c\u4e00\u6761\u51fa\u8fb9\n\nvoid add(int a, int b, int c) {\n    e[idx] = {b, c, h[a]};\n    h[a] = idx++;\n}\n\nvoid dfs(int u, int father) {\n    for (int i = h[u]; ~i; i = e[i].ne) {  //\u5f53\u8d70\u5230-1\u65f6\uff0c-1\u53d6\u53cd\u5c31\u662f0\n        int v = e[i].v, w = e[i].w;\n        if (v == father) continue;\n        printf(\"%d, %d, %d\\n\", u, v, w);\n        dfs(v, u);\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n        add(b, a, c);\n    }\n    dfs(1, 0);\n    return 0;\n}\n</code></pre> <p></p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#_14","title":"\u6811\u548c\u56fe\u7684\u904d\u5386","text":"<p>\u5206\u4e3a\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u548c\u5e7f\u5ea6\u4f18\u5148\u904d\u5386\u3002</p>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#dfs","title":"\u6df1\u5ea6\u4f18\u5148\u904d\u5386DFS","text":"<p>\u4f8b\u9898\uff1a\u6811\u7684\u91cd\u5fc3</p> <p>\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u4e5f\u53eb\u6df1\u5ea6\u4f18\u5148\u641c\u7d22 (Depth First Search)\uff0c\u904d\u5386\u662f\u624b\u6bb5\uff0c\u641c\u7d22\u662f\u76ee\u7684\uff0c\u901a\u8fc7\u904d\u5386\u6240\u6709\u53ef\u80fd\u7684\u60c5\u51b5\u4ee5\u8fbe\u5230\u641c\u7d22\u7684\u76ee\u7684\uff0c\u56e0\u6b64\u300c\u904d\u5386\u300d\u548c\u300c\u641c\u7d22\u300d\u53ef\u4ee5\u770b\u4f5c\u662f\u4e24\u4e2a\u7684\u7b49\u4ef7\u6982\u5ff5\u3002</p> <p>\u300c\u4e00\u6761\u8def\u8d70\u5230\u5e95\uff0c\u4e0d\u649e\u5357\u5899\u4e0d\u56de\u5934\u300d\u662f\u5bf9DFS\u7684\u6700\u76f4\u89c2\u63cf\u8ff0\u3002DFS\u6700\u663e\u8457\u7684\u7279\u5f81\u5728\u4e8e\u5176\u9012\u5f52\u8c03\u7528\u81ea\u8eab\u3002DFS\u4f1a\u5bf9\u5176\u8bbf\u95ee\u8fc7\u7684\u70b9\u6253\u4e0a\u8bbf\u95ee\u6807\u8bb0\uff0c\u5728\u904d\u5386\u56fe\u65f6\u8df3\u8fc7\u5df2\u6253\u8fc7\u6807\u8bb0\u7684\u70b9\uff0c\u4ee5\u786e\u4fdd\u6bcf\u4e2a\u70b9\u4ec5\u8bbf\u95ee\u4e00\u6b21\u3002</p> <p>DFS\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n+m)\\) ( \\(n\\) \u8868\u793a\u70b9\u6570\uff0c \\(m\\) \u8868\u793a\u8fb9\u6570)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)\u3002</p> <p>\u91c7\u7528\u6811\u7684DFS\u53ef\u4ee5\u77e5\u9053\u6bcf\u4e00\u4e2a\u5b50\u6811\u70b9\u7684\u6570\u91cf\u3002</p> <p>\u57fa\u672c\u7b97\u6cd5\u6d41\u7a0b\u4e3a\uff1a</p> <pre><code>1. Initialize all vertices as NOT_VISITED\n2. Choose a starting vertex s\n3. Call DFS_Visit(s)\n\nDFS_Visit(u):\n    1. Mark u as VISITED\n    2. Perform any pre-processing or operations on u\n    3. for each vertex v adjacent to u:\n        3.1 if v is NOT_VISITED:\n            3.1.1 DFS_Visit(v)\n    4. Perform any post-processing or operations on u\n</code></pre> <p>\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>-- u.color can be WHITE, GRAY, or BLACK, \n-- indicating whether a vertex is unvisited, currently being visited, or already visited, respectively\nDFS(G):\n    for each vertex u in G.V:\n        u.color = WHITE\n        u.\u03c0 = NIL\n    time = 0\n    for each vertex u in G.V:\n        if u.color == WHITE:\n            DFS-VISIT(G, u)\n\nDFS-VISIT(G, u):\n    time = time + 1\n    u.d = time\n    u.color = GRAY\n    for each v in G.Adj[u]:\n        if v.color == WHITE:\n            v.\u03c0 = u\n            DFS-VISIT(G, v)\n    u.color = BLACK\n    time = time + 1\n    u.f = time\n</code></pre> <p>\u4ee3\u7801\u6a21\u677f\u4e3a\uff1a</p> <pre><code>int dfs(int u) {  //\u4ece\u8282\u70b9u\u5f00\u59cb\u8fdb\u884c\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\n    st[u] = true;  //st[u]\u8868\u793a\u70b9u\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7 \n\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int v = e[i];\n        if (!st[v]) dfs(v);\n    }\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/02_Graph_Tree_Basics/#bfs","title":"\u5e7f\u5ea6\u4f18\u5148\u904d\u5386BFS","text":"<p>\u4f8b\u9898\uff1a \u56fe\u4e2d\u70b9\u7684\u5c42\u6b21</p> <p>\u5e7f\u5ea6\u4f18\u5148\u904d\u5386\uff08Breadth First Search\uff09\u6bcf\u6b21\u90fd\u5c1d\u8bd5\u8bbf\u95ee\u540c\u4e00\u5c42\u7684\u8282\u70b9\u3002 \u5982\u679c\u540c\u4e00\u5c42\u90fd\u8bbf\u95ee\u5b8c\u4e86\uff0c\u518d\u8bbf\u95ee\u4e0b\u4e00\u5c42\u3002\u8fd9\u6837\u505a\u7684\u7ed3\u679c\u662f\uff0cBFS\u7b97\u6cd5\u627e\u5230\u7684\u8def\u5f84\u662f\u4ece\u8d77\u70b9\u5f00\u59cb\u7684\u6700\u77ed\u5408\u6cd5\u8def\u5f84\u3002</p> <p>\u7b97\u6cd5\u8fc7\u7a0b\u53ef\u4ee5\u770b\u505a\u662f\u56fe\u4e0a\u706b\u82d7\u4f20\u64ad\u7684\u8fc7\u7a0b\uff1a\u6700\u5f00\u59cb\u53ea\u6709\u8d77\u70b9\u7740\u706b\u4e86\uff0c\u5728\u6bcf\u4e00\u65f6\u523b\uff0c\u6709\u706b\u7684\u8282\u70b9\u90fd\u5411\u5b83\u76f8\u90bb\u7684\u6240\u6709\u8282\u70b9\u4f20\u64ad\u706b\u82d7\u3002</p> <p>\u7b97\u6cd5\u57fa\u672c\u6d41\u7a0b\u4e3a\uff1a</p> <pre><code>1. Initialize all vertices as NOT_VISITED\n2. Choose a starting vertex s\n3. Mark s as VISITED\n4. Enqueue s into a queue Q\n5. while Q is not empty:\n    5.1 u = Dequeue(Q)\n    5.2 Perform any operations on u\n    5.3 for each vertex v adjacent to u:\n        5.3.1 if v is NOT_VISITED:\n            5.3.1.1 Mark v as VISITED\n            5.3.1.2 Enqueue v into Q\n</code></pre> <p>\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>-- u.color can be WHITE, GRAY, or BLACK, \n-- indicating whether a vertex is unvisited, currently being visited, or already visited, respectively\nBFS(G, s):\n    for each vertex u in G.V - {s}:\n        u.color = WHITE\n        u.d = \u221e\n        u.\u03c0 = NIL\n    s.color = GRAY\n    s.d = 0\n    s.\u03c0 = NIL\n    Q = \u2205\n    ENQUEUE(Q, s)\n    while Q \u2260 \u2205:\n        u = DEQUEUE(Q)\n        for each v in G.Adj[u]:\n            if v.color == WHITE:\n                v.color = GRAY\n                v.d = u.d + 1\n                v.\u03c0 = u\n                ENQUEUE(Q, v)\n        u.color = BLACK\n</code></pre> <p>\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n+m)\\)\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\u4e3a\uff1a</p> <pre><code>void bfs(int u) {  //\u4ece\u8282\u70b9u\u5f00\u59cb\u8fdb\u884c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\n    queue&lt;int&gt; q;\n    st[u] = true;  //\u8868\u793au\u53f7\u70b9\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\n    q.push(u);\n\n    while (q.size()) {  //\u4e5f\u53ef\u5199!q.empty()\n        auto t = q.front();\n        q.pop();\n\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int v = e[i];\n            if (!st[v]) {\n                st[v] = true;  // \u8868\u793a\u70b9j\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\n                q.push(v);\n            }\n        }\n    }\n}\n</code></pre> <p>\u5728BFS\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e5f\u53ef\u4ee5\u8bb0\u5f55\u4e00\u4e9b\u989d\u5916\u7684\u4fe1\u606f\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u4e00\u4e2a<code>d</code>\u6570\u7ec4\u7528\u4e8e\u8bb0\u5f55\u8d77\u70b9\u5230\u67d0\u4e2a\u8282\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u518d\u5f00\u4e00\u4e2a<code>p</code>\u6570\u7ec4\u8bb0\u5f55\u662f\u4ece\u54ea\u4e2a\u8282\u70b9\u8d70\u5230\u5f53\u524d\u8282\u70b9\u7684\u3002</p> <pre><code>void bfs(int u) {\n    queue&lt;int&gt; q;\n    st[u] = true;\n    q.push(u);\n    d[u] = 0, p[u] = -1;  // \u5047\u8bbe\u8282\u70b9\u7684\u7f16\u53f7\u5747\u4e3a\u6b63\u6574\u6570\n\n    while (!q.empty()) {\n        auto t = q.front();\n        q.pop();\n\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int v = e[i];\n            if (!st[v]) {\n                st[v] = true, q.push(v);\n                d[v] = d[t] + 1, p[v] = t;\n            }\n        }\n    }\n}\n</code></pre> <p>\u5047\u8bbe\u8def\u5f84\u7ec8\u70b9\u662f<code>x</code>\uff0c\u90a3\u4e48\u4ece<code>u</code>\u5230<code>x</code>\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\u5c31\u662f<code>d[x]</code>\uff0c\u76f8\u5e94\u5730\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e<code>p</code>\u6570\u7ec4\u8fd8\u539f\u51fa\u8fd9\u6761\u8def\u5f84\uff1a</p> <pre><code>vector&lt;int&gt; restore(int x) {\n    vector&lt;int&gt; path;\n    for (int v = x; ~v; v = p[v])\n        path.push_back(v);\n    reverse(path.begin(), path.end());\n    return path;\n}\n</code></pre> <p>\u4f8b\u9898\uff1a\u6709\u5411\u56fe\u7684\u62d3\u6251\u5e8f\u5217</p> <p>\u82e5\u4e00\u4e2a\u7531\u56fe\u4e2d\u6240\u6709\u70b9\u6784\u6210\u7684\u5e8f\u5217 \\(A\\) \u6ee1\u8db3\uff1a\u5bf9\u4e8e\u56fe\u4e2d\u7684\u6bcf\u6761\u8fb9 \\((x,y)\\)\uff0c \\(x\\) \u5728 \\(A\\) \u4e2d\u90fd\u51fa\u73b0\u5728y\u4e4b\u524d\uff0c\u5219\u79f0 \\(A\\) \u662f\u8be5\u56fe\u7684\u4e00\u4e2a \u62d3\u6251\u5e8f\u5217\u3002</p> <p>\u53ef\u4ee5\u8bc1\u660e\uff0c \u6709\u5411\u65e0\u73af\u56fe\u5fc5\u5b58\u5728\u62d3\u6251\u5e8f\u5217\uff0c\u56e0\u6b64\u6709\u5411\u65e0\u73af\u56fe\u4e5f\u88ab\u79f0\u4e3a \u62d3\u6251\u56fe\u3002\u5982\u679c\u6709\u5411\u56fe\u5b58\u5728\u73af\uff0c\u5219\u4e0d\u5b58\u5728\u62d3\u6251\u5e8f\u5217\u3002\u62d3\u6251\u5e8f\u5217\u53ef\u80fd\u4e0d\u552f\u4e00\u3002</p> <p>\u6709\u5411\u56fe\u4e2d\u5165\u5ea6\u4e3a<code>0</code>\u7684\u70b9\u53ef\u4ee5\u4f5c\u4e3a\u62d3\u6251\u5e8f\u5217\u7684\u8d77\u70b9\uff0c\u5c06\u8fd9\u4e9b\u5165\u5ea6\u4e3a<code>0</code>\u7684\u70b9\u5165\u961f\uff0c\u518d\u8fdb\u884cBFS\u3002\u6ce8\u610f\uff1a\u4e00\u4e2a\u6709\u5411\u65e0\u73af\u56fe\u4e00\u5b9a\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u5165\u5ea6\u4e3a<code>0</code>\u7684\u70b9\u3002\u5bfb\u627e\u6709\u5411\u56fe\u7684\u62d3\u6251\u5e8f\u5217\u7684\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>queue &lt;- \u6240\u6709\u5165\u5ea6\u4e3a0\u7684\u70b9;\n\nwhile (queue\u975e\u7a7a) {\n    t &lt;- \u961f\u5934 \u5e76\u51fa\u961f;\n    \u679a\u4e3et\u7684\u6240\u6709\u51fa\u8fb9: t-&gt;j;\n    \u5220\u6389 t-&gt;j, j\u7684\u5165\u5ea6: d[j]--;\n    if (d[j] == 0) \n        \u8ba9j\u5165\u961f: queue &lt;- j;\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/","title":"\u6700\u77ed\u8def\u95ee\u9898","text":"<p>\u6700\u77ed\u8def\u95ee\u9898\u7684\u5206\u7c7b(\u4ee5\u4e0b \\(n\\) \u4e3a\u56fe\u7684\u70b9\u6570\uff0c \\(m\\)\u4e3a\u56fe\u7684\u8fb9\u6570)\uff1a</p> <ul> <li>\u5355\u6e90\u6700\u77ed\u8def\uff1a\u6c42\u4e00\u4e2a\u70b9\u5230\u5176\u4ed6\u6240\u6709\u70b9\u7684\u6700\u77ed\u8def</li> <li>\u56fe\u4e2d\u6240\u6709\u8fb9\u6743\u90fd\u662f\u6b63\u6570\uff1a<ul> <li>\u6734\u7d20Dijkstra\u7b97\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^2)\\)\uff0c\u6bd4\u8f83\u9002\u7528\u4e8e\u7a20\u5bc6\u56fe (\u4f8b\u5982\uff1a \\(m\\) \u548c \\(n^2\\) \u5728\u540c\u4e00\u6570\u91cf\u7ea7)</li> <li>\u5806\u4f18\u5316\u7248\u7684Dijkstra\u7b97\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(m\\log n)\\)\uff0c\u6bd4\u8f83\u9002\u7528\u4e8e\u7a00\u758f\u56fe (\u4f8b\u5982\uff1a \\(m\\) \u548c \\(n\\) \u5728\u540c\u4e00\u6570\u91cf\u7ea7)</li> </ul> </li> <li>\u56fe\u4e2d\u5b58\u5728\u8d1f\u6743\u8fb9\uff1a<ul> <li>Bellman-Ford\u7b97\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(nm)\\)\uff0c\u9002\u7528\u4e8e\u6c42\u4e0d\u8d85\u8fc7 \\(k\\) \u6761\u8fb9\u7684\u6700\u77ed\u8def</li> <li>SPFA: \u662fBellman-Ford\u7b97\u6cd5\u7684\u4f18\u5316\uff0c\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m)\\)\uff0c\u6700\u574f \\(O(nm)\\)\uff0c\u76f8\u5bf9\u5e94\u7528\u9650\u5236\u6700\u5c11</li> </ul> </li> <li>\u591a\u6e90\u6c47\u6700\u77ed\u8def\uff1a\u8d77\u70b9\u548c\u7ec8\u70b9\u662f\u4e0d\u786e\u5b9a\u7684</li> <li>Floyd\u7b97\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^3)\\)</li> </ul> <p>\u4ee5\u4e0a\u5206\u7c7b\u4e2d\u53ef\u4ee5\u4e0d\u533a\u5206\u6709\u5411\u56fe\u548c\u65e0\u5411\u56fe\uff0c\u56e0\u4e3a\u53ef\u4ee5\u901a\u8fc7\u5c06\u65e0\u5411\u56fe\u70b9\u4e4b\u95f4\u8fde\u4e24\u6761\u6709\u5411\u8fb9\u6765\u8f6c\u5316\u4e3a\u6709\u5411\u56fe\uff0c\u56e0\u6b64\u53ef\u4ee5\u53ea\u8003\u8651\u6709\u5411\u8fb9\u3002</p> <p>\u6700\u77ed\u8def\u7b97\u6cd5\u5e38\u8003\u5bdf\u6a21\u578b\u7684\u5efa\u7acb(\u5efa\u56fe)\uff0c\u4e5f\u5c31\u662f\u5982\u4f55\u628a\u539f\u95ee\u9898\u62bd\u8c61\u6210\u6700\u77ed\u8def\u95ee\u9898\uff0c\u800c\u4e0d\u662f\u539f\u7406\u3002</p> <ul> <li>\u6700\u77ed\u8def\u95ee\u9898</li> <li>Dijkstra\u7b97\u6cd5<ul> <li>\u6734\u7d20Dijkstra\u7b97\u6cd5</li> <li>\u5806\u4f18\u5316\u7684Dijkstra\u7b97\u6cd5</li> </ul> </li> <li>Bellman-Ford\u7b97\u6cd5</li> <li>SPFA</li> <li>Floyd\u7b97\u6cd5</li> </ul>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/#dijkstra","title":"Dijkstra\u7b97\u6cd5","text":""},{"location":"zh/Graph_and_Search/03_Shortest_Path/#dijkstra_1","title":"\u6734\u7d20Dijkstra\u7b97\u6cd5","text":"<p>\u6734\u7d20Dijkstra\u7b97\u6cd5\u57fa\u4e8e\u8d2a\u5fc3\uff0c\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a</p> <pre><code>function Dijkstra(Graph, source):\n    distance[source] \u2190 0                 --\u521d\u59cb\u5316\u8d77\u70b9\u8ddd\u79bb\n    for each vertex v in Graph:             \n        if v \u2260 source\n            distance[v] \u2190 infinity       --\u521d\u59cb\u5316\u5176\u4ed6\u70b9\u8ddd\u79bb\n            previous[v] \u2190 undefined      --v\u7684\u524d\u9a71\n        end if\n    end for\n\n    visitedSet \u2190 empty set               --\u5f53\u524d\u5df2\u786e\u5b9a\u6700\u77ed\u8ddd\u79bb\u7684\u70b9\n\n    while size of visitedSet &lt; size of Graph:\n        --\u7528\u4e0d\u5728visitedSet\u4e2d\u7684\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u66f4\u65b0current\n        current \u2190 vertex not in visitedSet with smallest distance\n\n        add current to visitedSet\n\n        --\u7528current\u66f4\u65b0\u5176\u4ed6\u70b9\u7684\u8ddd\u79bb\n        for each neighbor v of current:  --Consider all neighbors\n            if v not in visitedSet:\n                alt \u2190 distance[current] + weight(current, v)\n                if alt &lt; distance[v]:    --\u4e00\u4e2a\u8ddd\u79bbv\u7684\u66f4\u77ed\u8ddd\u79bb\u88ab\u627e\u5230\n                    distance[v] \u2190 alt\n                    previous[v] \u2190 current\n                end if\n            end if\n        end for\n    end while\n\n    return distance[], previous[]\nend function\n</code></pre> <p>\u6734\u7d20Dijkstra\u7b97\u6cd5\u9002\u7528\u4e8e\u7a20\u5bc6\u56fe\uff0c\u53ef\u4ee5\u7528\u90bb\u63a5\u77e9\u9635\u6765\u5b58\u56fe\u3002</p> <p>\u4f8b\u9898\uff1aDijkstra\u6c42\u6700\u77ed\u8def I</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int g[N][N];  // \u5b58\u50a8\u6bcf\u6761\u8fb9\nint dist[N];  // \u5b58\u50a81\u53f7\u70b9\u5230\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\nbool st[N];  // \u5b58\u50a8\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8def\u662f\u5426\u5df2\u7ecf\u786e\u5b9a\n\n// \u6c421\u53f7\u70b9\u5230n\u53f7\u70b9\u7684\u6700\u77ed\u8def\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5219\u8fd4\u56de-1\nint dijkstra() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        int t = -1;\n        // \u5728\u8fd8\u672a\u786e\u5b9a\u6700\u77ed\u8def\u7684\u70b9\u4e2d\uff0c\u5bfb\u627e\u8ddd\u79bb\u6700\u5c0f\u7684\u70b9\n        for (int j = 1; j &lt; = n; j++) {\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        }\n\n        // \u7528t\u66f4\u65b0\u5176\u4ed6\u70b9\u7684\u8ddd\u79bb\n        for (int j = 1; j &lt; n; j++) {\n            dist[j] = min(dist[j], dist[t] +g[t][j]);\n        }\n\n        st[t] = true;\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n</code></pre> <p>\u8865\u5145\uff1a\u7528\u90bb\u63a5\u8868\u5b58\u56fe\u7684\u53e6\u4e00\u79cd\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>struct edge {\n    int v, w;\n};\n//e[u]\u5b58\u8282\u70b9u\u7684\u6240\u6709\u51fa\u8fb9\u7684\u7ec8\u70b9\u548c\u8fb9\u6743\nvector&lt;edge&gt; e[N];\n//d[u]\u5b58u\u5230\u6e90\u70b9s\u7684\u6700\u5c0f\u8ddd\u79bb\uff0cvis[u]\u6807\u8bb0u\u662f\u5426\u51fa\u5708\nint d[N], vis[N];\n\nvoid dijkstra(int s) {\n    //\u521d\u59cb\u65f6\u6240\u6709\u70b9\u90fd\u5728\u5708(\u96c6\u5408)\u5185\uff0cvis = 0, d[s] = 0, d[\u5176\u4ed6\u70b9] = \u6b63\u65e0\u7a77\n    for (int i = 0; i &lt;= n; i++) d[i] = inf;\n    d[s] = 0;\n\n    //\u91cd\u590d\u5982\u4e0b\u64cd\u4f5c\u76f4\u5230\u5708\u5185\u4e3a\u7a7a\n    for (int i = 1; i &lt; n; i++) {\n        //\u4ece\u5708\u5185\u9009\u4e00\u4e2a\u8ddd\u79bb\u6700\u5c0f\u7684\u70b9u\uff0c\u6253\u6807\u8bb0\u79fb\u51fa\u5708(\u8be5\u7b97\u6cd5\u6027\u80fd\u74f6\u9888)\n        int u = 0;\n        for (int j = 1; j &lt;= n; j++) {  //\u679a\u4e3e\u70b9\n            if (!vis[j] &amp;&amp; d[j] &lt; d[u]) u = j;\n        }\n        vis[u] = 1; //\u6807\u8bb0u\u5df2\u7ecf\u51fa\u5708\n\n        //\u5bf9u\u7684\u6240\u6709\u51fa\u8fb9\u6267\u884c\u677e\u5f1b\u64cd\u4f5c\uff0c\u5373\u5c1d\u8bd5\u66f4\u65b0\u90bb\u70b9v\u7684\u6700\u5c0f\u8ddd\u79bb\n        for (auto ed : e[u]) {  //\u679a\u4e3e\u90bb\u8fb9\n            int v = ed.v, w = ed.w;\n            if (d[v] &gt; d[u] + w) d[v] = d[u] + w;\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        e[a].push_back({b, c});\n    }\n    dijkstra(1);\n}\n</code></pre> <p>\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^2+m)\\approx O(n^2)\\)\uff0c \\(n\\) \u4e3a\u56fe\u7684\u70b9\u6570\uff0c \\(m\\)\u4e3a\u56fe\u7684\u8fb9\u6570</p>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/#dijkstra_2","title":"\u5806\u4f18\u5316\u7684Dijkstra\u7b97\u6cd5","text":"<p>\u4f7f\u7528\u5806\u6765\u5b58\u50a8\u8d77\u70b9\u5230\u6240\u6709\u70b9\u7684\u8ddd\u79bb\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u53d8\u4e3a \\(O(m\\log n)\\)\u3002\u5806\u7684\u5b9e\u73b0\u53ef\u4ee5\u91c7\u7528\u624b\u5199\u652f\u6301\u4fee\u6539\u4efb\u610f\u5143\u7d20\u7684\u5806(\u5806\u4e2d\u6709 \\(n\\) \u4e2a\u6570)\uff0c\u4e5f\u53ef\u4ee5\u7528C++\u7684\u4f18\u5148\u961f\u5217\u6570\u636e\u7ed3\u6784<code>priority_queue</code>(Python\u53ef\u4ee5\u76f4\u63a5\u7528<code>set</code>)\uff0c\u5806\u4e2d\u6709 \\(m\\) \u4e2a\u6570(\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u53d8\u4e3a \\(O(m \\log m)\\)\uff0c\u4f46\u4f9d\u7136\u548c \\(O(m\\log n)\\)\u76f8\u8fd1)\u3002</p> <p>\u7531\u4e8e\u56fe\u4e3a\u7a00\u758f\u56fe\uff0c\u6545\u9700\u91c7\u7528\u90bb\u63a5\u8868\u5b58\u50a8\u56fe\u3002</p> <p>\u4f8b\u9898\uff1aDijkstra\u6c42\u6700\u77ed\u8def II</p> <p>\u5806\u4f18\u5316\u7248\u7684Dijkstra\u662f\u5bf9\u6734\u7d20\u7248Dijkstra\u8fdb\u884c\u4e86\u4f18\u5316\uff0c\u5728\u6734\u7d20\u7248Dijkstra\u4e2d\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u9ad8\u7684\u5bfb\u627e\u8ddd\u79bb\u6700\u77ed\u7684\u70b9(\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^2)\\) \u7684\u8fd9\u4e00\u8fc7\u7a0b)\u53ef\u4ee5\u4f7f\u7528\u5c0f\u6839\u5806\u4f18\u5316\u3002</p> <ol> <li>\u4e00\u53f7\u70b9\u7684\u8ddd\u79bb\u521d\u59cb\u5316\u4e3a\u96f6\uff0c\u5176\u4ed6\u70b9\u521d\u59cb\u5316\u6210\u65e0\u7a77\u5927\u3002</li> <li>\u5c06\u4e00\u53f7\u70b9\u653e\u5165\u5806\u4e2d\u3002</li> <li>\u4e0d\u65ad\u5faa\u73af\uff0c\u76f4\u5230\u5806\u7a7a\u3002\u6bcf\u4e00\u6b21\u5faa\u73af\u4e2d\u6267\u884c\u7684\u64cd\u4f5c\u4e3a\uff1a</li> <li>\u5f39\u51fa\u5806\u9876(\u4e0e\u6734\u7d20\u7248Dijkstra\u627e\u5230<code>visitedSet</code>\u5916\u8ddd\u79bb\u6700\u77ed\u7684\u70b9\u76f8\u540c\uff0c\u5e76\u6807\u8bb0\u8be5\u70b9\u6700\u77ed\u8def\u5f84\u5df2\u7ecf\u786e\u5b9a)\uff1b</li> <li>\u7528\u8be5\u70b9\u66f4\u65b0\u4e34\u754c\u70b9\u7684\u8ddd\u79bb\uff0c\u82e5\u66f4\u65b0\u6210\u529f\u5c31\u52a0\u5165\u5230\u5806\u4e2d\u3002</li> </ol> <p>\u4ee3\u7801\u6a21\u677f(\u4f7f\u7528\u5c0f\u6839\u5806)\uff1a</p> <pre><code>typedef pair&lt;int, int&gt; PII;\n\nint n;  // \u70b9\u7684\u6570\u91cf\nint h[N], w[N], e[N], ne[N], idx;  // \u90bb\u63a5\u8868\u5b58\u50a8\u6240\u6709\u8fb9\nint dist[N];  // \u5b58\u50a8\u6240\u6709\u70b9\u52301\u53f7\u70b9\u7684\u8ddd\u79bb\nbool st[N];  // \u5b58\u50a8\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u662f\u5426\u5df2\u786e\u5b9a\n\n// \u6c421\u53f7\u70b9\u5230n\u53f7\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de-1\nint dijkstra() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    // first\u5b58\u50a8\u8ddd\u79bb\uff0csecond\u5b58\u50a8\u8282\u70b9\u7f16\u53f7\n    heap.push({0, 1});\n\n    while (heap.size()) {\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] &gt; distance + w[i]) {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n</code></pre> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m \\log n)\\)\uff0c\u5176\u4e2d \\(n\\) \u8868\u793a\u70b9\u6570\uff0c \\(m\\) \u8868\u793a\u8fb9\u6570</p> <p>\u8865\u5145\uff1a\u4f7f\u7528<code>struct</code>\u7684\u4e14\u8bb0\u5f55\u8def\u5f84\u5e76\u9012\u5f52\u8f93\u51fa\u7684\u5806\u4f18\u5316\u7248Dijkstra\u7b97\u6cd5\u6a21\u677f\u5982\u4e0b(\u6b64\u5904\u4f7f\u7528\u5927\u6839\u5806)\uff1a</p> <pre><code>struct edge {\n    int v, w;\n};\nvector&lt;edge&gt; e[N];\nint d[N], vis[N], pre[N];\n\n//\u521b\u5efa\u4e00\u4e2apair\u7c7b\u578b\u7684\u5927\u6839\u5806q{-\u8ddd\u79bb, \u70b9}\uff0c\u628a\u8ddd\u79bb\u53d6\u8d1f\u503c\uff0c\u8ddd\u79bb\u6700\u5c0f\u7684\u5143\u7d20\u6700\u5927\uff0c\u5fc5\u5728\u5806\u9876\npriority_queue&lt;pair&lt;int, int&gt;&gt; q;\n\nvoid dijkstra(int s) {\n    //\u521d\u59cb\u5316\uff1a{0, s}\u5165\u961f\uff0cd[s] = 0\uff0cd[\u5176\u4ed6\u70b9]=\u6b63\u65e0\u7a77\n    for (int i = 0; i &lt;= n; i++) d[i] = inf;\n    d[s] = 0;\n    q.push({0, s});\n\n    //\u91cd\u590d\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\n    while (q.size()) {\n        //\u4ece\u961f\u5934\u5f39\u51fa\u8ddd\u79bb\u6700\u4e0b\u7684\u70b9u\n        auto t = q.top();\n        q.pop();\n\n        //\u82e5u\u6269\u5c55\u8fc7\u5219\u8df3\u8fc7\uff0c\u5426\u5219\u6253\u6807\u8bb0\n        int u = t.second;\n        if (vis[u]) continue;  //\u518d\u6b21\u51fa\u961f\u7684\uff0c\u8df3\u8fc7\n        vis[u] = 1;  //\u6807\u8bb0u\u5df2\u51fa\u961f\n\n        //\u5bf9u\u7684\u6240\u6709\u51fa\u8fb9\u6267\u884c\u677e\u5f1b\u64cd\u4f5c\uff0c\u628a{-d[v], v}\u538b\u5165\u961f\u5c3e\n        for (auto ed : e[u]) {\n            int v = ed.v, w = ed.w;\n            if (d[v] &gt; d[u] + w) {\n                d[v] = d[u] + w;\n                pre[v] = u;\n                q.push({-d[v], v});  //\u5927\u6839\u5806\n            }\n        }\n    }\n}\n\nvoid dfs_path(int u) {\n    if (u == s) {\n        printf(\"%d \", u);\n        return;\n    }\n    dfs_path(pre[u]);\n    printf(\"%d \", u);\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/#bellman-ford","title":"Bellman-Ford\u7b97\u6cd5","text":"<p>Bellman-Ford\u7b97\u6cd5\u7684\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a</p> <pre><code>function BellmanFord(Graph, source):\n    for each vertex v in Graph:\n        distance[v] \u2190 infinity\n        predecessor[v] \u2190 null\n    end for\n    distance[source] \u2190 0\n\n    --\u677e\u5f1b\u64cd\u4f5c\n    for i from 1 to |V| - 1:                  --|V|\u4e3a\u9876\u70b9\u6570\n        for each edge (u, v) in Graph:\n            if distance[u] + weight(u, v) &lt; distance[v]:\n                distance[v] \u2190 distance[u] + weight(u, v)\n                predecessor[v] \u2190 u\n            end if\n        end for\n    end for\n\n    for each edge (u, v) in Graph:\n        --\u5982\u679c\u8fd8\u5b58\u5728\u4e0d\u6ee1\u8db3\u4e09\u89d2\u4e0d\u7b49\u5f0f\u7684\u60c5\u51b5\n        if distance[u] + weight(u, v) &lt; distance[v]:\n            print \"Graph contains a negative-weight cycle\"\n            return\n        end if\n    end for\n\n    return distance[], predecessor[]\nend function\n</code></pre> <p>\u56fe\u4e2d\u5b58\u5728\u8d1f\u6743\u56de\u8def\u65f6\uff0c\u53ef\u80fd\u4e0d\u5b58\u5728\u4ece\u8d77\u70b9\u5230\u76ee\u6807\u70b9\u7684\u6700\u77ed\u8def\u5f84\uff0c\u4f8b\u5982\u5f53\u8def\u5f84\u4e0a\u5b58\u5728\u8d1f\u6743\u56de\u8def\u65f6\uff0c\u53ef\u4ee5\u6cbf\u7740\u8be5\u56de\u8def\u65e0\u9650\u5faa\u73af\uff0c\u5bfc\u81f4\u6700\u77ed\u8def\u5f84\u53d8\u4e3a \\(-\\infty\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u6709\u8fb9\u6570\u9650\u5236\u7684\u6700\u77ed\u8def</p> <p>\u6ce8\u610f\u5728\u8be5\u4f8b\u9898\u4e2d\u9700\u8981\u5bf9\u4e0b\u9762\u7684\u6a21\u677f\u7a0d\u4f5c\u4fee\u6539\uff0c\u52a0\u4e0a\u5907\u4efd\u6570\u7ec4<code>backup</code>\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int n, m;  // n\u8868\u793a\u70b9\u6570\uff0cm\u8868\u793a\u8fb9\u6570\nint dist[N];  // dist[x]\u5b58\u50a81\u5230x\u7684\u6700\u77ed\u8def\u8ddd\u79bb\n\n// \u8fb9\uff0ca\u8868\u793a\u51fa\u70b9\uff0cb\u8868\u793a\u5165\u70b9\uff0cw\u8868\u793a\u8fb9\u7684\u6743\u91cd\nstruct edge {\n    int a, b, w;\n} edges[M];\n\n// \u6c421\u5230n\u7684\u6700\u77ed\u8def\u8ddd\u79bb\uff0c\u5982\u679c\u65e0\u6cd5\u4ece1\u8d70\u5230n\uff0c\u5219\u8fd4\u56de-1\nint bellman_ford() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // \u5982\u679c\u7b2cn\u6b21\u8fed\u4ee3\u4ecd\u7136\u4f1a\u677e\u5f1b\u4e09\u89d2\u4e0d\u7b49\u5f0f\uff0c\u5c31\u8bf4\u660e\u5b58\u5728\u4e00\u6761\u957f\u5ea6\u662fn+1\u7684\u6700\u77ed\u8def\u5f84\n    // \u7531\u62bd\u5c49\u539f\u7406\uff0c\u8def\u5f84\u4e2d\u81f3\u5c11\u5b58\u5728\u4e24\u4e2a\u76f8\u540c\u7684\u70b9\uff0c\u8bf4\u660e\u56fe\u4e2d\u5b58\u5728\u8d1f\u6743\u56de\u8def\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n</code></pre> <p>\u56e0\u4e3a\u6bcf\u8f6e\u5faa\u73af\u662f \\(O(m)\\) \u7684\uff0c\u82e5\u6700\u77ed\u8def\u5b58\u5728\uff0c\u4e00\u8f6e\u677e\u5f1b\u64cd\u4f5c\u4f1a\u4f7f\u6700\u77ed\u8def\u7684\u8fb9\u6570\u81f3\u5c11\u52a01\uff0c\u800c\u6700\u77ed\u8def\u7684\u8fb9\u6570\u6700\u591a\u4e3a \\(n-1\\)\uff0c\u56e0\u6b64\u6700\u591a\u6267\u884c \\(n-1\\)\u8f6e\u677e\u5f1b\u64cd\u4f5c\u3002\u6545\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(nm)\\)\uff0c\u5176\u4e2d \\(n\\) \u8868\u793a\u70b9\u6570\uff0c \\(m\\)\u8868\u793a\u8fb9\u6570\u3002</p> <p>Bellman-Ford\u7b97\u6cd5\u80fd\u591f\u5224\u65ad\u8d1f\u73af\u5b58\u5728\uff1a\u5982\u679c\u7b2c \\(n\\) \u8f6e\u5faa\u73af\u662f\u4ecd\u7136\u5b58\u5728\u80fd\u591f\u677e\u5f1b\u7684\u8fb9\uff0c\u8bf4\u660e\u4ece\u6e90\u70b9\u51fa\u53d1\u80fd\u591f\u62b5\u8fbe\u4e00\u4e2a\u8d1f\u73af\u3002</p> <p>\u8865\u5145\uff1aBellman-Ford\u7684\u4f7f\u7528<code>vector</code>\u7684\u53e6\u4e00\u79cd\u4ee3\u7801\u5b9e\u73b0\u5982\u4e0b\uff1a</p> <pre><code>struct edge {\n    int v, w;\n};\n//e[u]\u5b58u\u70b9\u7684\u51fa\u8fb9\u7684\u90bb\u70b9\u548c\u8fb9\u6743\nvector&lt;edge&gt; e[N];\n//d[u]\u5b58u\u70b9\u5230\u6e90\u70b9\u7684\u8ddd\u79bb\nint d[N];\n\nbool bellman_ford(int s) {\n    //\u521d\u59cb\u5316d[s] = 0\uff0cd[\u5176\u4ed6\u70b9]=\u6b63\u65e0\u7a77\n    memset(d, 0x3f, sizeof d);\n    d[s] = 0;\n    bool flag;  //\u662f\u5426\u677e\u5f1b\n\n    //\u6267\u884c\u591a\u8f6e\u5faa\u73af\uff0c\u6bcf\u8f6e\u5faa\u73af\u5bf9\u6240\u6709\u8fb9\u90fd\u5c1d\u8bd5\u8fdb\u884c\u4e00\u6b21\u677e\u5f1b\u64cd\u4f5c\n    for (int i = 1; i &lt;= n; i++) {  //n\u8f6e\n        flag = false;\n\n        for (int u = 1; u &lt;= n; u++) {  //n\u70b9\n            if (d[u] == 0x3f3f3f3f) continue;\n\n            for (auto ed : e[u]) {  //u\u7684\u51fa\u8fb9\n                int v = ed.v, w = ed.w;\n                if (d[v] &gt; d[u] + w) {\n                    d[v] = d[u] + w;\n                    flag = true;\n                }\n            }\n        }\n\n        //\u5f53\u4e00\u8f6e\u5faa\u73af\u4e2d\u6ca1\u6709\u6210\u529f\u7684\u677e\u5f1b\u64cd\u4f5c\u65f6\uff0c\u7b97\u6cd5\u7ec8\u6b62\n        if (!flag) break;\n    }\n\n    return flag;  //\u7b2cn\u8f6e\u4e3atrue\u5219\u6709\u8d1f\u73af\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/#spfa","title":"SPFA","text":"<p>SPFA (Shortest Path Faster Algorithm)\u662f\u5bf9Bellman-Ford\u7b97\u6cd5\u7684\u6539\u8fdb\u3002\u4e8b\u5b9e\u4e0a\uff0c\u53ea\u6709\u672c\u8f6e\u88ab\u66f4\u65b0\u7684\u70b9\uff0c\u5176\u51fa\u8fb9\u624d\u6709\u53ef\u80fd\u5f15\u8d77\u4e0b\u4e00\u8f6e\u7684\u677e\u5f1b\u64cd\u4f5c\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u961f\u5217\u6765\u7ef4\u62a4\u88ab\u66f4\u65b0\u7684\u70b9\u7684\u96c6\u5408\u3002</p> <p>SPFA\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a</p> <pre><code>function SPFA(Graph, source):\n    for each vertex v in Graph:\n        distance[v] \u2190 infinity\n        inQueue[v] \u2190 false\n    end for\n    distance[source] \u2190 0\n\n    queue \u2190 empty queue\n    queue.push(source)\n    inQueue[source] \u2190 true\n\n    while queue is not empty:\n        u \u2190 queue.pop()\n        inQueue[u] \u2190 false\n\n        for each neighbor v of u:\n            if distance[u] + weight(u, v) &lt; distance[v]:\n                distance[v] \u2190 distance[u] + weight(u, v)\n                if not inQueue[v]:\n                    queue.push(v)\n                    inQueue[v] \u2190 true\n            end if\n        end for\n    end while\n\n    --Optional: Negative cycle detection\n    for each vertex v in Graph:\n        for each neighbor w of v:\n            if distance[v] + weight(v, w) &lt; distance[w]:\n                print \"Graph contains a negative-weight cycle\"\n                return\n            end if\n        end for\n    end for\n\n    return distance[]\nend function\n</code></pre> <p>\u4f8b\u9898\uff1aSPFA\u6c42\u6700\u77ed\u8def</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int n; // \u603b\u70b9\u6570\nint h[N], w[N], e[N], ne[N], idx;  // \u90bb\u63a5\u8868\u5b58\u50a8\u6240\u6709\u8fb9\nint dist[N];   // \u5b58\u50a8\u6bcf\u4e2a\u70b9\u52301\u53f7\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\nbool st[N];  // \u5b58\u50a8\u6bcf\u4e2a\u70b9\u662f\u5426\u5728\u961f\u5217\u4e2d\n\n// \u6c421\u53f7\u70b9\u5230n\u53f7\u70b9\u7684\u6700\u77ed\u8def\u8ddd\u79bb\uff0c\u5982\u679c\u4ece1\u53f7\u70b9\u65e0\u6cd5\u8d70\u5230n\u53f7\u70b9\u5219\u8fd4\u56de-1\nint SPFA() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n\n    while (q.size()) {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) {\n                dist[j] = dist[t] + w[i];\n\n                // \u5982\u679c\u961f\u5217\u4e2d\u5df2\u5b58\u5728j\uff0c\u5219\u4e0d\u9700\u8981\u5c06j\u91cd\u590d\u63d2\u5165\n                if (!st[j]) {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n</code></pre> <p><code>st</code>\u6570\u7ec4\u7684\u4f5c\u7528\uff1a\u5224\u65ad\u5f53\u524d\u7684\u70b9\u662f\u5426\u5df2\u7ecf\u52a0\u5165\u5230\u961f\u5217\u5f53\u4e2d\u4e86\uff1b\u5df2\u7ecf\u52a0\u5165\u961f\u5217\u7684\u7ed3\u70b9\u5c31\u4e0d\u9700\u8981\u53cd\u590d\u7684\u628a\u8be5\u70b9\u52a0\u5165\u5230\u961f\u5217\u4e2d\u4e86\uff0c\u5c31\u7b97\u6b64\u6b21\u8fd8\u662f\u4f1a\u66f4\u65b0\u5230\u6e90\u70b9\u7684\u8ddd\u79bb\uff0c\u90a3\u53ea\u7528\u66f4\u65b0\u4e00\u4e0b\u6570\u503c\u800c\u4e0d\u7528\u52a0\u5165\u5230\u961f\u5217\u5f53\u4e2d\u3002\u5373\u4fbf\u4e0d\u4f7f\u7528<code>st</code>\u6570\u7ec4\u6700\u7ec8\u4e5f\u6ca1\u6709\u4ec0\u4e48\u5173\u7cfb\uff0c\u4f46\u662f\u4f7f\u7528\u7684\u597d\u5904\u5728\u4e8e\u53ef\u4ee5\u63d0\u5347\u6548\u7387\u3002</p> <p>SPFA\u770b\u4e0a\u53bb\u548cDijkstra\u7b97\u6cd5\u957f\u5f97\u6709\u4e00\u4e9b\u50cf\uff0c\u4f46\u662f\u5176\u4e2d\u7684\u610f\u4e49\u8fd8\u662f\u76f8\u5dee\u751a\u8fdc\u7684:</p> <ul> <li>Dijkstra\u7b97\u6cd5\u4e2d\u7684st\u6570\u7ec4\u4fdd\u5b58\u7684\u662f\u5f53\u524d\u786e\u5b9a\u4e86\u5230\u6e90\u70b9\u8ddd\u79bb\u6700\u5c0f\u7684\u70b9\uff0c\u4e14\u4e00\u65e6\u786e\u5b9a\u4e86\u6700\u5c0f\u90a3\u4e48\u5c31\u4e0d\u53ef\u9006\u4e86(\u4e0d\u53ef\u6807\u8bb0\u4e3a<code>true</code>\u540e\u6539\u53d8\u4e3a<code>false</code>)\uff1bSPFA\u7b97\u6cd5\u4e2d\u7684<code>st</code>\u6570\u7ec4\u4ec5\u4ec5\u53ea\u662f\u8868\u793a\u7684\u5f53\u524d\u53d1\u751f\u8fc7\u66f4\u65b0\u7684\u70b9\uff0c\u4e14SPFA\u4e2d\u7684<code>st</code>\u6570\u7ec4\u53ef\u9006(\u53ef\u4ee5\u5728\u6807\u8bb0\u4e3a<code>true</code>\u4e4b\u540e\u53c8\u6807\u8bb0\u4e3a<code>false</code>)\u3002\u6ce8\u610fBFS\u4e2d\u7684<code>st</code>\u6570\u7ec4\u8bb0\u5f55\u7684\u662f\u5f53\u524d\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\u7684\u70b9\u3002</li> <li>Dijkstra\u7b97\u6cd5\u91cc\u4f7f\u7528\u7684\u662f\u4f18\u5148\u961f\u5217\u4fdd\u5b58\u7684\u662f\u5f53\u524d\u672a\u786e\u5b9a\u6700\u5c0f\u8ddd\u79bb\u7684\u70b9\uff0c\u76ee\u7684\u662f\u5feb\u901f\u7684\u53d6\u51fa\u5f53\u524d\u5230\u6e90\u70b9\u8ddd\u79bb\u6700\u5c0f\u7684\u70b9\uff1bSPFA\u7b97\u6cd5\u4e2d\u4f7f\u7528\u7684\u662f\u961f\u5217(\u4e5f\u53ef\u4ee5\u4f7f\u7528\u522b\u7684\u6570\u636e\u7ed3\u6784),\u76ee\u7684\u53ea\u662f\u8bb0\u5f55\u4e00\u4e0b\u5f53\u524d\u53d1\u751f\u8fc7\u66f4\u65b0\u7684\u70b9\u3002</li> </ul> <p>Bellman-Ford\u7b97\u6cd5\u91cc\u6700\u540e<code>return -1</code>\u7684\u5224\u65ad\u6761\u4ef6\u5199\u7684\u662f<code>dist[n] &gt; 0x3f3f3f3f / 2</code>\uff0c\u800cSPFA\u5199\u7684\u662f<code>dist[n] == 0x3f3f3f3f</code>\uff0c\u5176\u539f\u56e0\u5728\u4e8eBellman Ford\u7b97\u6cd5\u4f1a\u904d\u5386\u6240\u6709\u7684\u8fb9\uff0c\u56e0\u6b64\u4e0d\u7ba1\u662f\u4e0d\u662f\u548c\u6e90\u70b9\u8fde\u901a\u7684\u8fb9\u5b83\u90fd\u4f1a\u5f97\u5230\u66f4\u65b0\uff0c\u4f46\u662fSPFA\u7b97\u6cd5\u4e0d\u4e00\u6837\uff0c\u5b83\u76f8\u5f53\u4e8e\u91c7\u7528\u4e86BFS\uff0c\u56e0\u6b64\u904d\u5386\u5230\u7684\u7ed3\u70b9\u90fd\u662f\u4e0e\u6e90\u70b9\u8fde\u901a\u7684\uff0c\u56e0\u6b64\u5982\u679c\u8981\u6c42\u7684<code>n</code>\u548c\u6e90\u70b9\u4e0d\u8fde\u901a\uff0c\u5b83\u4e0d\u4f1a\u5f97\u5230\u66f4\u65b0\uff0c\u8fd8\u662f\u4fdd\u63010x3f3f3f3f\u3002</p> <p>\u7531\u4e8eSPFA\u662f\u7531Bellman-Ford\u7b97\u6cd5\u4f18\u5316\u800c\u6765\uff0c\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u5b83\u4e00\u6837\uff0c\u5373\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(nm)\\)\uff0c\u4f46\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m)\\)\uff0c\u5176\u4e2d \\(n\\) \u4e3a\u70b9\u6570\uff0c \\(m\\) \u4e3a\u8fb9\u6570\u3002\u5047\u5982\u9898\u76ee\u65f6\u95f4\u5141\u8bb8\u53ef\u4ee5\u76f4\u63a5\u7528SPFA\u53bb\u89e3Dijkstra\u7b97\u6cd5\u7684\u9898\u76ee\u3002</p> <p>SPFA\u53ef\u4ee5\u5904\u7406\u8d1f\u6743\u8fb9\uff0c\u4f46\u662f\u4e0d\u80fd\u5904\u7406\u6709\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff1b\u800cDijkstra\u4e0d\u80fd\u5904\u7406\u5e26\u6709\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u56de\u8def\u7684\u56fe\uff0c\u56e0\u4e3aDijkstra\u7b97\u6cd5\u5728\u8ba1\u7b97\u6700\u77ed\u8def\u5f84\u65f6\uff0c\u4e0d\u4f1a\u56e0\u4e3a\u8d1f\u8fb9\u7684\u51fa\u73b0\u800c\u66f4\u65b0\u5df2\u7ecf\u8ba1\u7b97\u8fc7(\u6536\u5f55\u8fc7)\u7684\u9876\u70b9\u7684\u8def\u5f84\u957f\u5ea6\u3002\u53ef\u89c1Bellman-Ford\u53ef\u4ee5\u5904\u7406\u4efb\u610f\u5e26\u8d1f\u6743\u8fb9\u548c\u8d1f\u6743\u73af\u7684\u56fe\uff0cSPFA\u53ef\u4ee5\u5904\u7406\u5e26\u8d1f\u6743\u8fb9\u7684\u56fe\uff0cDijkstra\u53ea\u80fd\u5904\u7406\u5e26\u6b63\u6743\u8fb9\u7684\u56fe\u3002</p> <p>\u4f8b\u9898\uff1aSPFA\u5224\u65ad\u8d1f\u73af</p> <p>\u5224\u65ad\u8d1f\u73af\u7684\u6a21\u677f\u4ee3\u7801\uff1a</p> <pre><code>int n;  // \u603b\u70b9\u6570\nint h[N], w[N], e[N], ne[N], idx;  // \u90bb\u63a5\u8868\u5b58\u50a8\u6240\u6709\u8fb9\n// dist[x]\u5b58\u50a81\u53f7\u70b9\u5230x\u7684\u6700\u77ed\u8ddd\u79bb\uff0ccnt[x]\u5b58\u50a81\u5230x\u7684\u6700\u77ed\u8def\u4e2d\u7ecf\u8fc7\u7684\u70b9\u6570\nint dist[N], cnt[N];\nbool st[N];  // \u5b58\u50a8\u6bcf\u4e2a\u70b9\u662f\u5426\u5728\u961f\u5217\u4e2d\n\n// \u5982\u679c\u5b58\u5728\u8d1f\u73af\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\nbool SPFA() {\n    // \u4e0d\u9700\u8981\u521d\u59cb\u5316dist\u6570\u7ec4\n\n    // \u5224\u8d1f\u73af\uff1a\u5982\u679c\u67d0\u6761\u6700\u77ed\u8def\u5f84\u4e0a\u6709n\u4e2a\u70b9\uff08\u9664\u4e86\u81ea\u5df1\uff09\uff0c\u90a3\u4e48\u52a0\u4e0a\u81ea\u5df1\u4e4b\u540e\u4e00\u5171\u6709n+1\u4e2a\u70b9\uff0c\u7531\u62bd\u5c49\u539f\u7406\u4e00\u5b9a\u6709\u4e24\u4e2a\u70b9\u76f8\u540c\uff0c\u6240\u4ee5\u5b58\u5728\u73af\n\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i++) {\n        q.push(i);\n        st[i] = true;\n    }\n\n    while (q.size()) {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt;= n) return true;\n\n                if (!st[j]) {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n</code></pre> <p>\u5728SPFA\u4e2d\uff0c<code>dist[x]</code>\u8868\u793a\u4ece1\u53f7\u70b9\u5230<code>x</code>\u53f7\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\uff0c\u4e3a\u4e86\u5224\u65ad\u8d1f\u6743\u56de\u8def\uff0c\u8fd8\u53ef\u4ee5\u53e6\u5f00\u4e00\u4e2a<code>cnt[x]</code>\u6570\u7ec4\u8868\u793a\u4ece\u4ece1\u53f7\u70b9\u5230<code>x</code>\u53f7\u70b9\u7684\u6700\u77ed\u8def\u7684\u8fb9\u7684\u6570\u91cf\u3002\u6bcf\u6b21\u66f4\u65b0\u65f6\u9664\u4e86<code>dist[x] = dist[t]+ w[i];</code>\u4e4b\u5916\u518d\u52a0\u4e0a<code>cnt[x] = xnt[t] + 1;</code>\u3002\u5982\u679c\u67d0\u6b21\u51fa\u73b0<code>cnt[x] &gt;= n</code>\uff0c\u5219\u53ef\u4ee5\u6839\u636e\u62bd\u5c49\u539f\u7406\u5224\u65ad\u8be5\u8def\u5f84\u4e0a\u81f3\u5c11\u6709\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\u662f\u76f8\u540c\u7684\uff0c\u5373\u8def\u5f84\u4e0a\u5b58\u5728\u73af\uff0c\u800c\u4e14\u8be5\u73af\u5fc5\u4e3a\u8d1f\u73af\u3002</p> <p>\u8865\u5145\uff1a\u53e6\u4e00\u79cd\u4f7f\u7528<code>vector</code>\u7684SPFA\u4ee3\u7801\u5b9e\u73b0(\u80fd\u5224\u8d1f\u73af\u548c\u9012\u5f52\u8f93\u51fa\u8def\u5f84)\uff1a</p> <pre><code>struct edge {\n    int v, w;\n};\nvector&lt;edge&gt; e[N];\n//vis[u]\u6807\u8bb0u\u70b9\u662f\u5426\u5728\u961f\u5185\uff0ccnt[v]\u8bb0\u5f55\u8fb9\u6570\uff0c\u5224\u8d1f\u73af\nint d[N], cnt[N], vis[N], pre[N];\nqueue&lt;int&gt; q;  //\u961f\u5217\n\nbool SPFA(int s) {\n    //\u521d\u59cb\u5316\uff1as\u5165\u961f\uff0c\u6807\u8bb0s\u5728\u961f\u5185\uff0cd[s] = 0\uff0cd[\u5176\u4ed6\u70b9] = \u6b63\u65e0\u7a77\n    memset(d, 0x3f, sizeof d);\n    d[s] = 0;\n    vis[s] = 1;\n    q.push(s);\n\n    //\u91cd\u590d\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\n    while (q.size()) {\n        //\u4ece\u961f\u5934\u5f39\u51fau\u70b9\uff0c\u6807\u8bb0u\u4e0d\u5728\u961f\u5185\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n\n        //\u679a\u4e3eu\u7684\u6240\u6709\u51fa\u8fb9\n        for (auto ed : e[u]) {\n            int v = ed.v, w = ed.w;\n            //\u6267\u884c\u677e\u5f1b\u64cd\u4f5c\n            if (d[v] &gt; d[u] + w) {\n                d[v] = d[u] + w;\n                pre[v] = u;  //\u8bb0\u5f55\u524d\u9a71\u70b9\n\n                //\u8bb0\u5f55\u4eces\u8d70\u5230v\u7684\u8fb9\u6570\u5e76\u5224\u8d1f\u73af\n                cnt[v] = cnt[u] + 1;  //\u8bb0\u5f55\u8fb9\u6570\n                //\u5982\u679c\u6709\u8d1f\u73af\u8fd4\u56detrue\n                if (cnt[v] &gt;= n) return true;\n\n                //\u5982\u679cv\u4e0d\u5728\u961f\u5185\u5219\u628av\u538b\u5165\u961f\u5c3e\uff0c\u5e76\u6253\u4e0a\u6807\u8bb0\n                if (!vis[v]) {\n                    q.push(v);\n                    vis[v] = 1;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid dfs_path(int u) {  //\u9012\u5f52\u8f93\u51fa\u8def\u5f84\n    if (u == 1) {\n        printf(\"%d \", u);\n        return;\n    }\n    dfs_path(pre[u]);\n    printf(\"%d \", u);\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/03_Shortest_Path/#floyd","title":"Floyd\u7b97\u6cd5","text":"<p>Floyd\u7b97\u6cd5\u57fa\u4e8e\u52a8\u6001\u89c4\u5212\uff0c\u4f7f\u7528\u90bb\u63a5\u77e9\u9635\uff0c<code>d[i][j]</code>\u5b58\u50a8\u6240\u6709\u7684\u8fb9\uff0c\u5171\u4e09\u91cd\u5faa\u73af\uff0c\u5faa\u73af\u5b8c\u4e4b\u540e<code>d[i][j]</code>\u5c31\u662f\u4ece\u70b9<code>i</code>\u5230\u70b9<code>j</code>\u7684\u6700\u77ed\u8ddd\u79bb\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n^3)\\)\uff0c\u5176\u4e2d \\(n\\) \u4e3a\u70b9\u6570\u3002</p> <p>\u4f8b\u9898\uff1aFloyd\u6c42\u6700\u77ed\u8def</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>//\u521d\u59cb\u5316\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= n; j++)\n        if (i == j) d[i][j] = 0;\n        else d[i][j] = INF;\n\n// \u7b97\u6cd5\u7ed3\u675f\u540e\uff0cd[a][b]\u8868\u793aa\u5230b\u7684\u6700\u77ed\u8ddd\u79bb\nvoid floyd() {\n    for (int k = 1; k &lt;= n; k++)\n        for (int i = 1; i &lt;= n; i++)\n            for (int j = 1; j &lt;= n; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/04_Minimum_Spanning_Tree/","title":"\u6700\u5c0f\u751f\u6210\u6811","text":"<ol> <li>Prim\u7b97\u6cd5</li> <li>\u6734\u7d20\u7248Prim(\u5e38\u7528)\uff1a\u7a20\u5bc6\u56fe\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^2)\\)</li> <li>\u5806\u4f18\u5316\u7248Prim(\u4e0d\u5e38\u7528)\uff1a\u7a00\u758f\u56fe\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(m\\log n)\\)</li> <li>Kruskal\u7b97\u6cd5(\u5e38\u7528)\uff1a\u7a00\u758f\u56fe\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(m\\log m)\\)</li> </ol>"},{"location":"zh/Graph_and_Search/04_Minimum_Spanning_Tree/#prim","title":"Prim\u7b97\u6cd5","text":""},{"location":"zh/Graph_and_Search/04_Minimum_Spanning_Tree/#prim_1","title":"\u6734\u7d20\u7248Prim\u7b97\u6cd5","text":"<p>\u7b97\u6cd5\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>PRIM(G, w, r):\n    for each u in G.V:\n        u.key = \u221e\n        u.\u03c0 = NIL\n    r.key = 0\n    Q = G.V\n    while Q \u2260 \u2205:\n        u = EXTRACT-MIN(Q)\n        for each v in G.Adj[u]:\n            if v \u2208 Q and w(u, v) &lt; v.key\n                v.\u03c0 = u\n                v.key = w(u, v)\n</code></pre> <p>\u4f8b\u9898\uff1aPrim\u7b97\u6cd5\u6c42\u6700\u5c0f\u751f\u6210\u6811</p>"},{"location":"zh/Graph_and_Search/04_Minimum_Spanning_Tree/#prim_2","title":"\u5806\u4f18\u5316\u7684Prim\u7b97\u6cd5","text":"<p>\u7565</p>"},{"location":"zh/Graph_and_Search/04_Minimum_Spanning_Tree/#kruskal","title":"Kruskal\u7b97\u6cd5","text":"<ol> <li>\u5c06\u6240\u6709\u8fb9\u6309\u6743\u91cd\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u672c\u6b65\u9aa4\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m\\log m)\\)\uff1b</li> <li>\u4ece\u5c0f\u5230\u5927\u4f9d\u6b21\u679a\u4e3e\u6bcf\u6761\u8fb9 \\(a,b\\)\uff0c\u6743\u91cd \\(c\\)\uff0c\u5982\u679c \\(a,b\\) \u4e0d\u8fde\u901a\uff0c\u5c31\u5c06\u8fd9\u6761\u8fb9\u52a0\u5165\u5230\u96c6\u5408\u4e2d\u3002\u672c\u6b65\u9aa4\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(m)\\)\u3002</li> </ol> <p>\u4ee5\u4e0a\u6b65\u9aa4\u7c7b\u4f3c\u4e8e\u5e76\u67e5\u96c6\u3002</p> <p>\u7b97\u6cd5\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>KRUSKAL(G, w):\n    A = \u2205\n    for each vertex v in G.V:\n        MAKE-SET(v)\n    sort the edges of G.E into non-decreasing order by weight w\n    for each edge (u, v) in G.E, taken in non-decreasing order by weight:\n        if FIND-SET(u) \u2260 FIND-SET(v):\n            A = A \u222a {(u, v)}\n            UNION(u, v)\n    return A\n</code></pre> <p>\u4f8b\u9898\uff1aKruskal\u7b97\u6cd5\u6c42\u6700\u5c0f\u751f\u6210\u6811</p>"},{"location":"zh/Graph_and_Search/05_Bipartite_Graph/","title":"\u4e8c\u5206\u56fe","text":"<ol> <li>\u67d3\u8272\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n+m)\\)</li> <li>\u5308\u7259\u5229\u7b97\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u574f \\(O(mn)\\)\uff0c\u4f46\u5b9e\u9645\u8fd0\u884c\u65f6\u95f4\u4e00\u822c\u8fdc\u5c0f\u4e8e \\(O(mn)\\)</li> </ol>"},{"location":"zh/Graph_and_Search/05_Bipartite_Graph/#_2","title":"\u67d3\u8272\u6cd5","text":"<p>\u4e8c\u5206\u56fe\u7684\u5b9a\u4e49\uff1a\u6709\u4e24\u9876\u70b9\u96c6\u4e14\u56fe\u4e2d\u6bcf\u6761\u8fb9\u7684\u7684\u4e24\u4e2a\u9876\u70b9\u5206\u522b\u4f4d\u4e8e\u4e24\u4e2a\u9876\u70b9\u96c6\u4e2d\uff0c\u6bcf\u4e2a\u9876\u70b9\u96c6\u4e2d\u6ca1\u6709\u8fb9\u76f4\u63a5\u76f8\u8fde\u63a5\u7684\u56fe(\u56fe\u4e2d\u70b9\u901a\u8fc7\u79fb\u52a8\u80fd\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u4fa7\u7684\u70b9\u53ea\u548c\u53f3\u4fa7\u7684\u70b9\u76f8\u8fde\uff0c\u53f3\u4fa7\u7684\u70b9\u53ea\u548c\u5de6\u4fa7\u7684\u70b9\u76f8\u8fde)</p> <p>\u67d3\u8272\u6cd5\u53ef\u4ee5\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u56fe\u662f\u4e0d\u662f\u4e8c\u5206\u56fe\u3002</p> <p>\u5b9a\u7406\uff1a\u4e00\u4e2a\u56fe\u662f\u4e8c\u5206\u56fe\u5f53\u4e14\u4ec5\u5f53\u56fe\u4e2d\u4e0d\u542b\u5947\u6570\u73af(\u8fb9\u6570\u4e3a\u5947\u6570\u7684\u73af)\u3002</p> <ul> <li>\u5f00\u59cb\u5bf9\u4efb\u610f\u4e00\u672a\u67d3\u8272\u7684\u9876\u70b9\u67d3\u8272\u3002</li> <li>\u5224\u65ad\u5176\u76f8\u90bb\u7684\u9876\u70b9\u4e2d\uff0c\u82e5\u672a\u67d3\u8272\u5219\u5c06\u5176\u67d3\u4e0a\u548c\u76f8\u90bb\u9876\u70b9\u4e0d\u540c\u7684\u989c\u8272\u3002</li> <li>\u82e5\u5df2\u7ecf\u67d3\u8272\u4e14\u989c\u8272\u548c\u76f8\u90bb\u9876\u70b9\u7684\u989c\u8272\u76f8\u540c\u5219\u8bf4\u660e\u4e0d\u662f\u4e8c\u5206\u56fe\uff0c\u82e5\u989c\u8272\u4e0d\u540c\u5219\u7ee7\u7eed\u5224\u65ad\u3002</li> <li>\u901a\u8fc7DFS\u6216BFS\u8fdb\u884c\u641c\u7d22\u3002</li> </ul> <p>\u4f8b\u9898\uff1a\u67d3\u8272\u6cd5\u5224\u5b9a\u4e8c\u5206\u56fe</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>/*\n1. color\u6570\u7ec4\u521d\u59cb\u5316\u4e3a0\uff0c\u88ab\u8bbf\u95ee\u7684\u70b9\u7684\u989c\u8272\u4e3a1\u62162\n2. \u8fdb\u5165u\uff0c\u5bf9u\u70b9\u67d3\u8272\n3. \u679a\u4e3eu\u7684\u90bb\u70b9v\n\uff081\uff09\u82e5v\u672a\u8bbf\u95ee\uff0c\u8d70\u8fdb\u53bb\uff0c\u82e5\u8fd4\u56de\u6709\u5947\u73af\uff0c\u5219\u4e00\u8def\u8fd4\u56de\u6709\u5947\u73af\n\uff082\uff09\u82e5v\u5df2\u8bbf\u95ee\u4e14v\u7684\u989c\u8272\u4e0eu\u7684\u989c\u8272\u76f8\u540c\uff0c\u5219\u8fd4\u56de\u6709\u5947\u73af\n4. \u679a\u4e3e\u5b8cu\u7684\u90bb\u70b9\uff0c\u6ca1\u6709\u53d1\u73b0\u6709\u5947\u73af\uff0c\u5219\u8fd4\u56de\u6ca1\u6709\u5947\u73af\n*/\n\nint n; //n\u4e3a\u70b9\u6570\nint h[N], e[M], ne[M], idx;  //\u90bb\u63a5\u8868\u5b58\u50a8\u56fe\nint color[N];  //\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u989c\u8272\uff0c-1\u8868\u793a\u672a\u67d3\u8272\uff0c0\u8868\u793a\u767d\u8272\uff0c1\u8868\u793a\u9ed1\u8272\n\n// \u53c2\u6570\uff1au\u8868\u793a\u5f53\u524d\u8282\u70b9\uff0cc\u8868\u793a\u5f53\u524d\u70b9\u7684\u989c\u8272\nbool dfs(int u, int c) {\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int j = e[i];\n        if (color[j] == -1) {\n            if (!dfs(j, !c)) return false;\n        } else if (color[j] == c) return false;\n    }\n    return true;\n}\n\nbool check() {\n    memset(color, -1, sizeof color);\n    bool flag = true;\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (color[i] == -1) {\n            if (!dfs(i, 0)) {\n                flag = false;\n                break;\n            }\n        }\n    }\n    return flag;\n}\n</code></pre>"},{"location":"zh/Graph_and_Search/05_Bipartite_Graph/#_3","title":"\u5308\u7259\u5229\u7b97\u6cd5","text":"<p>\u4f8b\u9898\uff1a\u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d</p>"},{"location":"zh/Graph_and_Search/06_Network_Flow/","title":"\u7f51\u7edc\u6d41\u95ee\u9898","text":"<p>Ford\u2013Fulkerson\u7b97\u6cd5\uff1a</p> <p>\u7b97\u6cd5\u7684\u57fa\u672c\u6d41\u7a0b\u4e3a\uff1a</p> <pre><code>Initialize flow f to 0 for all edges in the graph\nwhile there exists an augmenting path p in the residual graph Gf:\n    2.1 Find bottleneck capacity (minimum capacity along the path) f' of path p\n    2.2 Augment each edge (u, v) and its reverse (v, u) along p by f'\n    2.3 Update the residual graph Gf\nreturn the flow f\n</code></pre> <p>\u7b97\u6cd5\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>FORD-FULKERSON(G, s, t):\n    for each edge (u, v) in G.E:\n        (u, v).f = 0\n        (v, u).f = 0\n    while there exists an augmenting path p in the residual graph G_f:\n        f' = \u221e\n        for each edge (u, v) in p:\n            f' = min(f', (u, v).c - (u, v).f)\n        for each edge (u, v) in p:\n            (u, v).f = (u, v).f + f'\n            (v, u).f = (v, u).f - f'\n    return the flow f\n</code></pre> <p>\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(E\\times \\max flow)\\)\uff0c \\(E\\) \u662f\u8fb9\u7684\u6570\u91cf\uff0c\u201c \\(\\max flow\\) \u201d\u662f\u7f51\u7edc\u4e2d\u6700\u5927\u6d41\u91cf\u7684\u503c\u3002</p>"},{"location":"zh/Greedy_Methods/","title":"\u8d2a\u5fc3\u7b97\u6cd5","text":""},{"location":"zh/Greedy_Methods/01_Interval_Problems/","title":"\u533a\u95f4\u95ee\u9898","text":"<p>\u8d2a\u5fc3\u7b97\u6cd5\u96be\u5728\u8bc1\u660e\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff0c\u4e14\u7b97\u6cd5\u57fa\u672c\u6ca1\u6709\u6a21\u677f\u548c\u5957\u8def\u3002\u533a\u95f4\u4f55\u65f6\u6309\u5de6\u7aef\u70b9\u6392\u5e8f\uff0c\u4f55\u65f6\u6309\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u53d6\u51b3\u4e8e\u4e0d\u540c\u95ee\u9898\u3002</p>"},{"location":"zh/Greedy_Methods/01_Interval_Problems/#_2","title":"\u533a\u95f4\u9009\u70b9\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u533a\u95f4\u9009\u70b9</p> <p>\u7b97\u6cd5\u6b65\u9aa4\uff1a</p> <ol> <li>\u5c06\u6bcf\u4e2a\u533a\u95f4\u6309\u7167\u53f3\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff1b</li> <li>\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c<code>end</code>\u503c\u521d\u59cb\u5316\u4e3a\u8d1f\u65e0\u7a77\uff1b</li> <li>\u5982\u679c\u5f53\u524d\u533a\u95f4\u4e2d\u5df2\u7ecf\u5305\u542b\u6700\u540e\u9009\u7684\u90a3\u4e2a\u70b9(\u5373\u53ef\u4ee5\u8986\u76d6\u6389\u4e0a\u6b21\u533a\u95f4\u7684\u53f3\u7aef\u70b9)\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\uff0c\u8fdb\u884c\u4e0b\u4e00\u8f6e\u5faa\u73af\uff1b</li> <li>\u5426\u5219\uff0c\u5982\u679c\u672c\u6b21\u533a\u95f4\u4e0d\u80fd\u8986\u76d6\u6389\u4e0a\u6b21\u533a\u95f4\u7684\u53f3\u7aef\u70b9(\u5373<code>ed &lt; range[i].l</code>)\uff0c\u8bf4\u660e\u9700\u8981\u9009\u62e9\u4e00\u4e2a\u65b0\u7684\u70b9\uff0c\u6545\u9009\u62e9\u5f53\u524d\u533a\u95f4\u7684\u53f3\u7aef\u70b9(\u5373<code>res++; ed = range[i].r;</code>)\u3002</li> </ol> <p>\u5982\u4f55\u8bc1\u660e\u7b97\u6cd5\u6b63\u786e\u6027\uff1f</p> <p>\u9996\u5148\uff0c\u5f53\u524d\u9009\u62e9\u7684\u65b9\u6848\u5fc5\u7136\u662f\u4e00\u7ec4\u5408\u6cd5\u7684\u65b9\u6848(\u53ef\u884c\u89e3)\u3002\u5047\u8bbe\u6700\u4f18\u89e3\u4e3a<code>ans</code>\u4e2a\u70b9\uff0c\u8d2a\u5fc3\u7b97\u6cd5\u6c42\u51fa\u7684\u4e3a<code>cnt</code>\u4e2a\u70b9\u3002\u53ea\u9700\u8981\u8bc1\u660e<code>ans == cnt</code>\u5373\u53ef\u3002</p> <ul> <li>\u56e0\u4e3a<code>ans</code>\u662f\u6700\u4f18\u89e3\uff0c\u6240\u4ee5<code>ans &lt;= cnt</code>\uff1b</li> <li>\u8d2a\u5fc3\u7b97\u6cd5\u6c42\u51fa\u7684\u7ed3\u679c\u4e3a<code>cnt</code>\uff0c\u6839\u636e\u7b97\u6cd5\u6b65\u9aa4\uff0c\u6bcf\u6b21\u8ba9\u9009\u53d6\u70b9\u6570\u52a0\u4e00\u7684\u533a\u95f4\u4e00\u5b9a\u6ca1\u6709\u4ea4\u96c6\uff0c\u5171\u8ba1<code>cnt</code>\u4e2a\u8fd9\u6837\u7684\u533a\u95f4\u3002\u4e3a\u4e86\u8986\u76d6\u8fd9<code>cnt</code>\u4e2a\u533a\u95f4\uff0c\u81f3\u5c11\u9700\u8981<code>cnt</code>\u4e2a\u70b9\uff0c\u6240\u4ee5<code>ans &gt;= cnt</code>\u3002</li> </ul> <p>\u56e0\u6b64\u8be5\u7b97\u6cd5\u4e00\u5b9a\u80fd\u5f97\u5230\u6700\u4f18\u89e3\u3002</p> <p>\u4ee3\u7801\uff1a</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nvector&lt;vector&lt;int&gt;&gt; nums;\n\nint main() {\n    cin &gt;&gt; n;\n    while (n--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        nums.push_back({a, b});\n    }\n\n    int res = 1;\n    sort(nums.begin(), nums.end());\n    int end = nums[0][1];\n    for (int i = 1; i &lt; nums.size(); i++) {\n        if (end &lt; nums[i][0]) {\n            res++;\n            end = nums[i][1];\n        } else {\n            end = min(end, nums[i][1]);\n        }\n    }\n\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a \\(O(n\\log n)\\)\u3002</p>"},{"location":"zh/Greedy_Methods/01_Interval_Problems/#_3","title":"\u6700\u5927\u4e0d\u76f8\u4ea4\u533a\u95f4\u6570\u91cf\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u6700\u5927\u4e0d\u76f8\u4ea4\u533a\u95f4\u6570\u91cf</p> <ol> <li>\u5c06\u533a\u95f4\u6309\u53f3\u7aef\u70b9\u6392\u5e8f\uff1b</li> <li>\u4ece\u524d\u5f80\u540e\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff1a</li> <li>\u5982\u679c\u8be5\u533a\u95f4\u548c\u4e0a\u4e00\u4e2a\u9009\u7684\u533a\u95f4\u6709\u91cd\u5408\uff0c\u5219\u8df3\u8fc7\uff1b</li> <li>\u5982\u679c\u548c\u4e0a\u4e00\u4e2a\u9009\u7684\u533a\u95f4\u6ca1\u6709\u91cd\u5408\uff0c\u5219\u9009\u53d6\u8be5\u533a\u95f4\uff1b</li> <li>\u8f93\u51fa\u6240\u9009\u533a\u95f4\u7684\u4e2a\u6570\u3002</li> </ol> <p>\u8bc1\u660e\uff1a</p> <ul> <li>\u5047\u8bbe<code>ans</code>\u662f\u6700\u4f18\u89e3\uff0c\u8868\u793a\u6700\u591a\u6709<code>ans</code>\u4e2a\u4e0d\u76f8\u4ea4\u7684\u533a\u95f4\uff1b<code>cnt</code>\u662f\u53ef\u884c\u89e3\uff0c\u8868\u793a\u7b97\u6cd5\u6c42\u51fa<code>cnt</code>\u4e2a\u4e0d\u76f8\u4ea4\u7684\u533a\u95f4\uff0c\u663e\u7136\u6709<code>ans &gt;= cnt</code>\uff1b</li> <li>\u53cd\u8bc1\u6cd5\u8bc1\u660e<code>ans &lt;= cnt</code>\uff1a\u5047\u8bbe<code>ans &gt; cnt</code>\uff0c\u7531\u6700\u4f18\u89e3\u7684\u542b\u4e49\u77e5\uff0c\u6700\u591a\u6709<code>ans</code>\u4e2a\u4e0d\u76f8\u4ea4\u7684\u533a\u95f4\uff0c\u56e0\u6b64\u81f3\u5c11\u9700\u8981<code>ans</code>\u4e2a\u70b9\u624d\u80fd\u8986\u76d6\u6240\u6709\u533a\u95f4\uff0c\u800c\u6839\u636e\u7b97\u6cd5\u77e5\uff0c\u53ea\u9700<code>cnt</code>\u4e2a\u70b9\u5c31\u80fd\u8986\u76d6\u5168\u90e8\u533a\u95f4\uff0c\u4e14<code>cnt &lt; ans</code>\uff0c\u8fd9\u4e0e\u524d\u8fb9\u5206\u6790\u81f3\u5c11\u9700\u8981ans\u4e2a\u70b9\u624d\u80fd\u8986\u76d6\u6240\u6709\u533a\u95f4\u76f8\u77db\u76fe\uff0c\u6545<code>ans &lt;= cnt</code>\u3002</li> </ul> <p>\u7efc\u4e0a\u6240\u8ff0\uff1a<code>ans == cnt</code>\u3002</p>"},{"location":"zh/Greedy_Methods/01_Interval_Problems/#_4","title":"\u533a\u95f4\u5206\u7ec4\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u533a\u95f4\u5206\u7ec4</p> <p>\u8d2a\u5fc3\u7b97\u6cd5\u7684\u89e3\u51b3\u6b65\u9aa4\uff1a</p> <ol> <li>\u5c06\u533a\u95f4\u6309\u5de6\u7aef\u70b9\u6392\u5e8f\uff1b</li> <li>\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u904d\u5386\u533a\u95f4\uff1a</li> <li>\u5982\u679c\u5f53\u524d\u533a\u95f4\u80fd\u653e\u5230\u4e4b\u524d\u7684\u67d0\u4e2a\u96c6\u5408\u4e2d\uff0c\u5219\u628a\u8be5\u533a\u95f4\u653e\u5230\u8be5\u96c6\u5408\uff1b</li> <li>\u5982\u679c\u5f53\u524d\u4e0d\u80fd\u653e\u5230\u4efb\u610f\u4e00\u4e2a\u4e4b\u524d\u7684\u96c6\u5408\u4e2d\uff0c\u5219\u65b0\u5f00\u4e00\u4e2a\u96c6\u5408\uff0c\u628a\u5f53\u524d\u533a\u95f4\u653e\u5230\u65b0\u5f00\u7684\u96c6\u5408\u4e2d\uff1b</li> <li>\u96c6\u5408\u7684\u6570\u91cf\u5c31\u662f\u7b54\u6848\u3002</li> </ol> <p>\u5173\u952e\u6b65\u9aa4\u662f\u7b2c\u4e8c\u6b65\uff0c\u5982\u4f55\u5224\u65ad\u5f53\u524d\u533a\u95f4\u80fd\u5426\u653e\u5230\u4e4b\u524d\u7684\u96c6\u5408\u4e2d\u3002\u89e3\u51b3\u65b9\u6cd5\u5982\u4e0b:</p> <ul> <li>\u4e3a\u4e86\u5feb\u901f\u627e\u51fa\u53f3\u4fa7\u7aef\u70b9\u6700\u5c0f\u7684\u90a3\u4e2a\u96c6\u5408\uff0c\u53ef\u4ee5\u4f7f\u7528\u5c0f\u6839\u5806\u4fdd\u5b58\u6bcf\u4e2a\u96c6\u5408\u7684\u53f3\u7aef\u70b9\uff1b</li> <li>\u8bb0\u5f55\u6bcf\u4e2a\u96c6\u5408\u4e2d\u4fdd\u5b58\u7684\u533a\u95f4\u7684\u6700\u53f3\u4fa7\u7aef\u70b9\uff0c\u5982\u679c\u5f53\u524d\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u4e0d\u548c\u67d0\u4e2a\u96c6\u5408\u4e2d\u4fdd\u5b58\u7684\u533a\u95f4\u7684\u6700\u53f3\u4fa7\u7aef\u70b9\u76f8\u4ea4\uff0c\u5219\u5f53\u524d\u533a\u95f4\u4e0d\u548c\u8be5\u96c6\u5408\u76f8\u4ea4\uff0c\u80fd\u653e\u5230\u8be5\u96c6\u5408\u4e2d\uff1b</li> <li>\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ea\u9700\u5224\u65ad\u5f53\u524d\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u662f\u5426\u548c\u53f3\u4fa7\u7aef\u70b9\u6700\u5c0f\u7684\u90a3\u4e2a\u96c6\u5408\u662f\u5426\u76f8\u4ea4\u5373\u53ef\uff1a</li> <li>\u5982\u679c\u4e00\u4e2a\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u6bd4\u6700\u5c0f\u7ec4\u7684\u53f3\u7aef\u70b9\u8981\u5c0f\uff0c\u5373<code>ranges[i].l &lt;= heap.top()</code>\uff0c\u5c31\u5f00\u4e00\u4e2a\u65b0\u7ec4\uff0c\u5373<code>heap.push(range[i].r);</code></li> <li>\u5982\u679c\u4e00\u4e2a\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u6bd4\u6700\u5c0f\u7ec4\u7684\u53f3\u7aef\u70b9\u8981\u5927\uff0c\u5219\u653e\u5728\u8be5\u7ec4\uff0c\u5373<code>heap.pop(), heap.push(range[i].r);</code></li> </ul> <p>\u6bcf\u7ec4\u53bb\u9664\u53f3\u7aef\u70b9\u6700\u5c0f\u7684\u533a\u95f4\uff0c\u53ea\u4fdd\u7559\u4e00\u4e2a\u53f3\u7aef\u70b9\u8f83\u5927\u7684\u533a\u95f4\uff0c\u8fd9\u6837<code>heap</code>\u6709\u591a\u5c11\u533a\u95f4\uff0c\u5c31\u6709\u591a\u5c11\u7ec4\u3002</p> <p>\u53ef\u770b\u89c6\u9891\u8bb2\u89e3\u3002</p>"},{"location":"zh/Greedy_Methods/01_Interval_Problems/#_5","title":"\u533a\u95f4\u8986\u76d6\u95ee\u9898","text":"<p>\u4f8b\u9898\uff1a\u533a\u95f4\u8986\u76d6</p> <p>\u601d\u8def\u603b\u89c8(\u8bbe\u6700\u521d\u7684\u533a\u95f4\u5de6\u7aef\u70b9\u4e3a<code>start</code>\uff0c\u53f3\u7aef\u70b9\u4e3a<code>end</code>)\uff1a</p> <ol> <li>\u5c06\u6240\u6709\u533a\u95f4\u6309\u7167\u5de6\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u8fdb\u884c\u6392\u5e8f\uff1b</li> <li>\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c\u5728\u6240\u6709\u80fd\u8986\u76d6<code>start</code>\u7684\u533a\u95f4\u4e2d\uff0c\u9009\u62e9\u53f3\u7aef\u70b9\u503c\u6700\u5927\u7684\u4e00\u4e2a\u533a\u95f4\uff0c\u7136\u540e\u5c06<code>start</code>\u66f4\u65b0\u6210\u8fd9\u4e2a\u53f3\u7aef\u70b9\u7684\u6700\u5927\u503c\u3002</li> </ol> <p>\u6ce8\u610f\uff0c\u5bf9\u4e8e\u5f53\u524d\u533a\u95f4<code>[a0, b0]</code>\u6765\u8bf4\uff0c\u4e0b\u4e00\u4e2a\u9009\u62e9\u533a\u95f4\u7684\u5de6\u7aef\u70b9<code>a1</code>\u5e94\u6ee1\u8db3<code>a1 &lt;= b0</code>\uff0c\u5426\u5219\u5c31\u4e0d\u80fd\u5b8c\u6210\u201c\u8986\u76d6\u201d\uff1b\u5bf9\u4e8e\u5f53\u524d\u533a\u95f4<code>[a0, b0]</code>\u6765\u8bf4\uff0c\u5982\u679c\u6709\u591a\u4e2a\u533a\u95f4\u90fd\u6ee1\u8db3\u6761\u4ef6\uff0c\u90a3\u4e48\u4e00\u5b9a\u9009\u62e9\u53f3\u7aef\u70b9\u6700\u5927\u7684\u533a\u95f4\uff0c\u5426\u5219\u5c31\u4e0d\u80fd\u6ee1\u8db3\u201c\u6240\u9009\u533a\u95f4\u4e2a\u6570\u6700\u5c0f\u201d\u8fd9\u4e00\u76ee\u7684\u3002</p> <p>\u91cd\u70b9\uff1a</p> <ul> <li>\u6309\u533a\u95f4\u5de6\u7aef\u70b9\u6392\u5e8f\uff1b</li> <li>\u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff1a\u5224\u65ad\u5de6\u7aef\u70b9\u5728<code>st</code>\u4e4b\u524d\u7684\u533a\u95f4\uff0c\u5faa\u73af\u627e\u5230\u6700\u5927\u53f3\u7aef\u70b9\uff0c\u5982\u679c\u53f3\u7aef\u70b9\u4e5f\u5728<code>st</code>\u4e4b\u524d\uff0c\u8bf4\u660e\u65e0\u6cd5\u8986\u76d6\u3002\u4e0b\u4e00\u6b21\u679a\u4e3e\u7684\u65f6\u5019\u4f9d\u65e7\u7528\u8fd9\u4e2a\u533a\u95f4(<code>i</code>\u4e0d\u53d8)\uff1b</li> <li>\u5982\u679c\u627e\u5230\u5de6\u7aef\u70b9\u5728<code>st</code>\u4e4b\u524d\uff0c\u53f3\u7aef\u70b9\u5728<code>st</code>\u4e4b\u540e\u7684\u533a\u95f4\uff0c<code>i++</code>\uff1b</li> <li>\u6bcf\u5faa\u73af\u4e00\u6b21\uff0c\u6ca1\u6709\u5728\u524d\u9762\u8df3\u51fa\u7684\u8bdd\uff0c\u8bf4\u660e\u627e\u5230\u4e86\u4e00\u4e2a\u533a\u95f4\uff0c<code>res++</code>\uff1b</li> <li>\u5982\u679c\u8fd9\u4e2a\u533a\u95f4\u53f3\u7aef\u70b9\u80fd\u8986\u76d6<code>end</code>\uff0c\u8bf4\u660e\u80fd\u8986\u76d6\uff1b</li> <li>\u628a<code>st</code>\u66f4\u65b0\u6210<code>right</code>\uff0c\u4fdd\u8bc1\u540e\u9762\u7684\u533a\u95f4\u9002\u5408\u4e4b\u524d\u7684\u533a\u95f4\u6709\u4ea4\u96c6\uff0c\u4ece\u800c\u5f62\u6210\u5bf9\u6574\u4e2a\u5e8f\u5217\u7684\u8986\u76d6\uff1b</li> <li>\u5982\u679c\u904d\u5386\u4e86\u6240\u6709\u7684\u6570\u7ec4\uff0c\u8fd8\u662f\u6ca1\u6709\u8986\u76d6\u6700\u540e\u7684<code>end</code>\uff0c\u8bf4\u660e\u4e0d\u80fd\u6210\u529f\u3002</li> </ul> <p>\u4ee3\u7801\uff1a</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\n\nstruct Range {\n    int l, r;\n    bool operator&lt; (const Range &amp;W) const {\n        return l &lt; W.l;\n    }\n} range[N];\n\nint main() {\n    int st, ed;\n    scanf(\"%d%d\", &amp;st, &amp;ed);\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; i++) {\n        int l, r;\n        scanf(\"%d%d\", &amp;l, &amp;r);\n        range[i] = {l, r};\n    }\n\n    sort(range, range + n);\n\n    int res = 0;\n    bool success = false;\n    for (int i = 0; i &lt; n; ) {\n        int j = i, r = -2e9;\n        while (j &lt; n &amp;&amp; range[j].l &lt;= st) {\n            r = max(r, range[j].r);\n            j++;\n        }\n        if (r &lt; st) {\n            res = -1;\n            break;\n        }\n        res++;\n        if (r &gt;= ed) {\n            success = true;\n            break;\n        }\n        st = r;\n        i = j;\n    }\n\n    if (!success) res = -1;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n</code></pre>"},{"location":"zh/Greedy_Methods/02_Huffman_Coding/","title":"Huffman\u6811","text":"<p>\u4f2a\u4ee3\u7801\u4e3a\uff1a</p> <pre><code>HUFFMAN(C):\n    n = |C|\n    Q = priority_queue(C, key=frequency)  -- Initialize priority queue with frequencies\n    for i = 1 to n - 1:\n        z = new node\n        z.left = x = EXTRACT-MIN(Q)\n        z.right = y = EXTRACT-MIN(Q)\n        z.frequency = x.frequency + y.frequency\n        INSERT(Q, z)\n    return EXTRACT-MIN(Q)  -- Return the root of the Huffman tree\n</code></pre> <ul> <li><code>C</code>\u662f\u8981\u7f16\u7801\u7684\u5b57\u7b26\u96c6\uff1b</li> <li><code>C</code>\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26<code>c</code>\u90fd\u6709\u4e00\u4e2a\u9891\u7387<code>c.frequency</code>\uff1b</li> <li><code>Q</code>\u662f\u4e00\u4e2a\u4f18\u5148\u961f\u5217\uff0c\u5b83\u6839\u636e\u8282\u70b9\u7684\u9891\u7387\u5b58\u50a8\u8282\u70b9\uff1b</li> <li><code>z</code>\u662f\u4e00\u4e2a\u65b0\u7684\u5185\u90e8\u8282\u70b9\uff0c\u5177\u6709\u5b50\u8282\u70b9<code>x</code>\u548c<code>y</code>\uff1b</li> <li>\u8be5\u7b97\u6cd5\u6784\u9020\u4e86\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u5176\u4e2d\u53f6\u5b50\u662f<code>C</code>\u4e2d\u7684\u5b57\u7b26\uff1b</li> <li><code>EXTRACT-MIN(Q)</code>\u64cd\u4f5c\u4ece\u4f18\u5148\u7ea7\u961f\u5217Q\u4e2d\u79fb\u9664\u5e76\u8fd4\u56de\u5177\u6709\u6700\u5c0fkey\uff08\u5728\u672c\u4f8b\u4e2d\u4e3a\u9891\u7387\uff09\u7684\u5143\u7d20\u3002</li> </ul> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n\\log n)\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u5408\u5e76\u679c\u5b50</p> <p>\u57fa\u672c\u601d\u8def\uff1a\u6bcf\u6b21\u5408\u5e76\u91cd\u91cf\u6700\u5c0f\u7684\u4e24\u5806\u679c\u5b50\u3002</p> <p>\u6ce8\u610f\uff0c\u672c\u9898\u4e0e\u77f3\u5b50\u5408\u5e76\u95ee\u9898\u4e0d\u4e00\u6837\uff0c\u672c\u95ee\u4e0d\u8981\u6c42\u5408\u5e76\u7684\u201c\u679c\u5b50\u201d\u76f8\u90bb\u3002</p> <p>\u6211\u4eec\u4f7f\u7528\u5c0f\u6839\u5806\u7ef4\u62a4\u6240\u6709\u679c\u5b50\uff0c\u6bcf\u6b21\u5f39\u51fa\u5806\u9876\u7684\u4e24\u5806\u679c\u5b50\uff0c\u5e76\u5c06\u5176\u5408\u5e76\uff0c\u5408\u5e76\u4e4b\u540e\u5c06\u4e24\u5806\u91cd\u91cf\u4e4b\u548c\u518d\u6b21\u63d2\u5165\u5c0f\u6839\u5806\u4e2d\u3002</p> <p>\u6bcf\u6b21\u64cd\u4f5c\u4f1a\u5c06\u679c\u5b50\u7684\u5806\u6570\u51cf\u4e00\uff0c\u4e00\u5171\u64cd\u4f5c \\(n-1\\) \u6b21\u5373\u53ef\u5c06\u6240\u6709\u679c\u5b50\u5408\u5e76\u6210\u4e00\u5806\u3002\u6bcf\u6b21\u64cd\u4f5c\u6d89\u53ca\u5230\u4e24\u6b21\u5806\u7684\u5220\u9664\u64cd\u4f5c\u548c\u4e00\u6b21\u5806\u7684\u63d2\u5165\u64cd\u4f5c\uff0c\u8ba1\u7b97\u91cf\u662f \\(O(\\log n)\\)\uff0c\u56e0\u6b64\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n\\log n)\\)\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint main() {\n    // \u5c0f\u6839\u5806\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        heap.push(x);\n    }\n\n    int res = 0;\n    while (heap.size() &gt; 1) {\n        int a = heap.top(); heap.pop();\n        int b = heap.top(); heap.pop();\n        res += a + b;\n        heap.push(a + b);\n    }\n\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"zh/Leetcode/","title":"Leetcode\u9898\u89e3","text":""},{"location":"zh/Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/","title":"\u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0017-letter-combinations-of-a-phone-number/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    const string letterMap[10] = {\n    \"\", // 0\n    \"\", // 1\n    \"abc\", // 2\n    \"def\", // 3\n    \"ghi\", // 4\n    \"jkl\", // 5\n    \"mno\", // 6\n    \"pqrs\", // 7\n    \"tuv\", // 8\n    \"wxyz\" // 9\n};\n    vector&lt;string&gt; res;\n    string path;\n    void backtracking(string&amp; digits, int index) {\n        if (digits.length() == index) {\n            res.push_back(path);\n            return;\n        }\n        int digit = digits[index] - '0';\n        string letters = letterMap[digit];\n        for (int i = 0; i &lt; letters.size(); i++) {\n            path.push_back(letters[i]);\n            backtracking(digits, index + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if (digits.empty()) return res;\n        backtracking(digits, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0020-valid-parentheses/","title":"\u6709\u6548\u7684\u62ec\u53f7","text":"<p>Leetcode\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0020-valid-parentheses/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0020-valid-parentheses/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    bool isValid(string s) {\n        if (s.size() % 2) return false;\n\n        stack&lt;char&gt; stk;\n        for (int i = 0; i &lt; s.size(); i++) {\n            if (s[i] == '(') stk.push(')');\n            else if (s[i] == '[') stk.push(']');\n            else if (s[i] == '{') stk.push('}');\n            else if (stk.empty() || stk.top() != s[i]) return false;\n            else stk.pop();\n        }\n\n        return stk.empty();\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0021-merge-two-sorted-lists/","title":"\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868","text":"<p>Leetcode\u9898\u76ee\u8fde\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0021-merge-two-sorted-lists/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0021-merge-two-sorted-lists/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if (!list1) return list2;\n        if (!list2) return list1;\n        ListNode* tail = new ListNode();\n        ListNode* preHead = tail;\n        auto p = list1, q = list2;\n        while (p &amp;&amp; q) {\n            if (p-&gt;val &lt;= q-&gt;val) {\n                tail-&gt;next = new ListNode(p-&gt;val);\n                p = p-&gt;next;\n            } else {\n                tail-&gt;next = new ListNode(q-&gt;val);\n                q = q-&gt;next;\n            }\n            tail = tail-&gt;next;\n        }\n        while (p) {\n            tail-&gt;next = new ListNode(p-&gt;val);\n            p = p-&gt;next;\n            tail = tail-&gt;next;\n        }\n        while (q) {\n            tail-&gt;next = new ListNode(q-&gt;val);\n            q = q-&gt;next;\n            tail = tail-&gt;next;\n        }\n        return preHead-&gt;next;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0023-merge-k-sorted-lists/","title":"\u5408\u5e76 K \u4e2a\u5347\u5e8f\u94fe\u8868","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0023-merge-k-sorted-lists/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0023-merge-k-sorted-lists/#_2","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        auto cmp = [](ListNode* a, ListNode* b) {\n            return a-&gt;val &gt; b-&gt;val;\n        };\n\n        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; q(cmp);\n\n        for (auto head : lists) {\n            if (head) q.push(head);\n        }\n\n        auto dummy = new ListNode(), tail = dummy;\n\n        while (!q.empty()) {\n            auto node = q.top(); q.pop();\n            tail-&gt;next = node;\n            tail = tail-&gt;next;\n            if (node-&gt;next) q.push(node-&gt;next);\n        }\n\n        auto mergeHead = dummy-&gt;next;\n        delete dummy;\n        return mergeHead;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/","title":"\u627e\u51fa\u5b57\u7b26\u4e32\u4e2d\u7b2c\u4e00\u4e2a\u5339\u914d\u9879\u7684\u4e0b\u6807","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0028-find-the-index-of-the-first-occurrence-in-a-string/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n = haystack.size(), m = needle.size();\n        haystack = ' ' + haystack;\n        needle = ' ' + needle;\n        vector&lt;int&gt; ne(m + 1);\n        for (int i = 2, j = 0; i &lt;= m; i++) {\n            while (j &amp;&amp; needle[i] != needle[j + 1]) j = ne[j];\n            if (needle[i] == needle[j + 1]) j++;\n            ne[i] = j;\n        }\n        for (int i = 1, j = 0; i &lt;= n; i++) {\n            while (j &amp;&amp; haystack[i] != needle[j + 1]) j = ne[j];\n            if (haystack[i] == needle[j + 1]) j++;\n            if (j == m) return i - m;\n        }\n        return -1;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0036-valid-sudoku/","title":"\u6709\u6548\u7684\u6570\u72ec","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0036-valid-sudoku/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0036-valid-sudoku/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int row[9][9];\n        int col[9][9];\n        int box[3][3][9];\n        memset(row, 0, sizeof(row));\n        memset(col, 0, sizeof(col));\n        memset(box, 0, sizeof(box));\n        for (int i = 0; i &lt; board.size(); i++) {\n            for (int j = 0; j &lt; board[0].size(); j++) {\n                if (board[i][j] == '.') continue;\n                int num = board[i][j] - '1';\n                if (row[i][num] || col[j][num] || box[i / 3][j / 3][num])\n                    return false;\n                row[i][num] = col[j][num] = box[i / 3][j / 3][num] = 1;\n            }\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0037-sudoku-solver/","title":"\u89e3\u6570\u72ec","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0037-sudoku-solver/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0037-sudoku-solver/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i = 0; i &lt; board.size(); i++) {\n            for (int j = 0; j &lt; board[0].size(); j++) {\n                if (board[i][j] == '.') {\n                    for (char k = '1'; k &lt;= '9'; k++) {\n                        if (isValid(i, j, k, board)) {\n                            board[i][j] = k;\n                            if (backtracking(board)) return true;\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool isValid(int row, int col, char val, vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        for (int i = 0; i &lt; 9; i++) {\n            if (board[row][i] == val)\n                return false;\n        }\n        for (int j = 0; j &lt; 9; j++) {\n            if (board[j][col] == val)\n                return false;\n        }\n        int rowIndex = (row / 3) * 3;\n        int colIndex = (col / 3) * 3;\n        for (int i = rowIndex; i &lt; rowIndex + 3; i++) {\n            for (int j = colIndex; j &lt; colIndex + 3; j++) {\n                if (board[i][j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        backtracking(board);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0039-combination-sum/","title":"\u7ec4\u5408\u603b\u548c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0039-combination-sum/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0039-combination-sum/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        if (sum &lt; 0) return;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; candidates.size(); i++) {\n            path.push_back(candidates[i]);\n            backtracking(candidates, sum - candidates[i], i);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0040-combination-sum-ii/","title":"\u7ec4\u5408\u603b\u548cII","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0040-combination-sum-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0040-combination-sum-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; candidates, int sum, int startIndex) {\n        // if (sum &lt; 0) return;\n        if (sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum - candidates[i] &gt;= 0; i++) {\n            if (i != startIndex &amp;&amp; candidates[i] == candidates[i - 1]) continue;\n            path.push_back(candidates[i]);\n            backtracking(candidates, sum - candidates[i], i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0042-trapping-rain-water/","title":"\u63a5\u96e8\u6c34","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0042-trapping-rain-water/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0042-trapping-rain-water/#_3","title":"\u89e3\u7b54","text":""},{"location":"zh/Leetcode/0001-0099/0042-trapping-rain-water/#_4","title":"\u53cc\u6307\u9488","text":"<pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        if (height.size() &lt;= 2) return 0;\n        vector&lt;int&gt; maxLeft(height.size(), 0);\n        vector&lt;int&gt; maxRight(height.size(), 0);\n        int sizeH = maxRight.size();\n\n        maxLeft[0] = height[0];\n        for (int i = 1; i &lt; sizeH; i++)\n            maxLeft[i] = max(height[i], maxLeft[i - 1]);\n\n        maxRight[sizeH - 1] = height[sizeH - 1];\n        for (int i = sizeH - 2; i &gt;= 0; i--)\n            maxRight[i] = max(height[i], maxRight[i + 1]);\n\n        int res = 0;\n        for (int i = 0; i &lt; sizeH; i++) {\n            int sum = min(maxLeft[i], maxRight[i]) - height[i];\n            if (sum &gt;= 0) res += sum;\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0042-trapping-rain-water/#_5","title":"\u5355\u8c03\u6808","text":"<pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        if (height.size() &lt;= 2) return 0;\n        stack&lt;int&gt; stk;\n        int sum = 0;\n        for (int i = 0; i &lt; height.size(); i++) {\n            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) {\n                int mid = stk.top();\n                stk.pop();\n                if (!stk.empty()) {\n                    int h = min(height[stk.top()], height[i]) - height[mid];\n                    int w = i - stk.top() - 1;\n                    sum += h * w;\n                }\n            }\n            stk.push(i);\n        }\n        return sum;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0046-permutations/","title":"\u5168\u6392\u5217","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0046-permutations/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0046-permutations/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n\n    void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) {\n        if (path.size() == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (used[i] == true) continue;\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        vector&lt;bool&gt; used(nums.size(), false);\n        backtracking(nums, used);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0047-permutations-ii/","title":"\u5168\u6392\u5217 II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0047-permutations-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0047-permutations-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) {\n        if (path.size() == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;\n            if (used[i]) continue;\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;bool&gt; used(nums.size(), false);\n        backtracking(nums, used);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0051-n-queens/","title":"N\u7687\u540e","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0051-n-queens/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0051-n-queens/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    int sizeBoard;\n    vector&lt;bool&gt; column, lDiagonal, rDiagonal;\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n    void backtracking(int index) {\n        if (index == sizeBoard) {\n            res.push_back(path);\n            return;\n        }\n        for (int j = 0; j &lt; sizeBoard; j++) {\n            if (column[j] || lDiagonal[index + j] || rDiagonal[sizeBoard - index + j]) continue;\n            column[j] = lDiagonal[index + j] = rDiagonal[sizeBoard - index + j] = true;\n            path[index][j] = 'Q';\n            backtracking(index + 1);\n            path[index][j] = '.';\n            column[j] = lDiagonal[index + j] = rDiagonal[sizeBoard - index + j] = false;\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        sizeBoard = n;\n        column = vector&lt;bool&gt;(sizeBoard, false);\n        lDiagonal = rDiagonal = vector&lt;bool&gt;(2 * sizeBoard, false);\n        path = vector&lt;string&gt;(sizeBoard, string(sizeBoard, '.'));\n\n        backtracking(0);\n\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0052-n-queens-ii/","title":"N\u7687\u540e II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0052-n-queens-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0052-n-queens-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    int res;\n    vector&lt;bool&gt; dg, udg, col;\n    int _n;\n    void backtracking(int row) {\n        if (row == _n) {\n            res++;\n            return;\n        }\n        for (int i = 0; i &lt; _n; i++) {\n            if (!col[i] &amp;&amp; !dg[row - i + _n] &amp;&amp; !udg[row + i]) {\n                col[i] = dg[row - i + _n] = udg[row + i] = true;\n                backtracking(row + 1);\n                col[i] = dg[row - i + _n] = udg[row + i] = false;\n            }\n        }\n    }\npublic:\n    int totalNQueens(int n) {\n        _n = n;\n        col = vector&lt;bool&gt;(n, false);\n        dg = udg = vector&lt;bool&gt;(2 * n, false);\n        res = 0;\n        backtracking(0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0062-unique-paths/","title":"\u4e0d\u540c\u8def\u5f84","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0062-unique-paths/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0062-unique-paths/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int dp[110][110];\n    int uniquePaths(int m, int n) {\n        for (int i = 0; i &lt; 110; i++) dp[i][0] = dp[0][i] = 1;\n        for (int i = 1; i &lt; m; i++) \n            for (int j = 1; j &lt; n; j++)\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        return dp[m - 1][n - 1];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0063-unique-paths-ii/","title":"\u4e0d\u540c\u8def\u5f84II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0063-unique-paths-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0063-unique-paths-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));\n        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;\n        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;\n\n        for (int i = 1; i &lt; m; i++) {\n            for (int j = 1; j &lt; n; j++) {\n                if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n                else continue;\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0070-climbing-stairs/","title":"\u722c\u697c\u68af","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0070-climbing-stairs/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0070-climbing-stairs/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int dp[50];\n    int climbStairs(int n) {\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0077-combinations/","title":"\u7ec4\u5408","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0077-combinations/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0077-combinations/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtrack(int n, int k, int startIndex) {\n        if (path.size() == k) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) {\n            path.push_back(i);\n            backtrack(n, k, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        backtrack(n, k, 1);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0078-subsets/","title":"\u5b50\u96c6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0078-subsets/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0078-subsets/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        res.push_back(path);\n        // if (startIndex &gt;= nums.size()) return;\n\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0090-subsets-ii/","title":"\u5b50\u96c6II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0090-subsets-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0090-subsets-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        res.push_back(path);\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1]) continue;\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n       sort(nums.begin(), nums.end());\n       backtracking(nums, 0);\n       return res; \n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0093-restore-ip-addresses/","title":"\u590d\u539f IP \u5730\u5740","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0093-restore-ip-addresses/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0093-restore-ip-addresses/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;string&gt; res;\n    void backtracking(const string &amp;s, int startIndex, int currSize, string path) {\n        if (startIndex == s.length()) {\n            if (currSize == 4) {\n                path.pop_back();  // delete the final \".\"\n                res.push_back(path);\n            }\n            return;\n        }\n\n        if (currSize == 4) return;\n\n        for (int i = startIndex, temp = 0; i &lt; s.length(); i++) {\n            if (i &gt; startIndex &amp;&amp; s[startIndex] == '0') break;\n            temp = temp * 10 + s[i] - '0';\n            if (temp &lt;= 255) \n                backtracking(s, i + 1, currSize + 1, path + to_string(temp) + '.');\n            else break;\n        }\n    }\npublic:\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        backtracking(s, 0, 0, \"\");\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0094-binary-tree-inorder-traversal/","title":"\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0094-binary-tree-inorder-traversal/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void inOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        inOrder(node-&gt;left, res);\n        res.push_back(node-&gt;val);\n        inOrder(node-&gt;right, res);\n    }\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        inOrder(root, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0096-unique-binary-search-trees/","title":"\u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0096-unique-binary-search-trees/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0096-unique-binary-search-trees/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int numTrees(int n) {\n        long long res = 1;\n        for (int i = n + 1; i &lt;= 2 * n; i++) {\n            res = res * i / (i - n);\n        }\n        return res / (n + 1);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0001-0099/0098-validate-binary-search-tree/","title":"\u9a8c\u8bc1\u4e8c\u53c9\u641c\u7d22\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0001-0099/0098-validate-binary-search-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0001-0099/0098-validate-binary-search-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    bool traversal(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\n        if (!node) return true;\n        if (minNode &amp;&amp; node-&gt;val &lt;= minNode-&gt;val) return false;\n        if (maxNode &amp;&amp; node-&gt;val &gt;= maxNode-&gt;val) return false;\n        return traversal(node-&gt;left, minNode, node) &amp;&amp; traversal(node-&gt;right, node, maxNode);\n    }\npublic:\n    bool isValidBST(TreeNode* root) {\n        return traversal(root, nullptr, nullptr);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0100-same-tree/","title":"\u76f8\u540c\u7684\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0100-same-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0100-same-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p &amp;&amp; !q) return true;\n        if (!p || !q || p-&gt;val != q-&gt;val) return false;\n        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0101-symmetric-tree/","title":"\u5bf9\u79f0\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0101-symmetric-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0101-symmetric-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right) {\n        if (!left &amp;&amp; right) return false;\n        if (left &amp;&amp; !right) return false;\n        if (!left &amp;&amp; !right) return true;\n        if (left-&gt;val != right-&gt;val) return false;\n\n        bool outside = compare(left-&gt;left, right-&gt;right);\n        bool inside = compare(left-&gt;right, right-&gt;left);\n        return outside &amp;&amp; inside;\n    }\n    bool isSymmetric(TreeNode* root) {\n        return compare(root-&gt;left, root-&gt;right);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0102-binary-tree-level-order-traversal/","title":"\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0102-binary-tree-level-order-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0102-binary-tree-level-order-traversal/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        queue&lt;TreeNode*&gt; q;\n        if (root) q.push(root);\n        while (!q.empty()) {\n            int len = q.size();\n            vector&lt;int&gt; temp;\n            for (int i = 0; i &lt; len; i++) {\n                auto node = q.front();\n                q.pop();\n                temp.push_back(node-&gt;val);\n                if (node-&gt;left) q.push(node-&gt;left);\n                if (node-&gt;right) q.push(node-&gt;right);\n            }\n            res.push_back(temp);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/","title":"\u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0104-maximum-depth-of-binary-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/","title":"\u4ece\u524d\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    unordered_map&lt;int, int&gt; pos;\n    TreeNode* treeBuilder(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preorderLeft, int preorderRight, int inorderLeft, int inorderRight) {\n        if (preorderLeft &gt; preorderRight) return nullptr;\n        auto root = new TreeNode(preorder[preorderLeft]);\n        int index = pos[root-&gt;val];\n        root-&gt;left = treeBuilder(preorder, inorder, \n        preorderLeft + 1, preorderLeft + 1 + index - 1 - inorderLeft, \n        inorderLeft, index - 1);\n        root-&gt;right = treeBuilder(preorder, inorder, \n        preorderLeft + 1 + index - 1 - inorderLeft + 1, preorderRight, \n        index + 1, inorderRight);\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        int treeSize = inorder.size();\n        for (int i = 0; i &lt; treeSize; i++) pos[inorder[i]] = i;\n        return treeBuilder(preorder, inorder, 0, treeSize - 1, 0, treeSize - 1);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/","title":"\u4ece\u4e2d\u5e8f\u4e0e\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#_3","title":"\u89e3\u7b54","text":""},{"location":"zh/Leetcode/0100-0199/0110-balanced-binary-tree/","title":"\u5e73\u8861\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0110-balanced-binary-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0110-balanced-binary-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int depth(TreeNode* node) {\n        if (!node) return 0;\n        return max(depth(node-&gt;left), depth(node-&gt;right)) + 1;\n    }\npublic:\n    bool isBalanced(TreeNode* root) {\n        if (!root) return true;\n        return (abs(depth(root-&gt;left) - depth(root-&gt;right)) &lt;= 1) &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/","title":"\u4e8c\u53c9\u6811\u7684\u6700\u5c0f\u6df1\u5ea6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0111-minimum-depth-of-binary-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root) return 0;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        int depth = 0;\n        while (!q.empty()) {\n            int len = q.size();\n            depth++;\n            while (len--) {\n                auto node = q.front();\n                q.pop();\n                if (!node-&gt;left &amp;&amp; !node-&gt;right) return depth;\n                if (node-&gt;left) q.push(node-&gt;left);\n                if (node-&gt;right) q.push(node-&gt;right);\n            }\n        }\n        return depth;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0112-path-sum/","title":"\u8def\u5f84\u603b\u548c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0112-path-sum/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0112-path-sum/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (!root) return false;\n        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val) return true;\n        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0113-path-sum-ii/","title":"\u8def\u5f84\u603b\u548c II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0113-path-sum-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0113-path-sum-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void findPaths(TreeNode* root, vector&lt;int&gt; path, int sum) {\n        if (!root) return;\n        sum -= root-&gt;val;\n        path.push_back(root-&gt;val);\n        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) {\n            res.push_back(path);\n            return;\n        }\n        findPaths(root-&gt;left, path, sum);\n        findPaths(root-&gt;right, path, sum);\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        findPaths(root, path, targetSum);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0120-triangle/","title":"\u4e09\u89d2\u5f62\u6700\u5c0f\u8def\u5f84\u548c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0120-triangle/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0120-triangle/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        for (int i = triangle.size() - 2; i &gt;= 0; i--) {\n            for (int j = 0; j &lt;= i; j++) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0126-word-ladder-ii/","title":"\u5355\u8bcd\u63a5\u9f99 II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0126-word-ladder-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0126-word-ladder-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    void dfs(string&amp; beginWord, string word, vector&lt;string&gt;&amp; path, unordered_map&lt;string, int&gt;&amp; dist) {\n        if (word == beginWord) {\n            reverse(path.begin(), path.end());\n            res.push_back(path);\n            reverse(path.begin(), path.end());\n        } else {\n            for (int i = 0; i &lt; word.size(); i++) {\n                string oldWord = word;\n                for (int j = 'a'; j &lt;= 'z'; j++) {\n                    oldWord[i] = j;\n                    if (dist.count(oldWord) &amp;&amp; dist[oldWord] + 1 == dist[word]) {\n                        path.push_back(oldWord);\n                        dfs(beginWord, oldWord, path, dist);\n                        path.pop_back();\n                    }\n                }\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) return res;\n\n        unordered_map&lt;string, int&gt; dist;\n        dist[beginWord] = 0;\n\n        queue&lt;string&gt; que;\n        que.push(beginWord);\n\n        while (!que.empty()) {\n            string word = que.front();\n            que.pop();\n\n            for (int i = 0; i &lt; word.size(); i++) {\n                string newWord = word;\n                for (char j = 'a'; j &lt;= 'z'; j++) {\n                    newWord[i] = j;\n                    if (wordSet.count(newWord) &amp;&amp; !dist.count(newWord)) {\n                        dist[newWord] = dist[word] + 1;\n                        if (newWord == endWord) break;\n                        que.push(newWord);\n                    }\n                }\n            }\n        }\n\n        vector&lt;string&gt; path;\n        path.push_back(endWord);\n        dfs(beginWord, endWord, path, dist);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0127-word-ladder/","title":"\u5355\u8bcd\u63a5\u9f99","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0127-word-ladder/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0127-word-ladder/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) return 0;\n\n        unordered_map&lt;string, int&gt; visitMap;\n        queue&lt;string&gt; que;\n        que.push(beginWord);\n        visitMap[beginWord] = 1;\n\n        while (!que.empty()) {\n            string word = que.front();\n            que.pop();\n\n            int path = visitMap[word];\n            for (int i = 0; i &lt; word.size(); i++) {\n                string newWord = word;\n                for (int j = 0; j &lt; 26; j++) {\n                    newWord[i] = j + 'a';\n                    if (newWord == endWord) return path + 1;\n                    if (wordSet.count(newWord) &amp;&amp; !visitMap.count(newWord)) {\n                        visitMap[newWord] = path + 1;\n                        que.push(newWord);\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0128-longest-consecutive-sequence/","title":"\u6700\u957f\u8fde\u7eed\u5e8f\u5217","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0128-longest-consecutive-sequence/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0128-longest-consecutive-sequence/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        unordered_set&lt;int&gt; s(nums.begin(), nums.end());\n        int best = 0;\n        for (int x : s) {\n            if (s.find(x - 1) == s.end()) {\n                int curr = x + 1;\n                while (s.find(curr) != s.end()) curr++;\n                best = max(best, curr - x);\n            }\n        }\n        return best;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0130-surrounded-regions/","title":"\u88ab\u56f4\u7ed5\u7684\u533a\u57df","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0130-surrounded-regions/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0130-surrounded-regions/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    int n, m;\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) {\n        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != 'O') return;\n        board[x][y] = '#';\n        dfs(board, x + 1, y);\n        dfs(board, x - 1, y);\n        dfs(board, x, y - 1);\n        dfs(board, x, y + 1);\n    }\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        n = board.size(), m = board[0].size();\n        for (int i = 0; i &lt; n; i++) {\n            dfs(board, i, 0);\n            dfs(board, i, m - 1);\n        }\n        for (int i = 1; i &lt; m - 1; i++) {\n            dfs(board, 0, i);\n            dfs(board, n - 1, i);\n        }\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (board[i][j] == '#') board[i][j] = 'O';\n                else if (board[i][j] == 'O') board[i][j] = 'X';\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0131-palindrome-partitioning/","title":"\u5206\u5272\u56de\u6587\u4e32","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0131-palindrome-partitioning/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0131-palindrome-partitioning/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;string&gt;&gt; res;\n    vector&lt;string&gt; path;\n\n    void backtracking(string &amp;s, int index) {\n        if (index == s.length()) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = index; i &lt; s.length(); i++) {\n            if (!isPalindrome(s, index, i)) continue;\n            path.push_back(s.substr(index, i - index + 1));\n            backtracking(s, i + 1);\n            path.pop_back();\n        }\n    }\n\n    bool isPalindrome(string &amp;s, int l, int r) {\n        while (l &lt; r) {\n            if (s[l] != s[r]) return false;\n            l++, r--;\n        }\n        return true;\n    }\n\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        backtracking(s, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0139-word-break/","title":"\u5355\u8bcd\u62c6\u5206","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0139-word-break/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0139-word-break/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());\n        vector&lt;bool&gt; dp(s.size() + 1, false);\n        dp[0] = true;\n        for (int i = 1; i &lt;= s.size(); i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if ((wordSet.find(s.substr(j, i - j)) != wordSet.end()) &amp;&amp; dp[j])\n                    dp[i] = true;\n            }\n        }\n        return dp[s.size()];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0144-binary-tree-preorder-traversal/","title":"\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0144-binary-tree-preorder-traversal/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void preOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        res.push_back(node-&gt;val);\n        preOrder(node-&gt;left, res);\n        preOrder(node-&gt;right, res);\n    }\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        preOrder(root, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0145-binary-tree-postorder-traversal/","title":"\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0145-binary-tree-postorder-traversal/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void postOrder(TreeNode* node, vector&lt;int&gt; &amp;res) {\n        if (node == nullptr) return;\n        postOrder(node-&gt;left, res);\n        postOrder(node-&gt;right, res);\n        res.push_back(node-&gt;val);\n    }\n\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; res;\n        postOrder(root, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0148-sort-list/","title":"\u6392\u5e8f\u94fe\u8868","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0148-sort-list/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0148-sort-list/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        int n = 0;\n        for (auto p = head; p; p = p-&gt;next) n++;\n\n        auto dummy = new ListNode();\n        dummy-&gt;next = head;\n\n        for (int i = 1; i &lt; n; i *= 2) {\n            auto curr = dummy;\n            for (int j = 1; j + i &lt;= n; j += i * 2) {\n                auto p = curr-&gt;next, q = p;\n                for (int k = 0; k &lt; i; k++) q = q-&gt;next;\n\n                int x = 0, y = 0;\n                while (x &lt; i &amp;&amp; y &lt; i &amp;&amp; p &amp;&amp; q) {\n                    if (p-&gt;val &lt;= q-&gt;val) {\n                        curr = curr-&gt;next = p;\n                        p = p-&gt;next;\n                        x++;\n                    } else {\n                        curr = curr-&gt;next = q;\n                        q = q-&gt;next;\n                        y++;\n                    }\n                }\n\n                while (x &lt; i &amp;&amp; p) {\n                    curr = curr-&gt;next = p;\n                    p = p-&gt;next;\n                    x++;\n                }\n                while (y &lt; i &amp;&amp; q) {\n                    curr = curr-&gt;next = q;\n                    q = q-&gt;next;\n                    y++;\n                }\n                curr-&gt;next = q;\n            }\n        }\n\n        return dummy-&gt;next;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/","title":"\u9006\u6ce2\u5170\u8868\u8fbe\u5f0f\u6c42\u503c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0100-0199/0150-evaluate-reverse-polish-notation/#_3","title":"\u89e3\u7b54","text":"<p>\u53c2\u8003\u81ea\u6b64\u9875\u9762\u3002</p> <pre><code>class Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        stack&lt;long long&gt; st; \n        for (int i = 0; i &lt; tokens.size(); i++) {\n            if (tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\") {\n                long long num1 = st.top();\n                st.pop();\n                long long num2 = st.top();\n                st.pop();\n                if (tokens[i] == \"+\") st.push(num2 + num1);\n                if (tokens[i] == \"-\") st.push(num2 - num1);\n                if (tokens[i] == \"*\") st.push(num2 * num1);\n                if (tokens[i] == \"/\") st.push(num2 / num1);\n            } else {\n                st.push(stoll(tokens[i]));\n            }\n        }\n\n        int result = st.top();\n        st.pop(); // \u628a\u6808\u91cc\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5f39\u51fa\uff08\u5176\u5b9e\u4e0d\u5f39\u51fa\u4e5f\u6ca1\u4e8b\uff09\n        return result;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0200-number-of-islands/","title":"\u5c9b\u5c7f\u6570\u91cf","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0200-number-of-islands/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0200-number-of-islands/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    int n, m;\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int x, int y) {\n        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return;\n        if (grid[x][y] == '0') return;\n        grid[x][y] = '0';\n        dfs(grid, x + 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y - 1);\n    }\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        int res = 0;\n        n = grid.size(), m = grid[0].size();\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0208-implement-trie-prefix-tree/","title":"\u5b9e\u73b0 Trie (\u524d\u7f00\u6811)","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0208-implement-trie-prefix-tree/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0208-implement-trie-prefix-tree/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Trie {\nprivate:\n    const static int N = 31010;\n    int son[N][26] {0};\n    int cnt[N] {0};\n    int idx = 0;\npublic:\n    Trie() {\n\n    }\n\n    void insert(string word) {\n        int p = 0;\n        for (char ch : word) {\n            int u = ch - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n        }\n        cnt[p]++;\n    }\n\n    bool search(string word) {\n        int p = 0;\n        for (char ch : word) {\n            int u = ch - 'a';\n            if (!son[p][u]) return false;\n            p = son[p][u];\n        }\n        return cnt[p] &gt; 0;\n    }\n\n    bool startsWith(string prefix) {\n        int p = 0;\n        for (char ch : prefix) {\n            int u = ch - 'a';\n            if (!son[p][u]) return false;\n            p = son[p][u];\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj-&gt;insert(word);\n * bool param_2 = obj-&gt;search(word);\n * bool param_3 = obj-&gt;startsWith(prefix);\n */\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0215-kth-largest-element-in-an-array/","title":"\u6570\u7ec4\u4e2d\u7684\u7b2cK\u4e2a\u6700\u5927\u5143\u7d20","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0215-kth-largest-element-in-an-array/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n        for (auto num : nums) {\n            q.push(num);\n            if (q.size() &gt; k) q.pop();\n        }\n        return q.top();\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0216-combination-sum-iii/","title":"\u7ec4\u5408\u603b\u548c III","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0216-combination-sum-iii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0216-combination-sum-iii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(int k, int n, int sum, int startIndex) {\n        if (sum &gt; n) return;\n        if (path.size() == k) {\n            if (sum == n) res.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) {\n            path.push_back(i);\n            backtracking(k, n, sum + i, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {\n        backtracking(k, n, 0, 1);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0222-count-complete-tree-nodes/","title":"\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u4e2a\u6570","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0222-count-complete-tree-nodes/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0222-count-complete-tree-nodes/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) return 0;\n        TreeNode* l = root, * r = root;\n        int lDepth = 0, rDepth = 0;\n        while (l) { l = l-&gt;left; lDepth++; }\n        while (r) { r = r-&gt;right; rDepth++; }\n        if (lDepth == rDepth) return (1 &lt;&lt; lDepth) - 1;\n        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0225-implement-stack-using-queues/","title":"\u7528\u961f\u5217\u5b9e\u73b0\u6808","text":"<p>Leetcode\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0225-implement-stack-using-queues/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0225-implement-stack-using-queues/#_3","title":"\u89e3\u7b54","text":"<pre><code>class MyStack {\npublic:\n    queue&lt;int&gt; q, sq;\n    MyStack() {\n\n    }\n\n    void push(int x) {\n        q.push(x);\n    }\n\n    int pop() {\n        while (q.size() &gt; 1) {\n            sq.push(q.front());\n            q.pop();\n        }\n        int res = q.front();\n        q.pop();\n        while (!sq.empty()) {\n            q.push(sq.front());\n            sq.pop();\n        }\n        return res;\n    }\n\n    int top() {\n        return q.back();\n    }\n\n    bool empty() {\n        return q.empty();\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0226-invert-binary-tree/","title":"\u7ffb\u8f6c\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0226-invert-binary-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0226-invert-binary-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (!root) return nullptr;\n        swap(root-&gt;left, root-&gt;right);\n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        return root;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0232-implement-queue-using-stacks/","title":"\u7528\u961f\u5217\u5b9e\u73b0\u6808","text":"<p>Leetcode\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0232-implement-queue-using-stacks/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0232-implement-queue-using-stacks/#_3","title":"\u89e3\u7b54","text":"<pre><code>class MyQueue {\npublic:\n    stack&lt;int&gt; stkIn, stkOut;\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        stkIn.push(x);\n    }\n\n    int pop() {\n        // Import data from stIn only if stOut is empty (import all stIn data)\n        if (stkOut.empty()) {\n            while (!stkIn.empty()) {\n                stkOut.push(stkIn.top());\n                stkIn.pop();\n            }\n        }\n        int result = stkOut.top();\n        stkOut.pop();\n        return result;\n    }\n\n    int peek() {\n        int result = this-&gt;pop();\n        // Because the pop function pops the element \"result\",\n        // it need to be added back again\n        stkOut.push(result);\n        return result;\n    }\n\n    bool empty() {\n        return stkIn.empty() &amp;&amp; stkOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0239-sliding-window-maximum/","title":"\u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c","text":"<p>Leetcode\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0239-sliding-window-maximum/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0239-sliding-window-maximum/#_3","title":"\u89e3\u7b54","text":"<p>\u5355\u8c03\u961f\u5217\u662f\u961f\u5c3e\u65e2\u53ef\u4ee5\u8fdb\u961f\u4e5f\u53ef\u4ee5\u51fa\u961f\u3001\u961f\u5934\u53ef\u4ee5\u51fa\u961f\u7684\u961f\u5217 (\u76ee\u7684\u662f\u7ef4\u62a4\u5b50\u5e8f\u5217\u7684\u5355\u8c03\u6027)\u3002\u7ef4\u62a4\u6700\u5927\u503c\u5c31\u662f\u7ef4\u62a4\u6ed1\u52a8\u7a97\u53e3\u5185\u7684\u964d\u5e8f\u5b50\u5e8f\u5217\u3002</p> <p>\u6ce8\u610f\uff1a</p> <ul> <li>\u961f\u5c3e\u51fa\u961f\u7684\u6761\u4ef6\uff1a\u961f\u5217\u4e0d\u7a7a\u4e14\u65b0\u5143\u7d20\u66f4\u4f18\uff0c\u5219\u961f\u4e2d\u65e7\u5143\u7d20\u4ece\u961f\u5c3e\u51fa\u961f\uff1b</li> <li>\u6bcf\u4e2a\u5143\u7d20\u5fc5\u7136\u4ece\u961f\u5c3e\u8fdb\u961f\u4e00\u6b21\uff1b</li> <li>\u961f\u5934\u51fa\u961f\u7684\u6761\u4ef6\uff1a\u961f\u4e2d\u5143\u7d20\u6ed1\u51fa\u4e86\u7a97\u53e3\uff1b</li> <li>\u961f\u5217\u4e2d\u5b58\u50a8\u5143\u7d20\u7684\u4e0b\u6807(\u800c\u4e0d\u662f\u6570\u7ec4\u4e2d\u7684\u5143\u7d20)\uff0c\u65b9\u4fbf\u5224\u65ad\u961f\u5934\u51fa\u961f\u3002</li> </ul> <p>\u4ee3\u7801<code>for</code>\u5faa\u73af\u5185\u7684\u6b65\u9aa4\uff1a</p> <ol> <li>\u89e3\u51b3\u961f\u9996\u5df2\u7ecf\u51fa\u7a97\u53e3\u7684\u95ee\u9898\uff1b</li> <li>\u89e3\u51b3\u961f\u5c3e\u4e0e\u5f53\u524d\u5143\u7d20<code>a[i]</code>\u4e0d\u6ee1\u8db3\u5355\u8c03\u6027\u7684\u95ee\u9898\uff1b</li> <li>\u5c06\u5f53\u524d\u5143\u7d20\u4e0b\u6807\u52a0\u5165\u961f\u5c3e\uff1b</li> <li>\u5982\u679c\u6ee1\u8db3\u6761\u4ef6\u5219\u8f93\u51fa\u7ed3\u679c\u3002</li> </ol> <p>\u4ee5\u4e0a\u6b65\u9aa4\u9700\u8981\u6ce8\u610f\u7684\u7ec6\u8282\uff1a</p> <ul> <li>\u4e0a\u9762\u56db\u4e2a\u6b65\u9aa4\u4e2d\u4e00\u5b9a\u8981\u51483\u540e4\uff0c\u56e0\u4e3a\u6709\u53ef\u80fd\u8f93\u51fa\u7684\u6b63\u662f\u65b0\u52a0\u5165\u7684\u90a3\u4e2a\u5143\u7d20\uff1b</li> <li>\u961f\u5217\u4e2d\u5b58\u7684\u662f\u539f\u6570\u7ec4\u7684\u4e0b\u6807\uff0c\u53d6\u503c\u65f6\u8981\u518d\u5957\u4e00\u5c42\uff0c<code>a[q[]]</code>\uff1b</li> <li>\u7b97\u6700\u5927\u503c\u524d\u6ce8\u610f\u5c06<code>hh</code>\u548c<code>tt</code>\u91cd\u7f6e\uff1b</li> <li><code>hh</code>\u4ece<code>0</code>\u5f00\u59cb\uff0c\u5219\u6570\u7ec4\u4e0b\u6807\u4e5f\u8981\u4ece<code>0</code>\u5f00\u59cb\u3002</li> </ul> <p>\u5173\u4e8e\u521d\u59cb\u5316\u7684\u6ce8\u610f\uff1a</p> <ul> <li><code>hh</code>\u548c<code>tt</code>\u7684\u521d\u59cb\u5316\u662f\u4e0e\u6570\u7ec4\u7b2c\u4e00\u4e2a\u503c\u4e0b\u6807\u6709\u5173\u7684\uff1a<code>hh</code>\u5c0f\u4e8e\u7b49\u4e8e\u6570\u7ec4\u7b2c\u4e00\u4e2a\u4e0b\u6807(\u5982\u6570\u7ec4\u4e0b\u6807\u4ece<code>0</code>\u5f00\u59cb\uff0c<code>hh &lt;= 0</code>\uff1b\u6570\u7ec4\u4e0b\u6807\u4ece<code>1</code>\u5f00\u59cb\uff0c<code>hh &lt;= 1</code>\uff0c\u53ef\u4ee5\u662f<code>1</code>\u3001<code>0</code>\u3001<code>-1</code>\u7b49\u7b49)\uff1b</li> <li>\u5bf9\u4e8e\u6570\u7ec4\u7b2c\u4e00\u4e2a\u503c\u4e0b\u6807\u4ece<code>0</code>\u8fd8\u662f\u4ece<code>1</code>\u5f00\u59cb\uff0c\u8fd8\u4f1a\u5f71\u54cd\u8f93\u51fa\u65f6\u7684<code>if</code>\u5224\u65ad\uff0c\u9700\u8981\u5bf9\u5e94\u4fee\u6539\uff1a</li> <li>\u82e5\u4e0b\u6807\u4ece<code>0</code>\u5f00\u59cb\uff0c\u5c31\u662f<code>i &gt;= k - 1</code>\uff0c\u56e0\u4e3a\u7b2c\u4e00\u4e2a\u7a97\u53e3\u4e3a<code>0 1 2</code>\uff1b</li> <li>\u82e5\u4e0b\u6807\u4ece<code>1</code>\u5f00\u59cb\uff0c\u5c31\u662f<code>i &gt;= k</code>\uff0c\u56e0\u4e3a\u9996\u4e2a\u7a97\u53e3\u662f<code>1 2 3</code>\uff1b</li> <li>\u521d\u59cb\u5316\u65f6<code>hh</code>\u548c<code>tt</code>\u4e4b\u95f4\u8981\u95f4\u9694\u4e00\u4e2a\u4f4d\uff0c\u5373<code>hh == tt + 1</code>\u3002</li> </ul> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        int q[100010];\n        vector&lt;int&gt; res;\n        int hh = 0, tt = -1;  // \u6e05\u7a7a\u961f\u5217\n        for (int i = 0; i &lt; nums.size(); i++) {  // \u679a\u4e3e\u6570\u7ec4\n            /*\n            \u4e3a\u4e86\u7ef4\u6301\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\n            \u5f53\u961f\u5217\u4e0d\u4e3a\u7a7a(hh &lt;= tt) \u4e14 \u5f53\u5f53\u524d\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f(i - q[hh] + 1)\u5927\u4e8e\u6211\u4eec\u8bbe\u5b9a\u7684\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f(k)\u65f6\uff0c\u961f\u5217\u5f39\u51fa\u961f\u5217\u5934\u5143\u7d20\u4ee5\u7ef4\u6301\u6ed1\u52a8\u7a97\u53e3\u7684\u5927\u5c0f\n            */\n            // hh &lt;= tt \u4ee3\u8868\u961f\u5217\u4e0d\u7a7a\n            if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;  // \u961f\u5934\u51fa\u961f(\u961f\u5934\u5143\u7d20\u6ed1\u51fa\u7a97\u53e3)\n\n            /*\n            \u6784\u9020\u5355\u8c03\u9012\u589e\u961f\u5217\n            \u5f53\u961f\u5217\u4e0d\u4e3a\u7a7a(hh &lt;= tt) \u4e14 \u5f53\u961f\u5217\u961f\u5c3e\u5143\u7d20\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u5143\u7d20(nums[i])\u65f6\uff0c\u90a3\u4e48\u961f\u5c3e\u5143\u7d20\u5c31\u4e00\u5b9a\u4e0d\u662f\u5f53\u524d\u7a97\u53e3\u6700\u5927\u503c\uff0c\n            \u5c31\u5220\u53bb\u961f\u5c3e\u5143\u7d20\uff0c\u52a0\u5165\u5f53\u524d\u5143\u7d20(q[ ++ tt] = i)\n            */\n            // \u961f\u5c3e\u51fa\u961f(\u961f\u5217\u4e0d\u7a7a\u4e14\u65b0\u5143\u7d20\u66f4\u4f18)\n            while (hh &lt;= tt &amp;&amp; nums[q[tt]] &lt;= nums[i]) tt--;  // \u8fd9\u91cc\u662f\u5355\u8c03\u961f\u5217\u7279\u6709\u7684\u64cd\u4f5c\n            // \u961f\u5c3e\u5165\u961f(\u6ce8\u610f\u961f\u5217\u5b58\u50a8\u7684\u662f\u6570\u7ec4\u4e0b\u6807\uff0c\u65b9\u4fbf\u5224\u65ad\u961f\u5934\u51fa\u961f)\n            q[++tt] = i;\n\n            // \u4f7f\u7528\u6700\u5927\u503c\n            if (i &gt;= k - 1) res.push_back(nums[q[hh]]);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0257-binary-tree-paths/","title":"\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8def\u5f84","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0257-binary-tree-paths/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0257-binary-tree-paths/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    void traversal(TreeNode* curr, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) {\n        path.push_back(curr-&gt;val);\n        if (!curr-&gt;left &amp;&amp; !curr-&gt;right) {\n            string sPath;\n            for (int i = 0; i &lt; path.size() - 1; i++) {\n                sPath += to_string(path[i]);\n                sPath += \"-&gt;\";\n            }\n            sPath += to_string(path[path.size() - 1]);\n            result.push_back(sPath);\n            return;\n        }\n        if (curr-&gt;left) {\n            traversal(curr-&gt;left, path, result);\n            path.pop_back();\n        }\n        if (curr-&gt;right) {\n            traversal(curr-&gt;right, path, result);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        vector&lt;string&gt; res;\n        vector&lt;int&gt; path;\n        if (!root) return res;\n        traversal(root, path, res);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0200-0299/0295-find-median-from-data-stream/","title":"\u6570\u636e\u6d41\u7684\u4e2d\u4f4d\u6570","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0200-0299/0295-find-median-from-data-stream/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0200-0299/0295-find-median-from-data-stream/#_3","title":"\u89e3\u7b54","text":"<pre><code>class MedianFinder {\nprivate:\n    priority_queue&lt;int&gt; small;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large;\npublic:\n    MedianFinder() {\n\n    }\n\n    void addNum(int num) {\n        if (small.size() &gt;= large.size()) {\n            small.push(num);\n            large.push(small.top());\n            small.pop();\n        } else {\n            large.push(num);\n            small.push(large.top());\n            large.pop();\n        }\n    }\n\n    double findMedian() {\n        if (large.size() &lt; small.size()) return small.top();\n        else if (large.size() &gt; small.size()) return large.top();\n\n        return (large.top() + small.top()) / 2.0;\n    }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj-&gt;addNum(num);\n * double param_2 = obj-&gt;findMedian();\n */\n</code></pre>"},{"location":"zh/Leetcode/0300-0399/0322-coin-change/","title":"\u96f6\u94b1\u5151\u6362","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0300-0399/0322-coin-change/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0300-0399/0322-coin-change/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {\n        vector&lt;int&gt; dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i &lt; coins.size(); i++) {\n            for (int j = coins[i]; j &lt;= amount; j++) {\n                if (dp[j - coins[i]] != INT_MAX) \n                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);\n            }\n        }\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0300-0399/0343-integer-break/","title":"\u6574\u6570\u62c6\u5206","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0300-0399/0343-integer-break/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0300-0399/0343-integer-break/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int integerBreak(int n) {\n        vector&lt;int&gt; dp(n + 1);\n        dp[2] = 1;\n        for (int i = 3; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= i / 2; j++)\n                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n        }\n        return dp[n];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0300-0399/0347-top-k-frequent-elements/","title":"\u524dK\u4e2a\u9ad8\u9891\u5143\u7d20","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0300-0399/0347-top-k-frequent-elements/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0300-0399/0347-top-k-frequent-elements/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; hashing;\n        for (auto elm : nums) hashing[elm]++;\n        int n = nums.size();\n        vector&lt;int&gt; count(n + 1, 0);\n        for (auto &amp;p : hashing) count[p.second]++;\n        int i = n, t = 0;\n        while (t &lt; k) t += count[i--];\n        vector&lt;int&gt; res;\n        for (auto &amp;p : hashing) {\n            if (p.second &gt; i) res.push_back(p.first);\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0300-0399/0377-combination-sum-iv/","title":"\u7ec4\u5408\u603b\u548c \u2163","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0300-0399/0377-combination-sum-iv/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0300-0399/0377-combination-sum-iv/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; dp(target + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i &lt;= target; i++) {\n            for (int j = 0; j &lt; nums.size(); j++) {\n                if (i &gt;= nums[j] &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) \n                    dp[i] += dp[i - nums[j]];\n            }\n        }\n        return dp[target];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0404-sum-of-left-leaves/","title":"\u5de6\u53f6\u5b50\u4e4b\u548c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0404-sum-of-left-leaves/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0404-sum-of-left-leaves/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        if (!root) return 0;\n        int leftVal = 0;\n        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)\n            leftVal = root-&gt;left-&gt;val;\n        return leftVal + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0416-partition-equal-subset-sum/","title":"\u5206\u5272\u7b49\u548c\u5b50\u96c6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0416-partition-equal-subset-sum/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0416-partition-equal-subset-sum/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n        vector&lt;int&gt; dp(10001, 0);\n        for (int i = 0; i &lt; nums.size(); i++) sum += nums[i];\n        if (sum % 2 == 1) return false;\n        int target = sum / 2;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = target; j &gt;= nums[i]; j--) {\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n        if (dp[target] == target) return true;\n        return false;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0459-repeated-substring-pattern/","title":"\u91cd\u590d\u7684\u5b50\u5b57\u7b26\u4e32","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0459-repeated-substring-pattern/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0459-repeated-substring-pattern/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string t = s + s;\n        t.erase(t.begin()); t.erase(t.end() - 1);\n        if (t.find(s) != string::npos) return true;\n        return false;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0474-ones-and-zeroes/","title":"\u4e00\u548c\u96f6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0474-ones-and-zeroes/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0474-ones-and-zeroes/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n\n        for (string str : strs) {\n            int one = 0, zero = 0;\n            for (char c : str) {\n                (c == '0') ? zero++ : one++;\n            }\n            for (int i = m; i &gt;= zero; i--) {\n                for (int j = n; j &gt;= one; j--) {\n                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0491-non-decreasing-subsequences/","title":"\u9012\u589e\u5b50\u5e8f\u5217","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0491-non-decreasing-subsequences/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0491-non-decreasing-subsequences/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;int&gt; path;\n    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex) {\n        if (path.size() &gt; 1) res.push_back(path);\n\n        unordered_set&lt;int&gt; used;\n        for (int i = startIndex; i &lt; nums.size(); i++) {\n            if (used.find(nums[i]) != used.end()) continue;\n            if (!path.empty() &amp;&amp; nums[i] &lt; path.back()) continue;\n\n            used.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) {\n        backtracking(nums, 0);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0494-target-sum/","title":"\u76ee\u6807\u548c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0494-target-sum/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0494-target-sum/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {\n        int sum = 0;\n        for (auto x : nums) sum += x;\n        if (abs(target) &gt; sum) return 0;\n        if ((sum + target) % 2) return 0;\n        int m = (sum + target) / 2;\n        vector&lt;int&gt; dp(m + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            for (int j = m; j &gt;= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[m];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0400-0499/0496-next-greater-element-i/","title":"\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20 I","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0400-0499/0496-next-greater-element-i/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0400-0499/0496-next-greater-element-i/#_2","title":"\u89e3\u7b54","text":"<p>\u5173\u4e8e\u5355\u8c03\u6808\u7684\u8bb2\u89e3\uff0c\u6b64\u7bc7\u535a\u6587\u53ef\u4f9b\u53c2\u9605\u3002</p> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; res(nums1.size(), -1);\n\n        unordered_map&lt;int, int&gt; mapping;\n        for (int i = 0; i &lt; nums1.size(); i++) mapping[nums1[i]] = i;\n        stk.push(0);\n\n        for (int i = 1; i &lt; nums2.size(); i++) {\n            while (!stk.empty() &amp;&amp; nums2[i] &gt; nums2[stk.top()]) {\n                if (mapping.count(nums2[stk.top()])) {\n                    int index = mapping[nums2[stk.top()]];\n                    res[index] = nums2[i];\n                }\n                stk.pop();\n            }\n            stk.push(i);\n        }\n\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/","title":"\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6700\u5c0f\u7edd\u5bf9\u5dee","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0500-0599/0500-minimum-absolute-difference-in-bst/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* pre;\n    int res = INT_MAX;\n    void traversal(TreeNode* root) {\n        if (!root) return;\n        traversal(root-&gt;left);\n        if (pre) res = min(res, root-&gt;val - pre-&gt;val);\n        pre = root;\n        traversal(root-&gt;right);\n    }\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        traversal(root);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0500-0599/0503-next-greater-element-ii/","title":"\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0500-0599/0503-next-greater-element-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0500-0599/0503-next-greater-element-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; res(nums.size(), -1);\n        stack&lt;int&gt; stk;\n        for (int i = 0; i &lt; nums.size() * 2; i++) {\n            while (!stk.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[stk.top()]) {\n                res[stk.top()] = nums[i % nums.size()];\n                stk.pop();\n            }\n            stk.push(i % nums.size());\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0500-0599/0509-fibonacci-number/","title":"\u6590\u6ce2\u90a3\u5951\u6570","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0500-0599/0509-fibonacci-number/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0500-0599/0509-fibonacci-number/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int fib(int n) {\n        if (n &lt;= 1) return n;\n        int dp[2];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            int sum = dp[0] + dp[1];\n            dp[0] = dp[1];\n            dp[1] = sum;\n        }\n        return dp[1];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0500-0599/0513-find-bottom-left-tree-value/","title":"\u627e\u6811\u5de6\u4e0b\u89d2\u7684\u503c","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0500-0599/0513-find-bottom-left-tree-value/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0500-0599/0513-find-bottom-left-tree-value/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int res = 0;\n    int maxDepth = 0;\n    void traversal(TreeNode* root, int depth) {\n        if (!root) return;\n        if (depth &gt; maxDepth) {\n            maxDepth = depth;\n            res = root-&gt;val;\n        }\n        traversal(root-&gt;left, depth + 1);\n        traversal(root-&gt;right, depth + 1);\n    }\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        traversal(root, 1);\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0500-0599/0518-coin-change-ii/","title":"\u96f6\u94b1\u5151\u6362II","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0500-0599/0518-coin-change-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0500-0599/0518-coin-change-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int change(int amount, vector&lt;int&gt;&amp; coins) {\n        int n = coins.size();\n        vector&lt;int&gt; dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = coins[i - 1]; j &lt;= amount; j++) {\n                dp[j] = dp[j] + dp[j - coins[i - 1]];\n            }\n        }\n        return dp[amount];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0600-0699/0617-merge-two-binary-trees/","title":"\u5408\u5e76\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0600-0699/0617-merge-two-binary-trees/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0600-0699/0617-merge-two-binary-trees/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1) return root2;\n        if (!root2) return root1;\n        root1-&gt;val += root2-&gt;val;\n        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);\n        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);\n        return root1;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0600-0699/0654-maximum-binary-tree/","title":"\u6700\u5927\u4e8c\u53c9\u6811","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0600-0699/0654-maximum-binary-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0600-0699/0654-maximum-binary-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* traversal(vector&lt;int&gt; &amp;nums, int left, int right) {\n        if (left &gt;= right) return nullptr;\n\n        // int maxIndex = left;\n        // for (int i = left + 1; i &lt; right; i++) {\n        //     if (nums[i] &gt; nums[maxIndex]) maxIndex = i;\n        // }\n        int maxIndex = distance(nums.begin(), max_element(nums.begin() + left, nums.begin() + right));\n\n        TreeNode *root = new TreeNode(nums[maxIndex]);\n\n        root-&gt;left = traversal(nums, left, maxIndex);\n        root-&gt;right = traversal(nums, maxIndex + 1, right);\n\n        return root;\n    }\npublic:\n    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {\n        return traversal(nums, 0, nums.size());\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0700-0799/0700-search-in-a-binary-search-tree/","title":"\u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u7684\u641c\u7d22","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0700-0799/0700-search-in-a-binary-search-tree/#_3","title":"\u89e3\u7b54","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root || root-&gt;val == val) return root;\n        if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);\n        if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val);\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/","title":"\u6570\u636e\u6d41\u4e2d\u7684\u7b2c K \u5927\u5143\u7d20","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0700-0799/0703-kth-largest-element-in-a-stream/#_2","title":"\u89e3\u7b54","text":"<pre><code>class KthLargest {\nprivate:\n    int _k;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\npublic:\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) {\n        for (int num : nums) {\n            q.push(num);\n            if (q.size() &gt; k) q.pop();\n        }\n        this-&gt;_k = k;\n    }\n\n    int add(int val) {\n       q.push(val);\n       if (q.size() &gt; _k) q.pop();\n       return q.top(); \n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-&gt;add(val);\n */\n</code></pre>"},{"location":"zh/Leetcode/0700-0799/0720-longest-word-in-dictionary/","title":"\u8bcd\u5178\u4e2d\u6700\u957f\u7684\u5355\u8bcd","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0700-0799/0720-longest-word-in-dictionary/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0700-0799/0720-longest-word-in-dictionary/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; son;\n    vector&lt;int&gt; cnt;\n    int idx;\n    void insert(string&amp; word) {\n        int p = 0;\n        for (char s : word) {\n            int u = s - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n        }\n        cnt[p]++;\n    }\n    int query(string&amp; word) {\n        int p = 0;\n        for (char s : word) {\n            int u = s - 'a';\n            p = son[p][u];\n            if (!p || cnt[p] == 0) return 0;\n        }\n        return cnt[p];\n    }\npublic:\n    string longestWord(vector&lt;string&gt;&amp; words) {\n        son = vector&lt;vector&lt;int&gt;&gt;(30010, vector&lt;int&gt;(26, 0));\n        cnt = vector&lt;int&gt;(30010, 0);\n        idx = 0;\n        set&lt;string&gt; ans;\n        for (string word : words) insert(word);\n        for (string word : words) {\n            if (query(word) &gt; 0) ans.insert(word);\n        }\n\n        string longest = \"\";\n        for (string word : ans) {\n            if (word.length() &gt; longest.length() || ((word.length() == longest.length() &amp;&amp; word &lt; longest)))\n            longest = word;\n        }\n\n        return longest;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0700-0799/0739-daily-temperatures/","title":"\u6bcf\u65e5\u6e29\u5ea6","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0700-0799/0739-daily-temperatures/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0700-0799/0739-daily-temperatures/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; res(temperatures.size(), 0);\n\n        for (int i = 0; i &lt; temperatures.size(); i++) {\n            while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()]) {\n                res[stk.top()] = i - stk.top();\n                stk.pop();\n            }\n            stk.push(i);\n        }\n\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0700-0799/0746-min-cost-climbing-stairs/","title":"\u4f7f\u7528\u6700\u5c0f\u82b1\u8d39\u722c\u697c\u68af","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0700-0799/0746-min-cost-climbing-stairs/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0700-0799/0746-min-cost-climbing-stairs/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int dp[1010];\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i &lt;= cost.size(); i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[cost.size()];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/0900-0999/0912-sort-an-array/","title":"\u6392\u5e8f\u6570\u7ec4","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/0900-0999/0912-sort-an-array/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/0900-0999/0912-sort-an-array/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\nprivate:\n    vector&lt;int&gt; tmp;\n    void merge_sort(vector&lt;int&gt;&amp; nums, int l, int r) {\n        if (l &gt;= r) return;\n        int mid = (l + r) &gt;&gt; 1;\n        merge_sort(nums, l, mid); merge_sort(nums, mid + 1, r);\n        int k = 0, i = l, j = mid + 1;\n        while (i &lt;= mid &amp;&amp; j &lt;= r) {\n            if (nums[i] &lt;= nums[j]) tmp[k++] = nums[i++];\n            else tmp[k++] = nums[j++];\n        }\n        while (i &lt;= mid) tmp[k++] = nums[i++];\n        while (j &lt;= r) tmp[k++] = nums[j++];\n        for (i = l, j = 0; i &lt;= r; i++, j++) nums[i] = tmp[j];\n    }\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        tmp = vector&lt;int&gt;(nums.size(), 0);\n        merge_sort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/","title":"\u5220\u9664\u5b57\u7b26\u4e32\u4e2d\u7684\u6240\u6709\u76f8\u90bb\u91cd\u590d\u9879","text":"<p>Leetcode\u94fe\u63a5</p>"},{"location":"zh/Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#_2","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/1000-1099/1047-remove-all-adjacent-duplicates-in-string/#_3","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    string removeDuplicates(string s) {\n        string res;\n        for (auto &amp;ch : s) {\n            if (res.empty() || res.back() != ch) res.push_back(ch);\n            else res.pop_back();\n        }\n        return res;\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/1000-1099/1049-last-stone-weight-ii/","title":"\u6700\u540e\u4e00\u5757\u77f3\u5934\u7684\u91cd\u91cfII","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/1000-1099/1049-last-stone-weight-ii/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u94fe\u63a5\u3002</p>"},{"location":"zh/Leetcode/1000-1099/1049-last-stone-weight-ii/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) {\n        int sum = 0;\n        for (int x : stones) sum += x;\n        vector&lt;int&gt; dp(sum + 1, 0);\n        for (int i = 0; i &lt; stones.size(); i++) {\n            for (int j = sum / 2; j &gt;= stones[i]; j--)\n                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n        }\n        return sum - 2 * dp[sum / 2];\n    }\n};\n</code></pre>"},{"location":"zh/Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/","title":"\u6570\u7ec4\u5f02\u6216\u548c\u7b49\u4e8e K \u7684\u6700\u5c11\u64cd\u4f5c\u6b21\u6570","text":"<p>Leetcode\u9898\u76ee\u94fe\u63a5</p>"},{"location":"zh/Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#_1","title":"\u63cf\u8ff0","text":"<p>\u8be6\u89c1\u4e2d\u6587\u9898\u76ee\u8fde\u63a5\u3002</p>"},{"location":"zh/Leetcode/10000-10100/10032-minimum-number-of-operations-to-make-array-xor-equal-to-k/#_2","title":"\u89e3\u7b54","text":"<pre><code>class Solution {\npublic:\n    int minOperations(vector&lt;int&gt;&amp; nums, int k) {\n        vector&lt;int&gt; oneCnt(32, 0);\n        for (int num : nums) {\n            for (int i = 0; i &lt; 32; i++) {\n                if (num &amp; (1 &lt;&lt; i)) oneCnt[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i &lt; 32; i++) {\n            if (k &amp; (1 &lt;&lt; i)) {  //if ith bit in k = 1\n                if (!(oneCnt[i] % 2)) ans++;\n            } else {\n                if (oneCnt[i] % 2) ans++;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>"},{"location":"zh/Math/","title":"\u6570\u5b66\u77e5\u8bc6","text":""},{"location":"zh/Math/01_Prime_Numbers/","title":"\u8d28\u6570","text":"<p>\u8d28\u6570\uff1a\u8d28\u6570\u662f\u9488\u5bf9\u5927\u4e8e1\u7684\u81ea\u7136\u6570\u6765\u5b9a\u4e49\u7684\uff0c\u5982\u679c\u8be5\u81ea\u7136\u6570\u53ea\u5305\u542b1\u548c\u672c\u8eab\u7684\u8fd9\u4e24\u4e2a\u7ea6\u6570\uff0c\u5c31\u88ab\u79f0\u4e3a\u8d28\u6570(\u7d20\u6570)\u3002</p>"},{"location":"zh/Math/01_Prime_Numbers/#_2","title":"\u8d28\u6570\u7684\u5224\u5b9a","text":"<p>\u4f8b\u9898\uff1a\u8bd5\u9664\u6cd5\u5224\u5b9a\u8d28\u6570</p> <p>\u8d28\u6570\u7684\u5224\u5b9a\uff1a\u8bd5\u9664\u6cd5\uff0c\u66b4\u529b\u505a\u6cd5(\u5373\u679a\u4e3e\u5230 \\(n\\) )\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)</p> <p>\u6027\u8d28\uff1a\u82e5 \\(\\left. d \\right|n\\)\uff0c\u5219 \\(\\left. \\frac{n}{d} \\right|n\\)</p> <p>\u5728\u679a\u4e3e\u65f6\uff0c\u53ea\u7528\u679a\u4e3e \\(d\\leqslant \\frac{n}{d}\\Longleftrightarrow d\\leqslant \\sqrt{n}\\) \u7684\u6570\uff0c\u53ef\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230 \\(O(\\sqrt{n})\\) (\u8fd9\u91cc\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5fc5\u4e3a \\(O(\\sqrt{n})\\) )\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>bool is_prime(int x) {\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n</code></pre>"},{"location":"zh/Math/01_Prime_Numbers/#_3","title":"\u5206\u89e3\u8d28\u56e0\u6570","text":"<p>\u4f8b\u9898\uff1a\u5206\u89e3\u8d28\u56e0\u6570</p> <p>\u5206\u89e3\u8d28\u56e0\u6570\uff1a\u8bd5\u9664\u6cd5\uff0c\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u6240\u6709\u7684\u6570\u4ee5\u5c1d\u8bd5\u56e0\u5b50\uff0c\u66b4\u529b\u505a\u6cd5(\u5373\u679a\u4e3e\u5230 \\(n\\) )\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)</p> <p>\u5f53\u679a\u4e3e\u5230\u6ee1\u8db3<code>n % i == 0</code>\u7684 \\(i\\) \u65f6\uff0c\u5b9e\u9645\u4e0a\u6240\u6709\u4ece2\u5230 \\(i-1\\) \u7684\u6240\u6709\u8d28\u56e0\u5b50\u5df2\u7ecf\u88ab\u9664\u5e72\u51c0\u4e86\uff0c\u4e5f\u5c31\u662f \\(n\\) \u5df2\u7ecf\u4e0d\u5305\u542b\u4ece2\u5230 \\(i-1\\) \u7684\u8d28\u56e0\u5b50\uff1b\u56e0\u4e3a \\(n\\) \u662f \\(i\\) \u7684\u500d\u6570\uff0c\u8bf4\u660e \\(i\\) \u4e5f\u4e0d\u5305\u542b\u4ece2\u5230 \\(i-1\\) \u7684\u8d28\u56e0\u5b50\uff0c\u56e0\u6b64 \\(i\\) \u4e00\u5b9a\u662f\u8d28\u6570</p> <p>\u6027\u8d28\uff1a\u4e0d\u8d85\u8fc7 \\(n\\) \u7684\u81ea\u7136\u6570\u4e2d\u6700\u591a\u53ea\u5305\u542b\u4e00\u4e2a\u5927\u4e8e \\(\\sqrt{n}\\) \u7684\u8d28\u56e0\u5b50\u3002</p> <p>\u5728\u679a\u4e3e\u65f6\uff0c\u53ef\u4ee5\u53ea\u679a\u4e3e\u5230 \\(\\sqrt{n}\\)\uff0c\u7136\u540e\u5355\u72ec\u5904\u7406\u5927\u4e8e \\(\\sqrt{n}\\) \u7684\u8d28\u56e0\u5b50\uff0c\u53ef\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230 \\(O(\\sqrt{n})\\) (\u8fd9\u91cc\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u4e00\u5b9a\u4e3a \\(O(\\sqrt{n})\\)\uff0c\u6700\u597d\u53ef\u4ee5\u8fbe\u5230 \\(O(\\log n)\\) \uff0c\u8fd9\u65f6 \\(n=2^k\\) )\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>void divide(int x) {\n    for (int i = 2; i &lt; = x / i; i++) {\n        if (x % i == 0) {\n            int s = 0;\n            while (x % i == 0) x /= i, s++;\n            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;\n        }\n    }\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"zh/Math/01_Prime_Numbers/#_4","title":"\u8d28\u6570\u7b5b\u9009","text":"<p>\u4f8b\u9898\uff1a\u7b5b\u8d28\u6570</p> <p>\u66b4\u529b\u505a\u6cd5\u7684\u601d\u60f3\u662f\u4ece2\u5230 \\(n\\) \u770b\u6bcf\u4e00\u4e2a\u6570\uff0c\u628a2\u7684\u6240\u6709\u500d\u6570\u7b5b\u6389\uff0c\u518d\u628a3\u7684\u6240\u6709\u500d\u6570\u7b5b\u6389\uff0c\u518d\u628a5\u7684\u6240\u6709\u500d\u6570\u7b5b\u6389\uff0c...\uff0c\u8fd9\u6837\u5269\u4f59\u7684\u6240\u6709\u6570\u90fd\u662f\u8d28\u6570\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O\\left( \\frac{n}{2}+\\frac{n}{3}+\\cdots +\\frac{n}{n} \\right) \\approx O\\left( n\\ln n \\right) \\approx O\\left( n\\log n \\right)\\)</p> <p>\u57c3\u6c0f\u7b5b\u6cd5(Sieve of Eratosthenes)\uff1a</p> <p>\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u6bcf\u4e2a\u6570\uff1a</p> <ul> <li>\u5982\u679c\u5f53\u524d\u6570\u6ca1\u88ab\u5212\u6389\uff0c\u5219\u5fc5\u5b9a\u662f\u8d28\u6570\uff0c\u8bb0\u5f55\u8be5\u8d28\u6570</li> <li>\u679a\u4e3e\u5f53\u524d\u8d28\u6570\u7684\u500d\u6570\uff0c\u5fc5\u5b9a\u662f\u5408\u6570\uff0c\u5212\u6389\u5408\u6570</li> </ul> <p>\u6027\u8d28(Prime Number Theorem)\uff1a\u4ece1\u5230 \\(n\\) \u4e2d\u6709\u7ea6 \\(\\frac{n}{\\ln n}\\) \u4e2a\u8d28\u6570\u3002</p> <p>\u91c7\u7528\u57c3\u6c0f\u7b5b\u6cd5\u4f18\u5316\u540e\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u7ea6\u4e3a \\(O(n)\\)\uff0c\u771f\u5b9e\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n\\log \\log n)\\)\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5408\u6570\u53ef\u80fd\u88ab\u7b5b\u6389\u4e0d\u6b62\u4e00\u6b21</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>typedef long long LL;\nconst int N = 100000010;\nint primes[N], cnt;  //primes[]\u5b58\u50a8\u6240\u6709\u8d28\u6570\uff0ccnt\u5b58\u50a8\u8d28\u6570\u4e2a\u6570\nbool st[N];  //st[x]\u5b58\u50a8x\u662f\u5426\u88ab\u7b5b\u6389\n\nvoid get_primes(int n) {\n    for (LL i = 2; i &lt;= n; i++) {\n        if (st[i]) continue;\n        primes[++cnt] = i;\n        for (LL j = i * i; j &lt;= n; j += i)\n            st[j] = true;\n    }\n}\n</code></pre> <p>\u7ebf\u6027\u7b5b\u6cd5\uff1a</p> <p>\u91c7\u7528\u7ebf\u6027\u7b5b\u6cd5\u8fdb\u884c\u4f18\u5316\uff0c\u8fd9\u91cc \\(n\\) \u53ea\u4f1a\u88ab\u5b83\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7b5b\u6389\uff1a</p> <ul> <li>\u82e5<code>i % primes[j] == 0</code>\uff1a\u5219<code>primes[j]</code>\u4e00\u5b9a\u662f<code>i</code>\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c<code>primes[j]</code>\u4e5f\u4e00\u5b9a\u662f<code>primes[j] * i</code>\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff1b</li> <li>\u82e5<code>i % primes[j] != 0</code>\uff1a\u56e0\u4e3a\u6211\u4eec\u662f\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u6240\u6709\u7684\u8d28\u6570\u4e14\u6ca1\u6709\u679a\u4e3e\u5230<code>i</code>\u7684\u8d28\u56e0\u5b50\uff0c\u5219<code>primes[j]</code>\u5fc5\u5b9a\u5c0f\u4e8e<code>i</code>\u7684\u6240\u6709\u8d28\u56e0\u5b50\uff0c<code>primes[j]</code>\u4e5f\u4e00\u5b9a\u662f<code>primes[j] * i</code>\u7684\u6700\u5c0f\u8d28\u56e0\u5b50</li> </ul> <p>\u5bf9\u4e8e\u4e00\u4e2a\u5408\u6570<code>x</code>\uff0c\u5047\u8bbe<code>primes[j]</code>\u4e3a<code>x</code>\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u5f53<code>i</code>\u679a\u4e3e\u5230<code>x / primes[j]</code>\u65f6\uff0c\u5c31\u53ef\u4ee5\u7b5b\u6389</p> <p>\u7ebf\u6027\u7b5b\u6cd5(\u53c8\u540d\u6b27\u62c9\u7b5b\u6cd5)\u7684\u6b65\u9aa4\u4e3a\uff1a</p> <p>\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u6bcf\u4e00\u4e2a\u6570\uff1a</p> <ul> <li>\u5982\u679c\u5f53\u524d\u6570\u6ca1\u6709\u88ab\u5212\u6389\uff0c\u5219\u5fc5\u5b9a\u662f\u8d28\u6570\uff0c\u8bb0\u5f55\u8be5\u8d28\u6570</li> <li>\u679a\u4e3e\u5df2\u8bb0\u5f55\u7684\u8d28\u6570(\u5982\u679c\u5408\u6570\u5df2\u8d8a\u754c\u5219\u4e2d\u65ad)</li> <li>\u5408\u6570\u672a\u8d8a\u754c\uff0c\u5219\u5212\u6389\u5408\u6570</li> <li>\u6761\u4ef6<code>i % p == 0</code>\uff0c\u4fdd\u8bc1\u5408\u6570\u53ea\u88ab\u6700\u5c0f\u8d28\u56e0\u5b50\u5212\u6389<ul> <li>\u82e5<code>i</code>\u662f\u8d28\u6570\uff0c\u5219\u6700\u591a\u679a\u4e3e\u5230\u81ea\u8eab\u4e2d\u65ad</li> <li>\u82e5<code>i</code>\u662f\u5408\u6570\uff0c\u5219\u6700\u591a\u679a\u4e3e\u5230\u81ea\u8eab\u7684\u6700\u5c0f\u8d28\u6570\u4e2d\u65ad</li> </ul> </li> </ul> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int primes[N], cnt;  //primes[i]\u5b58\u50a8\u5230i\u4e3a\u6b62\u7684\u6240\u6709\u7d20\u6570\nbool st[N];  //st[x]\u5b58\u50a8x\u662f\u5426\u88ab\u7b5b\u6389\n\nvoid get_primes(int n) {\n    for (int i = 2; i &lt;= n; i++) {\n        if (!st[i]) primes[++cnt] = i;\n        //\u4ee5\u4e0b\u8303\u56f4\u5224\u65ad\u4e5f\u53ef\u5199 1LL * i * primes[j] &lt;= n; (LL\u4e3along long)\n        for (int j = 1; primes[j] &lt;= n / i; j++) {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n</code></pre> <p>\u7ebf\u6027\u7b5b\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)</p>"},{"location":"zh/Math/02_Divisor/","title":"\u7ea6\u6570","text":""},{"location":"zh/Math/02_Divisor/#_2","title":"\u8bd5\u9664\u6cd5\u6c42\u7ea6\u6570","text":"<p>\u4f8b\u9898\uff1a\u8bd5\u9664\u6cd5\u6c42\u7ea6\u6570</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\sqrt{n})\\)</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>vector&lt;int&gt; get_divisors(int x) {\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i++) {\n        if (x % i == 0) {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n</code></pre>"},{"location":"zh/Math/02_Divisor/#_3","title":"\u7ea6\u6570\u4e2a\u6570\u4e0e\u7ea6\u6570\u548c","text":"<p>\u7b97\u672f\u57fa\u672c\u5b9a\u7406\uff1a\u5bf9\u4e8e \\(\\forall A\\in \\mathbb{N} , A&gt;1\\) \uff0c\u90fd</p> \\[ \\exists \\prod_{i=1}^n{{p_i}^{\\alpha _i}}=A \\] <p>\u5176\u4e2d \\(p_1 &lt; p_2 &lt; \\cdots &lt; p_n\\) \uff0c\u4e14 \\(p_i\\) \u4e3a\u8d28\u6570\uff0c \\({\\alpha}_i\\in \\mathbb{Z} ^+\\)\u3002\u8fd9\u79cd\u8868\u793a\u65b9\u6cd5\u5b58\u5728\u4e14\u552f\u4e00\u3002</p> <p>\u4f8b\u9898\uff1a\u7ea6\u6570\u4e2a\u6570</p> <p>\u7ed3\u8bba\uff1a\u5bf9\u4e8e\u6b63\u6574\u6570 \\(A\\)\uff0c\u5176\u6b63\u7ea6\u6570\u4e2a\u6570\u4e3a\uff1a</p> \\[ \\prod_{i=1}^n{\\left( \\alpha _i+1 \\right)} \\] <p>\u6ce8\uff1a<code>int</code>\u8303\u56f4\u5185\u7684\u6570 \\(A\\leqslant 2^{31}-1\\)\uff0c\u5176\u7ea6\u6570\u4e2a\u6570\u6700\u591a\u4e3a \\(1536\\)\uff0c\u4f8b\u5982 \\(1745944200=2^3\\times 3^3\\times 5^2\\times 7\\times 11\\times 13\\times 17\\times 19\\)\uff0c \\(2113511400=2^3\\times 3^3\\times 5^2\\times 7\\times 11\\times 13\\times 17\\times 23\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u7ea6\u6570\u4e4b\u548c</p> <p>\u7ed3\u8bba\uff1a\u6b63\u6574\u6570 \\(A\\) \u7684\u6b63\u7ea6\u6570\u548c\u4e3a\uff1a</p> \\[ \\left( {p_1}^0+{p_1}^1+{p_1}^2+\\cdots +{p_1}^{\\alpha _1} \\right) \\cdot \\left( {p_2}^0+{p_2}^1+{p_2}^2+\\cdots +{p_2}^{\\alpha _2} \\right) \\cdots \\left( {p_n}^0+{p_n}^1+{p_n}^2+\\cdots +{p_n}^{\\alpha _n} \\right)  \\] \\[ =\\prod_{i=1}^n{\\left( \\sum_{j=0}^{\\alpha _i}{{p_i}^j} \\right)} \\] <p>\u6280\u5de7\uff1a\u5982\u4f55\u6c42 \\(S\\left( n \\right) =1+x+x^2+\\cdots +x^n\\) \uff1f\u4e8b\u5b9e\u4e0a\uff0c\u7531\u4e8e \\(S\\left( n \\right) =1+x\\cdot \\left( 1+x+\\cdots +x^{n-1} \\right) =1+S\\left( n-1 \\right) \\cdot x\\)\uff0c\u8fb9\u754c\u4e3a \\(S(0)=1\\)\u3002\u6240\u4ee5\u53ef\u4ee5\u4ee4 \\(t=1\\)\uff0c\u4e58\u4ee5 \\(x\\) \u518d\u52a0\u4e0a1\u5f97\u5230 \\(S(1)\\)\uff0c\u518d\u4e58\u4ee5 \\(x\\) \u5e76\u52a0\u4e0a1\u5f97\u5230 \\(S(2)\\)\uff0c\u6267\u884cn\u6b21\u5faa\u73af\u5f97\u5230 \\(S(n)\\)</p> <p>\u901f\u8bb0\uff1a</p> <pre><code>\u5982\u679c N = p1^c1 * p2^c2 * ... *pk^ck\n\u7ea6\u6570\u4e2a\u6570\uff1a (c1 + 1) * (c2 + 1) * ... * (ck + 1)\n\u7ea6\u6570\u4e4b\u548c\uff1a (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\n</code></pre>"},{"location":"zh/Math/02_Divisor/#_4","title":"\u6700\u5927\u516c\u7ea6\u6570","text":"<p>\u4f8b\u9898\uff1a\u6700\u5927\u516c\u7ea6\u6570</p> <p>\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5(\u8f97\u8f6c\u76f8\u9664\u6cd5)\uff1a\u4e24\u4e2a\u6574\u6570\u7684\u6700\u5927\u516c\u7ea6\u6570\u7b49\u4e8e\u5176\u4e2d\u8f83\u5c0f\u7684\u6570\u548c\u4e24\u6570\u76f8\u9664\u4f59\u6570\u7684\u6700\u5927\u516c\u7ea6\u6570\uff0c\u5373 \\(\\mathrm{gcd}\\left( a, b \\right) =\\mathrm{gcd}\\left( b, a\\left( \\mathrm{mod} b \\right) \\right)\\)</p> <p>\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log n)\\)</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n</code></pre>"},{"location":"zh/Math/03_Euler_Function/","title":"\u6b27\u62c9\u51fd\u6570","text":"<p>\u6b27\u62c9\u51fd\u6570\u7684\u5b9a\u4e49\uff1a \\(1\\sim A\\) \u4e2d\u4e0e\u6b63\u6574\u6570 \\(A\\) \u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\u88ab\u79f0\u4e3a\u6b27\u62c9\u51fd\u6570\uff0c\u8bb0\u4e3a \\(\\varphi \\left( A \\right)\\)\u3002</p>"},{"location":"zh/Math/03_Euler_Function/#_2","title":"\u6b27\u62c9\u51fd\u6570\u7684\u57fa\u672c\u516c\u5f0f","text":"<p>\u4f8b\u9898\uff1a\u6b27\u62c9\u51fd\u6570</p> <p>\u7ed3\u8bba\uff1a\u82e5\u5728\u7b97\u672f\u57fa\u672c\u5b9a\u7406\u4e2d\uff0c\u6709 \\(A\\) \u5206\u89e3\u8d28\u56e0\u6570\u540e\u7684\u7ed3\u679c\u4e3a \\(A={p_1}^{\\alpha _1}\\cdot {p_2}^{\\alpha _2}\\cdots {p_n}^{\\alpha _n}\\)\uff0c\u5219\uff1a</p> \\[ \\varphi \\left( A \\right) =A\\times \\frac{p_1-1}{p_1}\\times \\frac{p_2-1}{p_2}\\times \\cdots \\times \\frac{p_n-1}{p_n} \\] <p>\u5373\uff1a</p> \\[ \\varphi \\left( A \\right) =A\\left( 1-\\frac{1}{p_1} \\right) \\cdot \\left( 1-\\frac{1}{p_2} \\right) \\cdots \\left( 1-\\frac{1}{p_n} \\right)  \\] <p>\u8bc1\u660e\uff1a\u8981\u6c42 \\(1\\sim A\\) \u4e2d\u548c \\(A\\) \u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\uff0c\u9700\u8981\u8fdb\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ol> <li>\u4ece \\(1\\sim A\\) \u4e2d\u53bb\u6389 \\(p_1,p_2,\\cdots ,p_k\\) \u7684\u6240\u6709\u500d\u6570\uff0c\u4e5f\u5c31\u662f \\(A-\\frac{A}{p_1}-\\frac{A}{p_2}-\\cdots -\\frac{A}{p_n}\\)</li> <li>\u6839\u636e\u5bb9\u65a5\u539f\u7406\uff0c\u8fd8\u9700\u8981\u52a0\u4e0a\u6240\u6709 \\(p_i\\cdot p_j\\) \u7684\u500d\u6570\uff0c\u4e5f\u5c31\u662f \\(A-\\sum_{i=1}^n{p_i}+\\sum_{1\\leqslant i &lt; j\\leqslant n}{p_i\\cdot p_j}\\)</li> <li>\u6839\u636e\u5bb9\u65a5\u539f\u7406\uff0c\u8fd8\u9700\u8981\u51cf\u53bb\u6240\u6709 \\(p_i\\cdot p_j\\cdot p_k\\) \u7684\u500d\u6570\uff0c\u4e5f\u5c31\u662f \\(A-\\sum_{i=1}^n{p_i}+\\sum_{1\\leqslant i &lt; j\\leqslant n}{p_i\\cdot p_j}-\\sum_{1\\leqslant i &lt; j &lt; k\\leqslant n}{p_i\\cdot p_j\\cdot p_k}\\)</li> <li>\u4ee5\u6b64\u7c7b\u63a8......</li> <li>\u6700\u7ec8\u5f97\u5230\u7684\u5f0f\u5b50\u5373\u4e3a\u539f\u516c\u5f0f</li> </ol> <p>\u53ef\u89c1\u6b27\u62c9\u51fd\u6570\u4ec5\u7531 \\(A\\) \u548c\u5176\u8d28\u56e0\u5b50\u51b3\u5b9a\uff0c\u4e0e\u6b21\u6570\u65e0\u5173\u3002</p> <p>\u4f7f\u7528\u516c\u5f0f\u6c42\u6b27\u62c9\u51fd\u6570\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\sqrt{n})\\)</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int phi(int x) {\n    int res = x;\n    for (int i = 2; i &lt;= x / i; i++) {\n        if (x % i == 0) {\n            res = res / i * (i - 1);\n            while (x % i == 0) x /= i;\n        }\n    }\n\n    if (x &gt; 1) res = res / x * (x - 1);\n\n    return res;\n}\n</code></pre> <p>\u7ed3\u8bba\uff1a\u82e5 \\(p\\) \u4e3a\u8d28\u6570\uff0c \\(k\\geqslant 1,k\\in \\mathbb{N}\\)\uff0c\u5219 \\(\\varphi \\left( p^k \\right) =\\left( p-1 \\right) p^{k-1}\\)</p> <p>\u7ed3\u8bba\uff1a\u6b27\u62c9\u51fd\u6570\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5373\u82e5 \\(m,n\\) \u4e92\u8d28\uff0c\u5219 \\(\\varphi \\left( m\\cdot n \\right) =\\varphi \\left( m \\right) \\cdot \\varphi \\left( n \\right)\\)</p>"},{"location":"zh/Math/03_Euler_Function/#_3","title":"\u901a\u8fc7\u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570","text":"<p>\u4ee5\u4e0a\u65b9\u6cd5\u9002\u5408\u6c42\u4e00\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570\u7684\u60c5\u5f62\uff0c\u6709\u65f6\u6211\u4eec\u9700\u8981\u6c42\u51fa \\(1\\sim N\\) \u4e2d\u6bcf\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570\uff0c\u53ef\u4ee5\u91c7\u7528\u7ebf\u6027\u7b5b\u6cd5\uff0c\u901a\u8fc7 \\(O(n)\\) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6c42\u51fa\u6bcf\u4e00\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570</p> <p>\u4f8b\u9898\uff1a\u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570</p> <p>\u7ebf\u6027\u7b5b\u6cd5\u7684\u6bcf\u4e2a\u5408\u6570 \\(m\\) \u90fd\u662f\u88ab\u6700\u5c0f\u7684\u8d28\u56e0\u5b50\u7b5b\u6389\u7684\uff0c\u8bbe \\(p_j\\) \u4e3a \\(m\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u5219 \\(m\\) \u901a\u8fc7 \\(m=p_j\\times i\\) \u7b5b\u6389\u3002\u4ee5\u4e0b\u5206\u7c7b\u8ba8\u8bba\uff1a</p> <ul> <li>\u4e00\u4e2a\u8d28\u6570 \\(p\\) \u7684\u6b27\u62c9\u51fd\u6570\u4e3a \\(\\varphi (p)=p-1\\)</li> <li>\u6b27\u62c9\u51fd\u6570\u4e0e\u8d28\u56e0\u5b50\u6b21\u6570\u65e0\u5173\u3002\u5f53 \\(i\\ \\mathrm{mod}\\ p_j=0\\)\u65f6\uff0c\u8bf4\u660e \\(i\\) \u5305\u542b\u4e86 \\(m\\) \u7684\u6240\u6709\u8d28\u56e0\u5b50\u3002\u6709 \\(\\varphi \\left( p_j\\cdot i \\right) =p_j\\cdot \\varphi \\left( i \\right)\\)</li> <li>\u5f53 \\(i\\ \\mathrm{mod}\\ p_j\\ne 0\\)\u65f6\uff0c\u5219 \\(i\\) \u548c \\(p_j\\) \u662f\u4e92\u8d28\u7684\uff0c\u6839\u636e\u7ebf\u6027\u7b5b\u6cd5\u7684\u6027\u8d28\uff0c\u6709 \\(p_j\\) \u5fc5\u4e3a \\(i\\cdot p_j\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u5219 \\(\\varphi \\left( p_j\\cdot i \\right) =p_j\\cdot \\varphi \\left( i \\right) \\cdot \\left( 1-\\frac{1}{p_j} \\right) =\\varphi \\left( i \\right) \\cdot \\left( p_j-1 \\right)\\)</li> </ul> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>int primes[N], cnt;  //primes[]\u5b58\u50a8\u6240\u6709\u8d28\u6570\nint euler[N];  //\u5b58\u50a8\u6bcf\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570\nbool st[N];  //st[x]\u5b58\u50a8x\u662f\u5426\u88ab\u7b5b\u6389\n\nvoid get_eulers(int n) {\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        if (!st[i]) {\n            primes[cnt++] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] &lt;= n / i; j++) {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0) {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n</code></pre> <p>\u6b27\u62c9\u5b9a\u7406\uff1a\u82e5\u6b63\u6574\u6570 \\(n,a\\) \u4e92\u8d28\uff0c\u5219 \\(a^{\\varphi \\left( n \\right)}\\equiv 1  \\left( \\mathrm{mod}\\ n \\right)\\)</p> <p>\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a\u5bf9\u4e8e\u6574\u6570 \\(a\\)\uff0c\u8d28\u6570 \\(p\\)\uff0c\u6709 \\(a^p\\equiv a\\ \\left( \\mathrm{mod}\\ p \\right)\\)\uff1b\u8fdb\u4e00\u6b65\uff0c\u82e5 \\(a\\) \u4e0d\u662f \\(p\\) \u7684\u500d\u6570\uff0c\u5219\u6709 \\(a^{p-1}\\equiv 1\\ \\left( \\mathrm{mod}\\ p \\right)\\)</p>"},{"location":"zh/Math/04_Binary_Exponentiation/","title":"\u5feb\u901f\u5e42","text":""},{"location":"zh/Math/04_Binary_Exponentiation/#_2","title":"\u5feb\u901f\u5e42\u7684\u4ecb\u7ecd","text":"<p>\u5feb\u901f\u5e42(\u4e8c\u8fdb\u5236\u53d6\u5e42)\u662f\u5728\u8f83\u5feb\u65f6\u95f4\u5185\u6c42\u51fa \\(a^k\\ \\left( \\mathrm{mod}\\ p \\right)\\) \u7684\u7ed3\u679c\u7684\u65b9\u6cd5\uff0c\u5176\u4e2d \\(1\\leqslant a,p,k\\leqslant 10^9\\)\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(\\log k)\\)\uff0c\u4ee5\u66ff\u4ee3\u66b4\u529b\u7b97\u6cd5 \\(O(k)\\) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002</p> <p>\u4f8b\u9898\uff1a\u5feb\u901f\u5e42</p> <p>\u8be5\u7b97\u6cd5\u7684\u6838\u5fc3\u662f\u53cd\u590d\u5e73\u65b9\uff0c\u5148\u9884\u5904\u7406\u5982\u4e0b\u7ed3\u679c\uff1a</p> \\[ \\log k\\text{\u4e2a}\\begin{cases}     a^{2^0}\\ \\left( \\mathrm{mod}\\ p \\right)\\\\     a^{2^1}\\ \\left( \\mathrm{mod}\\ p \\right)\\\\     a^{2^2}\\ \\left( \\mathrm{mod}\\ p \\right)\\\\     \\vdots\\\\     a^{2^{\\log k}}\\ \\left( \\mathrm{mod}\\ p \\right)\\\\ \\end{cases} \\] <p>\u4ee5\u4e0a\u9884\u5904\u7406\u7ed3\u679c\u4e4b\u95f4\u6ee1\u8db3\u9012\u63a8\u5173\u7cfb\uff1a \\(a^{2^{t+1}}=\\left( a^{2^t} \\right) ^2\\)</p> <p>\u4e3a\u4e86\u4f7f\u7528\u9884\u5904\u7406\u7ed3\u679c\u7684\u4e58\u79ef\uff0c\u53ef\u4ee5\u5c06 \\(k\\) \u62c6\u6210\u4e8c\u8fdb\u5236\uff1a\u82e5 \\(k=n_s2^s+n_{s-1}2^{s-1}+n_{s-2}2^{s-2}+\\cdots +n_12^1+n_02^0\\)\uff0c\u5176\u4e2d \\(n_i\\in \\left\\{ 0,1 \\right\\}\\)\uff0c\u5219\uff1a</p> \\[ a^k=a^{n_s2^s+n_{s-1}2^{s-1}+n_{s-2}2^{s-2}+\\cdots +n_12^1+n_02^0} \\] \\[ =a^{n_02^0}\\times a^{n_12^1}\\times \\cdots \\times a^{n_s2^s} \\] <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>// \u6c42 m^k (mod p)\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(log(k))\nint fast_power(int m, int k, int p) {\n    int res = 1 % p, t = m;\n    while (k) {\n        if (k &amp; 1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre> <p>\u9632\u6b62<code>int</code>\u6ea2\u51fa\u7684\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>// \u6c42 m^k (mod p)\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(log(k))\nLL fast_power(int m, int k, int p) {\n    //\u4e0eLL res = 1;\u76f8\u6bd4\uff0c\u8fd9\u6837\u5199\u8003\u8651\u5230\u4e86p = 1\u7684\u60c5\u51b5(\u5982p = 1, k = 0)\n    LL res = 1 % p;\n    while (k) {\n        if (k &amp; 1) res = res * m % p;\n        m = m * (LL)m % p;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre>"},{"location":"zh/Math/04_Binary_Exponentiation/#_3","title":"\u5feb\u901f\u5e42\u7684\u5e94\u7528\uff1a\u6c42\u8d28\u6570\u6a21\u7684\u9006\u5143","text":"<p>\u9006\u5143\uff1a\u82e5\u6574\u6570 \\(b,m\\) \u4e92\u8d28\uff0c\u5e76\u4e14\u5bf9\u4e8e\u4efb\u610f\u7684\u6574\u6570 \\(a\\)\uff0c\u82e5\u6ee1\u8db3 \\(\\left. b \\right|a\\)\uff0c\u5219\u5b58\u5728\u4e00\u4e2a\u6574\u6570 \\(x\\)\uff0c\u4f7f\u5f97 \\(\\frac{a}{b}\\equiv a\\cdot x\\ \\left( \\mathrm{mod}\\ m \\right)\\)\uff0c\u5219\u79f0 \\(x\\) \u4e3a \\(b\\) \u7684\u6a21 \\(m\\) \u7684\u4e58\u6cd5\u9006\u5143\uff0c\u8bb0\u4e3a \\(b^{-1}\\ \\left( \\mathrm{mod}\\ m \\right)\\)\u3002</p> <p>\u4f8b\u9898\uff1a\u5feb\u901f\u5e42\u6c42\u9006\u5143</p> <p>\\(b\\) \u5b58\u5728\u4e58\u6cd5\u9006\u5143\u7684\u5145\u8981\u6761\u4ef6\u662f \\(b\\) \u4e0e\u6a21\u6570 \\(m\\) \u4e92\u8d28\uff1b\u9006\u5143\u6ee1\u8db3 \\(b\\cdot b^{-1}\\equiv 1\\ \\left( \\mathrm{mod}\\ m \\right)\\)\uff1b\u5f53\u6a21\u6570 \\(m\\) \u4e3a\u8d28\u6570\u65f6\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c \\(b^{m-2}\\) \u5373\u4e3a \\(b\\) \u7684\u4e58\u6cd5\u9006\u5143\u3002</p>"},{"location":"zh/Math/05_Extended_Euclidean/","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"<p>\u88f4\u8700\u5b9a\u7406(B\u00e9zout's Lemma)\uff1a\u5bf9\u6574\u6570 \\(a,b,m\\)\uff0c\u5173\u4e8e\u672a\u77e5\u6570 \\(x\\) \u548c \\(y\\) \u7684\u7ebf\u6027\u4e0d\u5b9a\u65b9\u7a0b(\u79f0\u4f5c\u88f4\u8700\u7b49\u5f0f) \\(ax+by=m\\) \u6709\u6574\u6570\u89e3\u5f53\u4e14\u4ec5\u5f53 \\(m\\) \u4e3a \\(a,b\\) \u6700\u5927\u516c\u7ea6\u6570 \\(d\\) \u7684\u500d\u6570\u3002\u88f4\u8700\u7b49\u5f0f\u6709\u89e3\u65f6\u5fc5\u7136\u6709\u65e0\u7a77\u591a\u4e2a\u6574\u6570\u89e3\u3002</p> <p>\u63a8\u8bba\uff1a\u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 \\(a,b\\)\uff0c\u5fc5\u5b58\u5728\u975e\u96f6\u6574\u6570 \\(x,y\\)\uff0c\u4f7f\u5f97 \\(ax+by=\\mathrm{gcd}(a,b)\\)\u3002</p>"},{"location":"zh/Math/05_Extended_Euclidean/#_2","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u7b80\u4ecb","text":"<p>\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u662f\u8f97\u8f6c\u76f8\u9664\u6cd5\u7684\u6269\u5c55\u3002\u5df2\u77e5\u6574\u6570 \\(a,b\\)\uff0c\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u53ef\u4ee5\u5728\u6c42\u5f97 \\(a,b\\) \u7684\u6700\u5927\u516c\u7ea6\u6570\u7684\u540c\u65f6\uff0c\u627e\u5230\u6574\u6570 \\(x,y\\) (\u5176\u4e2d\u4e00\u4e2a\u53ef\u80fd\u662f\u8d1f\u6570)\uff0c\u4f7f\u5b83\u4eec\u6ee1\u8db3\u88f4\u8700\u7b49\u5f0f \\(ax+by=\\mathrm{gcd}(a,b)\\)\u3002\u5982\u679c \\(a\\) \u662f\u8d1f\u6570\uff0c\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u5316\u6210 \\(\\left| a \\right|\\cdot \\left( -x \\right) +b\\cdot y=\\mathrm{gcd}\\left( \\left| a \\right|,b \\right)\\)\uff0c\u7136\u540e\u4ee4 \\(x\\prime=-x\\)</p> <p>\u4f8b\u9898\uff1a\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5</p> <p>\u6c42\u89e3\u65b9\u7a0b \\(ax+by=\\mathrm{gcd}(a,b)\\)\uff1a</p> <p>\u5f53 \\(b=0\\) \u65f6\uff0c \\(ax+by=a\\)\uff0c\u6545 \\(x=1,\\ y=0\\) \u662f\u4e00\u7ec4\u89e3</p> <p>\u5f53 \\(b\\ne 0\\) \u65f6\uff0c\u56e0\u4e3a \\(\\mathrm{gcd}(a,b) =\\mathrm{gcd}(b,a\\%b)\\)\uff0c\u5219 \\(bx\\prime+(a\\%b) y\\prime=\\mathrm{gcd}(b,a\\%b)\\)\uff0c\u53ef\u77e5\uff1a</p> \\[ b\\cdot x\\prime+(a-\\lfloor \\frac{a}{b} \\rfloor \\cdot b) \\cdot y\\prime=\\mathrm{gcd}(b,a\\%b) ; \\] \\[ \\Rightarrow a\\cdot y\\prime+b\\cdot( x\\prime-\\lfloor \\frac{a}{b} \\rfloor \\cdot y\\prime) =\\mathrm{gcd}( b,a\\%b) =\\mathrm{gcd}(a,b) \\] <p>\u6545 \\(x=y\\prime, y=x\\prime-\\lfloor \\frac{a}{b} \\rfloor \\cdot y\\prime\\)\uff0c\u53ef\u4ee5\u91c7\u7528\u9012\u5f52\u7b97\u6cd5\uff0c\u5148\u6c42\u51fa\u4e0b\u4e00\u5c42\u7684 \\(x\\prime\\) \u548c \\(y\\prime\\)\uff0c\u518d\u5229\u7528\u4e0a\u8ff0\u516c\u5f0f\u8fdb\u884c\u56de\u4ee3\u3002</p> <p>\u4ee3\u7801\u6a21\u677f\uff1a</p> <pre><code>// \u6c42x, y\uff0c\u4f7f\u5f97ax + by = gcd(a, b)\nint ex_gcd(int a, int b, int &amp;x, int &amp;y) {\n    if (!b) {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = ex_gcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\n</code></pre> <p>\u7ed3\u8bba\uff1a\u8bbe\u65b9\u7a0b \\(ax+by=c\\) (\u5176\u4e2d \\(a,b\\) \u4e3a\u975e\u96f6\u6574\u6570)\u6709\u4e00\u7ec4\u6574\u6570\u89e3 \\(x=x_0, y=y_0\\)\uff0c\u5219\u65b9\u7a0b\u7684\u6240\u6709\u6574\u6570\u89e3(\u901a\u89e3)\u53ef\u4ee5\u8868\u793a\u4e3a\uff1a</p> \\[ \\begin{cases}     x=x_0-\\frac{b}{\\mathrm{gcd}\\left( a,b \\right)}t\\\\     y=y_0+\\frac{a}{\\mathrm{gcd}\\left( a,b \\right)}t\\\\ \\end{cases} \\]"},{"location":"zh/Math/05_Extended_Euclidean/#_3","title":"\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b","text":"<p>\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b\uff1a\u5f62\u5982 \\(ax\\equiv b\\ (\\mathrm{mod}\\ n)\\) \u7684\u65b9\u7a0b\u79f0\u4e3a\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b\uff0c\u5176\u4e2d \\(a,b,n\\) \u4e3a\u7ed9\u5b9a\u6574\u6570\uff0c \\(x\\) \u4e3a\u672a\u77e5\u6570\u3002</p> <p>\u4f8b\u9898\uff1a\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b</p> <p>\u4e0a\u8ff0\u539f\u65b9\u7a0b\u7b49\u4ef7\u4e3a \\(\\exists y\\in \\mathbb{Z}\\)\uff0c\u4f7f\u5f97 \\(ax=my+b\\)\uff0c\u4e5f\u5c31\u662f \\(ax-my=b\\)</p> <p>\u4ee4 \\(y\\prime =-y\\)\uff0c\u5219\u539f\u95ee\u9898\u53d8\u4e3a \\(ax+my\\prime =b\\)\uff1b\u53ea\u8981 \\(\\left. \\mathrm{gcd}\\left( a,m \\right) \\right|b\\)\uff0c\u5219\u65b9\u7a0b\u6709\u89e3\u3002</p> <p>\u8bbe \\(d=\\mathrm{gcd}\\left( a,m \\right)\\) \uff0c\u5728\u6709\u89e3\u65f6\uff0c\u5148\u7528\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u51fa\u4e00\u7ec4\u6574\u6570 \\(x_0, y_0\\)\uff0c\u6ee1\u8db3 \\(ax_0 + by_0 = d\\)\uff0c\u8be5\u7b49\u5f0f\u53ea\u9700\u6269\u5927 \\(\\frac{b}{d}\\) \u500d\uff0c\u5373\u53ef\u53d8\u4e3a \\(ax+my\\prime=b\\)\u3002\u56e0\u6b64 \\(x=x_0\\cdot \\frac{b}{d}\\) \u5c31\u662f\u539f\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b\u7684\u4e00\u4e2a\u89e3</p>"},{"location":"zh/Math/06_Chinese_Remainder_Theorem/","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"<p>\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff1a\u5bf9\u4e8e\u4ee5\u4e0b\u7684\u4e00\u5143\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b\u7ec4\uff1a</p> \\[ \\left( S \\right) : \\begin{cases}     x\\equiv a_1\\ \\left( \\mathrm{mod}\\ m_1 \\right)\\\\     x\\equiv a_2\\ \\left( \\mathrm{mod}\\ m_2 \\right)\\\\     \\vdots\\\\     x\\equiv a_n\\ \\left( \\mathrm{mod}\\ m_n \\right)\\\\ \\end{cases} \\] <p>\u82e5\u6574\u6570 \\(m_1, m_2,\\cdots , m_n\\) \u4e2d\u4efb\u610f\u4e24\u6570\u4e92\u8d28\uff0c\u5219\u5bf9\u4efb\u610f\u7684\u6574\u6570 \\(a_1, a_2,\\cdots , a_n\\)\uff0c\u65b9\u7a0b\u7ec4 \\((S)\\) \u6709\u89e3\uff0c\u4e14\u901a\u89e3\u53ef\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u6784\u9020\u5f97\u5230\uff1a</p> <ul> <li>\u8bbe \\(M=m_1\\times m_2\\times \\cdots \\times m_n=\\prod_{i=1}^n{m_i}\\) \u4e3a\u6574\u6570 \\(m_1, m_2,\\cdots , m_n\\) \u7684\u4e58\u79ef\uff0c\u5e76\u8bbe \\(\\forall i=1,2,\\cdots ,n:\\ M_i=\\frac{M}{m_i}\\)\uff0c\u5373 \\(M_i\\) \u662f\u9664\u4e86 \\(m_i\\) \u4e4b\u5916\u7684 \\(n-1\\) \u4e2a\u6574\u6570\u7684\u4e58\u79ef\uff1b</li> <li>\u8bbe \\(t_i={M_i}^{-1}\\) \u4e3a \\(M_i\\) \u6a21 \\(m_i\\) \u7684\u6a21\u9006\u5143\uff0c\u5373 \\(t_iM_i\\equiv 1\\ \\left( \\mathrm{mod}\\ m_i \\right) ,\\ \\forall i=1,2,\\cdots ,n\\)\uff1b</li> <li>\u65b9\u7a0b\u7ec4 \\((S)\\) \u7684\u901a\u89e3\u5f62\u5f0f\u4e3a\uff1a</li> </ul> \\[ x=a_1t_1M_1+a_2t_2M_2+\\cdots +a_nt_nM_n+kM=kM+\\sum_{i=1}^n{a_it_iM_i},\\ k\\in \\mathbb{Z}  \\] <p>\u5728\u6a21 \\(M\\) \u7684\u610f\u4e49\u4e0b\uff0c\u65b9\u7a0b\u7ec4 \\((S)\\) \u4ec5\u6709\u4e00\u4e2a\u89e3\uff1a</p> \\[ x=\\sum_{i=1}^n{a_it_iM_i} \\]"},{"location":"zh/Math/07_Gaussian_Elimination/","title":"\u9ad8\u65af\u6d88\u5143\u6cd5","text":""},{"location":"zh/Math/07_Gaussian_Elimination/#_2","title":"\u9ad8\u65af\u6d88\u5143\u6cd5\u7684\u6c42\u89e3","text":"<p>\u9ad8\u65af\u6d88\u5143\u6cd5\u53ef\u4ee5\u4ee5 \\(O(n^3)\\) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6c42\u89e3 \\(n\\) \u4e2a\u672a\u77e5\u6570\u7684\u7ebf\u6027\u65b9\u7a0b\u7ec4\uff0c\u6838\u5fc3\u662f\u5148\u628a\u7cfb\u6570\u77e9\u9635\u6d88\u6210\u4e0a\u4e09\u89d2\u77e9\u9635\uff0c\u518d\u4ece\u4e0b\u5230\u4e0a\u56de\u4ee3\u6c42\u89e3\u3002</p> <p>\u5bf9\u4e8e\u4ee5\u4e0b\u7ebf\u6027\u65b9\u7a0b\u7ec4\uff1a</p> \\[ \\boldsymbol{Ax}=\\boldsymbol{b} \\] \\[ \\boldsymbol{A}=\\left[ \\begin{array}{l}     a_{11}&amp;     a_{12}&amp;     \\cdots&amp;     a_{1n}\\\\     a_{21}&amp;     a_{22}&amp;     \\cdots&amp;     a_{2n}\\\\     \\vdots&amp;     \\vdots&amp;     \\ddots&amp;     \\vdots\\\\     a_{n1}&amp;     a_{n2}&amp;     \\cdots&amp;     a_{nn}\\\\ \\end{array} \\right] , \\boldsymbol{x}=\\left[ \\begin{array}{c}     x_1\\\\     x_2\\\\     \\vdots\\\\     x_n\\\\ \\end{array} \\right] , \\boldsymbol{b}=\\left[ \\begin{array}{c}     b_1\\\\     b_2\\\\     \\vdots\\\\     b_n\\\\ \\end{array} \\right]  \\] <p>\u589e\u5e7f\u77e9\u9635\uff1a</p> \\[ \\bar{\\boldsymbol{A}}=\\left[ \\begin{array}{c:c}     \\boldsymbol{A}&amp;     \\boldsymbol{b}\\\\ \\end{array} \\right] =\\left[ \\begin{array}{cccc:c}     a_{11}&amp;     a_{12}&amp;     \\cdots&amp;     a_{1n}&amp;     b_1\\\\     a_{21}&amp;     a_{22}&amp;     \\cdots&amp;     a_{2n}&amp;     b_2\\\\     \\vdots&amp;     \\vdots&amp;     \\ddots&amp;     \\vdots&amp;     \\vdots\\\\     a_{n1}&amp;     a_{n2}&amp;     \\cdots&amp;     a_{nn}&amp;     b_n\\\\ \\end{array} \\right] \\in \\mathbb{R} ^{n\\times \\left( n+1 \\right)} \\] <p>\u4f8b\u9898\uff1a\u9ad8\u65af\u6d88\u5143\u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4</p> <p>\u5982\u4e0b\u4e09\u7c7b\u53d8\u6362\u4e0d\u6539\u53d8\u539f\u65b9\u7a0b\u7684\u89e3\uff0c\u79f0\u4e3a\u521d\u7b49\u884c(\u5217)\u53d8\u6362\uff1a</p> <ul> <li>\u628a\u67d0\u4e00\u884c\u4e58\u4e00\u4e2a\u975e\u96f6\u7684\u6570</li> <li>\u4ea4\u6362\u67d0\u4e24\u884c</li> <li>\u628a\u67d0\u884c\u7684\u82e5\u5e72\u500d\u52a0\u5230\u53e6\u4e00\u884c\u4e0a\u53bb</li> </ul> <p>\u4e3a\u4e86\u6c42\u89e3\u65b9\u7a0b\uff0c\u6700\u7ec8\u9700\u8981\u5c06\u589e\u5e7f\u77e9\u9635\u505a\u521d\u7b49\u884c\u53d8\u6362\u5316\u4e3a\u5982\u4e0b\u7684\u68af\u5f62\u77e9\u9635\uff1a</p> \\[ \\left[ \\begin{array}{cccc:c}     1&amp;      &amp;       &amp;       &amp;       \\xi _1\\\\     &amp;       1&amp;      &amp;       &amp;       \\xi _2\\\\     &amp;       &amp;       \\ddots&amp;     &amp;       \\vdots\\\\     &amp;       &amp;       &amp;       1&amp;      \\xi _n\\\\ \\end{array} \\right]  \\] <p>\u901a\u8fc7\u521d\u7b49\u53d8\u6362\u53ef\u4ee5\u9996\u5148\u5c06\u7cfb\u6570\u77e9\u9635\u8f6c\u5316\u6210\u4e0a\u4e09\u89d2\u77e9\u9635\uff0c\u8f6c\u5316\u6210\u7684\u77e9\u9635\u53ef\u80fd\u6709\u5982\u4e0b\u60c5\u51b5\uff1a</p> <ul> <li>\u5b8c\u7f8e\u9636\u68af\u5f62\uff1a\u552f\u4e00\u89e3</li> <li>\u51fa\u73b0\u4e86\u201c0=\u975e0\u201d\u7684\u7b49\u5f0f\uff1a\u65e0\u89e3</li> <li>\u51fa\u73b0\u4e86\u201c0=0\u201d\u7684\u7b49\u5f0f\uff1a\u65e0\u7a77\u591a\u7ec4\u89e3</li> </ul> <p>\u679a\u4e3e\u6bcf\u4e00\u5217<code>c</code>\u4e3b\u5143\uff1a</p> <ul> <li>\u627e\u5230\u6bcf\u5217\u7684\u7edd\u5bf9\u503c\u6700\u5927\u7684\u4e00\u4e2a\u975e0\u7684\u6570\u6240\u5728\u884c</li> <li>\u5c06\u7b2c\u4e00\u884c\u7684\u503c\u4e0e\u8be5\u884c\u4ea4\u6362\uff0c\u4f7f\u5f97\u8be5\u884c\u6362\u5230\u6700\u4e0a\u9762</li> <li>\u5c06\u7b2c\u4e00\u884c\u7684\u6570\u5b57\u9664\u4ee5\u8be5\u6570\uff0c\u4f7f\u5f97\u8be5\u884c\u7684\u7b2c\u4e00\u4e2a\u6570\u6210\u4e3a1</li> <li>\u5bf9\u6bcf\u4e00\u884c\u505a\u521d\u7b49\u53d8\u6362\uff0c\u4f7f\u5f97\u4e0b\u9762\u6240\u6709\u884c\u7684\u7b2c<code>c</code>\u5217\u53d8\u4e3a0</li> </ul>"},{"location":"zh/Math/07_Gaussian_Elimination/#lu","title":"\u62d3\u5c55\uff1aLU\u5206\u89e3","text":"<p>\u8bbe \\(\\boldsymbol{A}\\in \\mathbb{R} ^{n\\times n}\\)\uff0c \\(\\boldsymbol{PA}=\\boldsymbol{LU}\\)\uff0c\u9ad8\u65af\u6d88\u5143\u6cd5\u7684LU\u5206\u89e3\u6b65\u9aa4\u4e3a\uff1a</p> <p>\u4ee4 \\(\\boldsymbol{U}=\\boldsymbol{A}, \\boldsymbol{L}=\\mathbf{I}, \\boldsymbol{P}=\\mathbf{I}\\)\uff1b</p> <p>For \\(k=1,2,\\cdots ,n-1\\):</p> <ul> <li>\u9009\u62e9 \\(i\\geqslant k\\) \uff0c\u4f7f\u5f97 \\(|u_{ik}|\\) \u6700\u5927\uff1b</li> <li>\\(u_{k,k:n}\\leftrightarrow u_{i,k:n}\\) (\u4ea4\u6362\u4e24\u884c)\uff1b</li> <li>\\(l_{k,1:k-1}\\leftrightarrow l_{i,1:k-1}\\)\uff1b</li> <li>\\(p_{k,:}\\leftrightarrow p_{i,:}\\)\uff1b</li> <li>For \\(j=k+1,k+2,\\cdots ,n\\):</li> <li>\\(l_{jk}=\\frac{u_{jk}}{u_{kk}}\\)\uff1b</li> <li>\\(u_{j,k:m}=u_{j,k:m}-l_{jk}u_{k,k:m}\\)\uff1b</li> </ul> <p>\u73b0\u5728\u5f97\u5230\u4e86 \\(\\boldsymbol{Rx}=\\boldsymbol{b}\\)\uff0c\u5373\uff1a</p> \\[ \\left[ \\begin{matrix}     r_{11}&amp;     r_{12}&amp;     \\cdots&amp;     r_{1n}\\\\     &amp;       r_{22}&amp;     &amp;       \\vdots\\\\     &amp;       &amp;       \\ddots&amp;     \\vdots\\\\     &amp;       &amp;       &amp;       r_{nn}\\\\ \\end{matrix} \\right] \\left[ \\begin{array}{c}     x_1\\\\     x_2\\\\     \\vdots\\\\     x_n\\\\ \\end{array} \\right] =\\left[ \\begin{array}{c}     b_1\\\\     b_2\\\\     \\vdots\\\\     b_n\\\\ \\end{array} \\right]  \\] <p>\u4ee5\u4e0a\u6b65\u9aa4\u5b8c\u6210\u540e\uff0c\u53cd\u5411\u66ff\u4ee3\u7684\u8fc7\u7a0b\u4e3a\uff1a</p> \\[ x_n=\\frac{b_n}{r_{nn}}; \\] \\[ x_{n-1}=\\frac{b_{n-1}-x_nr_{n-1,n}}{r_{n-1,n-1}}; \\] \\[ x_{n-2}=\\frac{b_{n-2}-x_{n-1}r_{n-2,n-1}-x_nr_{n-2,n}}{r_{n-2,n-2}}; \\] \\[ \\vdots  \\] \\[ x_j=\\frac{1}{r_{jj}}\\left( b_j-\\sum_{k=j+1}^n{x_kr_{jk}} \\right)  \\] <p>\u6ce8\uff1a\u5728\u4ee3\u7801\u7684\u505a\u6cd5\u4e2d\uff0c\u5df2\u6709 \\(r_{ii}=1\\)\uff0c\u4ee5\u4e0a\u63cf\u8ff0\u7684\u6b65\u9aa4\u9002\u7528\u8303\u56f4\u66f4\u5e7f\u3002</p>"},{"location":"zh/Math/08_Combinatorial_Number/","title":"\u7ec4\u5408\u6570\u7684\u8ba1\u7b97","text":"<p>\u4ece \\(n\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u4e2d\u53d6\u51fa \\(k\\) \u4e2a\u5143\u7d20\u7684\u6240\u6709\u4e0d\u540c\u7ec4\u5408\u7684\u4e2a\u6570\uff0c\u53eb\u505a\u4ece \\(n\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u4e2d\u53d6\u51fa \\(k\\) \u4e2a\u5143\u7d20\u7684\u7ec4\u5408\u6570\uff0c\u8bb0\u4f5c \\(C_{n}^{k}\\)</p> <p>\\(C_{n}^{k}\\) \u7684\u516c\u5f0f\u4e3a\uff1a</p> \\[ C_{n}^{k}=\\left( \\begin{array}{c}     n\\\\     k\\\\ \\end{array} \\right) =\\frac{A_{n}^{k}}{k!} \\] \\[ =\\frac{n\\times \\left( n-1 \\right) \\times \\cdots \\times \\left( n-k+1 \\right)}{1\\times 2\\times 3\\times \\cdots \\times k}=\\frac{n!}{k!\\cdot \\left( n-k \\right) !} \\]"},{"location":"zh/Math/08_Combinatorial_Number/#_2","title":"\u8ba1\u7b97\u7ec4\u5408\u6570","text":""},{"location":"zh/Math/08_Combinatorial_Number/#_3","title":"\u57fa\u672c\u9012\u63a8\u6c42\u6cd5","text":"<p>\u4f8b\u9898\uff1a\u6c42\u7ec4\u5408\u6570 1</p> <p>\u5bf9\u4e8e\u7ec4\u5408\u6570\uff0c\u6709\u5982\u4e0b\u9012\u63a8\u5f0f\uff1a</p> \\[ C_{n}^{k}=C_{n-1}^{k-1}+C_{n-1}^{k} \\]"},{"location":"zh/Math/08_Combinatorial_Number/#_4","title":"\u4f7f\u7528\u9006\u5143\u7684\u6c42\u6cd5","text":"<p>\u53e6\u4e00\u79cd\u7ec4\u5408\u6570\u7684\u6c42\u6cd5\uff1a</p> <p>\u4f8b\u9898\uff1a\u6c42\u7ec4\u5408\u6570 2</p> <p>\u6ce8\u610f\u5230\uff1a</p> \\[ C_{a}^{b}=\\frac{a!}{b!\\cdot \\left( a-b \\right) !}\\equiv a!\\cdot \\left( b! \\right) ^{-1}\\cdot \\left( \\left( a-b \\right) ! \\right) ^{-1}\\ \\ \\left( \\mathrm{mod}\\ p \\right)  \\] <p>\u4e0a\u8ff0\"-1\"\u4ee3\u8868\u4e58\u6cd5\u9006\u5143\u3002</p> <p>\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c\u82e5 \\(p\\) \u4e3a\u8d28\u6570\uff0c\u4e14\u6574\u6570 \\(b\\) \u4e0d\u662f \\(p\\) \u7684\u500d\u6570\uff0c\u5219 \\(b^{p-1}\\equiv 1\\ \\left( \\mathrm{mod}\\ p \\right)\\)\uff0c\u56e0\u6b64 \\(b\\cdot b^{-1}\\equiv b\\cdot b^{p-2}\\equiv 1\\ \\left( \\mathrm{mod}\\ p \\right)\\)\uff0c\u6545 \\(b^{-1}\\equiv b^{p-2}\\)\u3002</p>"},{"location":"zh/Math/08_Combinatorial_Number/#_5","title":"\u4f7f\u7528\u5362\u5361\u65af\u5b9a\u7406\u7684\u6c42\u6cd5","text":"<p>\u53e6\u4e00\u79cd\u7ec4\u5408\u6570\u6c42\u6cd5\uff1a</p> <p>\u4f8b\u9898\uff1a\u6c42\u7ec4\u5408\u6570 3</p> <p>\u5362\u5361\u65af\u5b9a\u7406\uff1a\u5bf9\u4e8e\u975e\u8d1f\u6574\u6570 \\(m,n\\) \u548c\u8d28\u6570 \\(p\\)\uff0c\u4ee5\u4e0b\u540c\u4f59\u5f0f\uff1a</p> \\[ C_{m}^{n}\\equiv \\prod_{i=0}^k{C_{m_i}^{n_i}}\\ \\ \\left( \\mathrm{mod}\\ p \\right)  \\] <p>\u6210\u7acb\uff0c\u5176\u4e2d \\(m=m_kp^k+m_{k-1}p^{k-1}+\\cdots +m_1p+m_0\\) \u4ee5\u53ca \\(n=n_kp^k+n_{k-1}p^{k-1}+\\cdots +n_1p+n_0\\) \u662f \\(m\\) \u548c \\(n\\) \u7684 \\(p\\) \u8fdb\u5236\u5c55\u5f00\u3002</p> <p>\u7279\u522b\u5730\uff0c\u5bf9\u4e8e\u8d28\u6570 \\(p\\) \uff0c\u6709\uff1a</p> \\[ C_{m}^{n}\\ \\ \\left( \\mathrm{mod}\\ p \\right) \\ \\ \\equiv \\ \\ C_{\\lfloor m/p \\rfloor}^{\\lfloor n/p \\rfloor}\\cdot C_{m\\left( \\mathrm{mod}\\ p\\ \\right)}^{n\\left( \\mathrm{mod}\\ p \\right)}\\ \\ \\left( \\mathrm{mod}\\ p \\right)  \\] <p>\u5bf9\u4e8e\u7ec4\u5408\u6570\u516c\u5f0f\u53ef\u505a\u5982\u4e0b\u53d8\u6362\uff1a</p> \\[ C_{n}^{k}=\\frac{n!}{k!\\cdot \\left( n-k \\right) !}=\\frac{n\\left( n-1 \\right) \\left( n-2 \\right) \\cdots \\left( n-k+1 \\right)}{k!} \\] \\[ \\equiv n\\times \\left( n-1 \\right) \\times \\cdots \\times \\left( n-k+1 \\right) \\times 1^{-1}\\times 2^{-1}\\times \\cdots \\times k^{-1}\\ \\ \\left( \\mathrm{mod}\\ p \\right)  \\] <p>\u4f7f\u7528\u5362\u5361\u65af\u5b9a\u7406\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O\\left( \\log _pN\\cdot p\\cdot \\log p \\right)\\)</p>"},{"location":"zh/Math/08_Combinatorial_Number/#_6","title":"\u7ec4\u5408\u6570\u5177\u4f53\u6570\u503c\u8ba1\u7b97(\u9ad8\u7cbe\u5ea6)","text":"<p>\u5982\u679c\u9700\u8981\u6c42\u51fa\u7ec4\u5408\u6570\u7684\u5177\u4f53\u6570\u503c\u800c\u4e0d\u53d6\u6a21\uff0c\u9700\u8981\u7528\u5230\u9ad8\u7cbe\u5ea6\u6570\u5b57\u8868\u793a\u3002</p> <p>\u4f8b\u9898\uff1a\u6c42\u7ec4\u5408\u6570 4</p> <p>\u5728\u6c42\u4e4b\u524d\uff0c\u53ef\u4ee5\u628a \\(C_{n}^{k}\\) \u5206\u89e3\u8d28\u56e0\u6570\uff0c\u8fd9\u6837\u53ea\u9700\u5b9e\u73b0\u9ad8\u7cbe\u5ea6\u4e58\u6cd5\u5373\u53ef\u3002\u5728\u8d28\u56e0\u6570\u5206\u89e3\u65f6\u6700\u597d\u4f7f\u7528\u6b64\u516c\u5f0f\uff1a \\(C_{n}^{k}=\\frac{n!}{k!\\cdot \\left( n-k \\right) !}\\)\u3002\u5982\u4f55\u6c42\u4e00\u4e2a\u9636\u4e58\u5305\u542b\u7684\u8d28\u56e0\u5b50\uff1f\u6709\u7ed3\u8bba(\u52d2\u8ba9\u5fb7\u5b9a\u7406)\uff1a \\(n!\\) \u4e2d\u8d28\u56e0\u5b50 \\(p\\) \u7684\u6b21\u6570\u4e3a\uff1a</p> \\[ d_p\\left( n! \\right) =\\lfloor \\frac{n}{p} \\rfloor +\\lfloor \\frac{n}{p^2} \\rfloor +\\lfloor \\frac{n}{p^3} \\rfloor +\\cdots =\\sum_{i=1}^{\\infty}{\\lfloor \\frac{n}{p^k} \\rfloor}=\\sum_{k=1}^{\\lfloor \\log _pn \\rfloor}{\\lfloor \\frac{n}{p^k} \\rfloor} \\] <p>\u6b65\u9aa4\uff1a</p> <ul> <li>\u7b5b\u8d28\u6570(\u672c\u9898\u53ef\u4ee5\u628a1~5000\u5185\u7684\u8d28\u6570\u7b5b\u51fa\u6765)</li> <li>\u6839\u636e\u4e0a\u8ff0\u516c\u5f0f\u6c42\u6bcf\u4e2a\u8d28\u6570\u7684\u6b21\u6570</li> <li>\u7528\u9ad8\u7cbe\u5ea6\u4e58\u628a\u6240\u6709\u8d28\u56e0\u5b50\u4e58\u4e0a</li> </ul>"},{"location":"zh/Math/08_Combinatorial_Number/#_7","title":"\u5361\u5854\u5170\u6570","text":"<p>\u4f8b\u9898\uff1a\u6ee1\u8db3\u6761\u4ef6\u768401\u5e8f\u5217</p> <p>\u5361\u5854\u5170\u6570 \u7684\u5b9a\u4e49\u4e3a\uff1a</p> \\[ C_n=\\frac{C_{2n}^{n}}{n+1}=\\frac{\\left( 2n \\right) !}{\\left( n+1 \\right) !\\cdot n!} \\] <p>\u5c0601\u5e8f\u5217\u7f6e\u4e8e\u5750\u6807\u7cfb\u4e2d\uff0c\u8d77\u70b9\u5b9a\u4e8e\u539f\u70b9\u3002\u82e50\u8868\u793a\u5411\u53f3\u8d70\uff0c1\u8868\u793a\u5411\u4e0a\u8d70\uff0c\u90a3\u4e48\u4efb\u4f55\u524d\u7f00\u4e2d0\u7684\u4e2a\u6570\u4e0d\u5c11\u4e8e1\u7684\u4e2a\u6570\u5c31\u8f6c\u5316\u4e3a\uff1a\u8def\u5f84\u4e0a\u7684\u4efb\u610f\u4e00\u70b9\uff0c\u6a2a\u5750\u6807\u5927\u4e8e\u7b49\u4e8e\u7eb5\u5750\u6807\u3002\u9898\u76ee\u6240\u6c42\u5373\u4e3a\u8fd9\u6837\u7684\u5408\u6cd5\u8def\u5f84\u6570\u91cf\u3002\u4e5f\u5c31\u662f\u6c42\u5728n\u4e58n\u683c\u70b9\u4e2d\u4e0d\u8d8a\u8fc7\u5bf9\u89d2\u7ebf\u7684\u5355\u8c03\u8def\u5f84\u7684\u4e2a\u6570\u3002\u4e00\u4e2a\u5355\u8c03\u8def\u5f84\u4ece\u683c\u70b9\u5de6\u4e0b\u89d2\u51fa\u53d1\uff0c\u5728\u683c\u70b9\u53f3\u4e0a\u89d2\u7ed3\u675f\uff0c\u6bcf\u4e00\u6b65\u5747\u4e3a\u5411\u4e0a\u6216\u5411\u53f3\u3002\u8ba1\u7b97\u7ed3\u679c\u4e3a\uff1a</p> \\[ C_n=C_{2n}^{n}-C_{2n}^{n+1}=\\frac{1}{n+1}C_{2n}^{n} \\]"},{"location":"zh/Miscellaneous/","title":"\u6742\u9879","text":""}]}
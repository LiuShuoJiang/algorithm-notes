# 双指针算法

## 类型

常见问题分类：

- 一个数组两个指针：对于一个序列，用两个指针维护一段区间，如快速排序
- 两个数组各一个指针：对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

核心思想：将算法时间复杂度从朴素算法的 $O(n^2)$ 降低到 $O(n)$

```C++
for (int i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j++;

    //每道题目的具体逻辑
}
```

>例题：[输出字符串](./output_string.cpp)
>例题：[数组元素的目标和](./target_sum.cpp) 注意要寻找单调性

## 范例：最长连续不重复子序列

>例题：[最长连续不重复子序列](./unrepeated_sequence.cpp)

- 遍历数组`a`中的每一个元素`a[i]`, 对于每一个`i`，找到`j`使得双指针`[j, i]`维护的是以`a[i]`结尾的最长连续不重复子序列，长度为`i - j + 1`, 将这一长度与`res`的较大者更新给`res`。
- 对于每一个`i`，如何确定`j`的位置：由于`[j, i - 1]`是前一步得到的最长连续不重复子序列，所以如果`[j, i]`中有重复元素，一定是`a[i]`，因此右移`j`直到`a[i]`不重复为止(由于`[j, i - 1]`已经是前一步的最优解，此时`j`只可能右移以剔除重复元素`a[i]`，不可能左移增加元素，因此，`j`具有“单调性”、本题可用双指针降低复杂度)。
- 用数组`s`记录子序列`a[j ~ i]`中各元素出现次数，遍历过程中对于每一个`i`有四步操作：`cin`元素`a[i]` -> 将`a[i]`出现次数`s[a[i]]`加`1` -> 若`a[i]`重复则右移`j`（`s[a[j]]`要减`1`） -> 确定`j`及更新当前长度`i - j + 1`给`res`。

注：当数据范围很大时，可以用哈希表做。

```C++
# include <iostream>
using namespace std;
const int N = 100010;
int a[N], s[N];
int main() {
    int n, res = 0;
    cin >> n;
    for (int i = 0, j = 0; i < n; ++ i) {
        cin >> a[i];
        ++s[a[i]];
        // 当a[i]重复时，先把a[j]次数减1，再右移j。
        while (s[a[i]] > 1) --s[a[j++]];
        res = max(r, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```
